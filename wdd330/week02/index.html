<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta
      name="description"
      content="My notes and codes from this weeks reading assignment."
    />
    <meta name="author" content="Jesse Wilson" />

    <!-- SITE TITLE -->
    <title>Week 2 Notes & Code</title>

    <!-- TELLS PHONES NOT TO LIE ABOUT THEIR WIDTH & stops the font from
      enlarging when a phone is turned sideways-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- STYLE SHEETS -->
    <link href="css/normalize.css" rel="stylesheet" />
    <!-- phone-default -->
    <link href="css/small.css" rel="stylesheet" />
    <!-- enhance-tablet -->
    <link href="css/medium.css" rel="stylesheet" />
    <!-- enhance-desktop -->
    <link href="css/large.css" rel="stylesheet" />

    <!-- JAVASCRIPTS-->
    <script defer src="js/style.js"></script>
  </head>
  <body>
    <!-- HEADER HERE -->
    <header id="headerWrapper">
      <h1>Week 2 Notes & Codes</h1>
    </header>

    <!-- NAVIGATION HERE -->
    <nav></nav>

    <!-- CONTENT HERE -->
    <main>
      <!-- Notes from Chapter 1 -->
      <div>
        <a href="activity.html"><h2>Team Activity</h2></a>
        <h1>Notes from JavaScript: Novice to Ninja - Chapter 2:</h1>
        <h2>Variables</h2>
        <p>
          When you use const in front of a variable, it won't be assigned to
          another variable of the same kind. When you use let in front of a
          variable. it can be changed at any time. If you try to do it on
          purpose or by accident, you will get an error, "<b
            >&lt;&lt; TypeError: Assignment to constant variable</b
          >". <br /><br />
          While in the console, you can type <b>typeof</b> in front of the
          variable to find out what type of variable is. <br /><br />
          For example if the following was true:
          <b>const firstName = "Jesse";</b> then it would come back with string.
        </p>
        <p>
          You can declair more than one variable at a time.For example, you
          could write a line of code as:
          <br /><br />
          &emsp; <b>let x = 3, y = 4, z = 5;</b>
        </p>
        <p>
          Above it says you cannot change the value of the variable if you use
          const in front of it but it is possible to accomplish. If const is
          used with an array, the values within the array can be changed.
          <br /><br />
          &emsp; <b>const name = { value: 'Alexa'};</b> // This is an object.
          <br /><br />
          You can change the value within the array by typing the follow:
          <br /><br />
          &emsp; <b>name.value = 'Siri';</b> // Change the value. <br /><br />
          You cannot change the value by typing:
          <b>const name = { value: 'Siri'};</b>
          <br />
          It would come back with the same error when you tried to change a
          const variable, "<b>&lt;&lt; TypeError: Assignment to constant variable.</b
          >"
        </p>
        <p>
          Using const and let to declare variables that are not inside of a
          block '{ }' and can be accessed throughout the program would be
          considered a Gobal Scope. If a variable is found inside of a block it
          is considered a local scope. It can only affect anything inside the
          function. If const or let are not used in a block it can be used
          inside or outside a block. To prevent peoblems, always use const or
          let with your variables.
        </p>
      </div>
      <div>
        <h2>Converting Strings to Numbers</h2>
        <p>
          Strings can be converted to numbers:
          <br /><br />
          &emsp; <b>Number('23');</b> the number 23 would be returned.
          <br /><br />
          &emsp; <b>const answer = '5' * 1;</b> the number 5 would be returned.
          <br /><br />
          &emsp; <b>const answer = + '5';</b> 5 would be returned. If you used
          <b>typeof</b> infront of the variable 'answer', the "number" would be
          returned. <br /><br />
          If you tried <b>Number('hello')</b> NaN would be returned.
        </p>
      </div>
      <div>
        <h2>Converting Numbers to Strings</h2>
        <p>
          Numbers can be converted to strings:
          <br /><br />
          &emsp; <b>String(3);</b> // would result with the return of '3'.
          <br /><br />
          &emsp; <b>3 + '3';</b> // would result with the return of '3'.
          <br /><br />
          You can even use the method toString() to convert numbers to strings:
          <br /><br />
          &emsp; <b>10..toString();</b> // would return '10'. The empty() writes
          the number 10 in binary base two. <br /><br />
          &emsp; <b>10..toString(2);</b> // would return '1010' because (2)
          writes the number in binary base 10. <br /><br />
          &emsp; <b>28101.toString(36);</b> // would return 'lol' because after
          base 10 letters are used to represent the digits.
        </p>
      </div>
      <div>
        <h2>Parsing Numbers</h2>
        <p>
          Converts from binary , back to decimal:
          <br /><br />
          &emsp; <b>parseInt('1010',2);</b> // returns 10 <br /><br />
          &emsp; <b>parseInt('omg',36);</b> // returns 31912 <br /><br />
          &emsp; <b>parseInt('23',10);</b> // returns 23 <br /><br />
          &emsp; <b>parseInt('211B Baker Street',10);</b> // returns 221 because
          the string started with a number and the letters after will be
          ignored. <br /><br />
          &emsp; <b>parseInt('2.4',10);</b> // returns 2 because everything
          after the decimal will be removed. <br /><br />
          &emsp; <b>parseFloat('2.9',10);</b> // returns 2.9
        </p>
      </div>
      <div>
        <h2>Template Literals</h2>
        <p>
          Template literals use the backtick character,` , to deliminate the
          string. It can be used when you need to show the single quote or
          double quote in a sentence:
          <br /><br />
          &emsp; `She said, "It's Me!"`
          <br /><br />
          It can also be used in code:
          <br /><br />
          &emsp; <b>const name = `Siri`;</b>
          <br />
          &emsp; <b>`Hello ${ name }!`;</b> // Which would return `Hello Siri!`
          <br /><br /><br />
          &emsp; <b>const age = 38;</b>
          <br />
          &emsp; <b>`I will be ${ age + 1 } next year`;</b> // Which would
          return `I will be 40 next year` <br /><br />
          Template literals can also contain line breaks:
          <br /><br />
          `This is the first line ...
          <br /><br /><br />
          ... and this is the last line`
          <br /><br />
          The result would look like this:
          <br /><br />
          `This is the first line ... \n\n\n... and this is the last line`
          <br /><br />
          Just a little note: This, \`, is also a backtick.
        </p>
      </div>
      <hr />
      <!-- Notes from Chapter 3 -->
      <div>
        <h1>Notes from JavaScript: Novice to Ninja - Chapter 3:</h1>
        <h2>Arrays, Logic, & Loops</h2>
        <p>
          An array is an ordered list of values. An array can be created:
          <br /><br />
          &emsp; <b>const heros = [];</b> // This is an empty array <br /><br />
          &emsp; <b>const heros = new Array();</b> // This is an array
          constructor function <br /><br />
          &emsp; <b>heros(0);</b> // Returns undefined if there 0 in the array
          has no value <br /><br />
          You can add values to an array or change a value or values by using
          the following:
          <br /><br />
          <b
            >&emsp; heros[0] = 'Superman';
            <br />
            &emsp; heros[1] = 'Wonder Woman';
            <br />
            &emsp; heros[2] = 'Flash';</b
          >
          <br /><br />
          If you added <b>heros[5] = 'Aquaman';</b> and skipped heros[3] &
          heros[4], they would be undefined within the array until they are
          defined. <br /><br />
          You can also create array literals:
          <br /><br />
          &emsp;
          <b
            >const avengers = ['Captain America', 'Iron Man', 'Thor',
            'Hulk'];</b
          >
          <br /><br />
          You can also create arrays with different data types:
          <br /><br />
          &emsp; <b>const mixedArray = [null, 1, [], 'two', true];</b>
          <br /><br />
          You can delete a value from the array:
          <br /><br />
          &emsp; <b>const mixedArray = [null, 1, [], 'two', true];</b> // This
          would delete 'Hulk' from the array and avengers[3] would not be
          undefined. <br /><br />
          If you typed avengers you would get:
          <br /><br />
          &emsp; <b>['Captain America', 'Iron Man', 'Thor', undefined]</b>
          <br /><br />
          If you wanted to show one of the avengers names you would type:
          <br /><br />
          &emsp; <b>avengers[2];</b> // This would return 'Thor' <br /><br />
          You can swap the values of two variables:
          <br /><br />
          <b
            >&emsp; const temp = x;
            <br />
            &emsp; x = y;
            <br />
            &emsp; y = temp;</b
          >
          <br /><br />
          Here are some of the things you can do with arrays. We will use the
          following code to work with:
          <br /><br />
          &emsp;
          <b
            >const avengers = ['Captain America', 'Iron Man', 'Thor', 'Hulk',
            'Hawkeye', 'Black Widow'];</b
          >
          <br /><br />
          You can see what then length of the array is:
          <br /><br />
          &emsp; <b>avengers.length;</b> // This returns 6 and if you subtrack 1
          from the length, it would give you the amount of values in the array.
          <br /><br />
          You can use the length to find out the last value in the array:
          <br /><br />
          &emsp; <b>avengers[avengers.length - 1];</b> // returns 
          <br>
          &emsp;'Black Widow' <br /><br />
          You can change the length of the array by setting the length of it:
          <br /><br />
          &emsp; <b>avengers.length = 8;</b> // returns
          <br>
          &emsp; ['Captain
          America', 'Iron Man', 'Thor', 'Hulk', 'Hawkeye', 'Black Widow',
          undefined, undefined] <br /><br />
          You can shorted the array but any elements beyond that length will be
          removed.
          <br /><br />
          &emsp; <b>avengers.length = 3;</b> // returns 
          <br>
          &emsp; ['Captain
          America', 'Iron Man', 'Thor'] <br /><br />
          You can remove the last item in an array, if the following code was
          used:
          <br /><br />
          &emsp; <b>avengers.pop();</b> // the array would return 
          <br>
          &emsp; ['Captain America', 'Iron Man'] <br /><br />
          If you wanted to remove the first item in the list (using the array
          just mentioned):
          <br /><br />
          &emsp; <b>avengers.shift();</b> // the array would return 
          <br>
          &emsp; ['Iron Man', 'Thor'] <br /><br />
          If you wanted to add an item to the end of the list (using the array
          just used):
          <br /><br />
          &emsp; <b>avengers.push('Hulk');</b> // returns 
          <br>
          &emsp; ['Captain America', 'Iron Man', 'Thor', 'Hulk'] <br /><br />
          If you wanted to add a new item to the beginning of an array (using
          the above array):
          <br /><br />
          &emsp; <b>avengers.unshift('Black Widow');</b> // the array would return
          <br>
          &emsp; ['Black Widow, 'Captain America', 'Iron Man', 'Thor']
          <br /><br />
          It is possible to merge one or more arrays. It does not change the
          array, it just creates a new one:
          <br /><br />
          &emsp; <b>avengers.concat(['Hulk','Hawkeye', 'Black Widow']);</b> //
          would return
          <br />
          &emsp; ['Captain America', 'Iron Man', 'Thor', 'Hulk', 'Hawkeye',
          'Black Widow']
          <br /><br />
          If you wanted to update the Avengers array you would use the
          following:
          <br /><br />
          &emsp;
          <b>avengers = avengers.concat(['Hulk','Hawkeye', 'Black Widow']);</b>
          // would return <br />
          &emsp; ['Captain America', 'Iron Man', 'Thor', 'Hulk', 'Hawkeye',
          'Black Widow']
          <br /><br />
          <b
            >avengers = [ ...avengers, ...['Hulk','Hawkeye', 'Black Widow']
            ];</b
          >
          // would return <br />
          &emsp; ['Captain America', 'Iron Man', 'Thor', 'Hulk', 'Hawkeye',
          'Black Widow']
          <br /><br />
          <u>The Join() Method:</u> It seems like I have going over the join()
          method before but it is not clear in my head. From what I am getting
          from the book is that the join() method displays an array by
          seperating each item with a comma. <br /><br />
          &emsp; <b>avengers.join();</b> // would return <br />
          &emsp; 'Captain America, Iron Man, Thor, Hulk, Hawkeye, Black Widow'
          <br /><br />
          You can also choose a seperator other than a comma by placing it
          inside the paraentheses:
          <br /><br />
          &emsp; <b>avengers.join(' & ');</b> // would return <br />
          &emsp; 'Captain America & Iron Man & Thor & Hulk & Hawkeye & Black
          Widow'
          <br /><br />
          <u>Slicing:</u> This does not change the but it seems as if you have
          certain values to be displayed. <br /><br />
          &emsp; <b>avengers.slice(2,4);</b> // The return will be 3rd item up
          to but not include the 5th item.
          <br />
          &emsp; ['Captain America', 'Iron Man', 'Thor', 'Hulk', 'Hawkeye',
          'Black Widow']
          <br /><br />
          <u>Splicing:</u> This method removes items from the array and inserts
          new items.
          <br />
          &emsp; <b>avengers.splice(3, 1, 'Scarlet Witch');</b> // This replaces
          the 4th item 'Hulk' with 'Scarlet Witch'
          <br />
          &emsp; ['Captain America', 'Iron Man', 'Thor', 'Scarlet Witch',
          'Hawkeye', 'Black Widow']
          <br /><br />
          You can remove an item using splice:
          <br /><br />
          &emsp; <b>avengers.splice(2,1);</b> // will remove the item at index 2
          (3rd item - 'Thor')
          <br />
          &emsp; ['Captain America', 'Iron Man', 'Scarlet Witch', 'Quicksilver',
          'Hawkeye', 'Black Widow'] <br /><br />
          You can reverce the order of the array:
          <br />
          &emsp; <b>avengers.reverse();</b> // would return <br /><br />
          &emsp; ['Black Widow', 'Hawkeye', 'Quicksilver', 'Scarlet Witch',
          'Iron Man', 'Captain America'] <br /><br />
          You can also sort arrays:
          <br /><br />
          &emsp; <b>avengers.sort();</b> // would return
          <br />
          &emsp; ['Black Widow', 'Captain America', 'Hawkeye', 'Iron Man',
          'Quicksilver', 'Scarlet Witch']
          <br /><br />
          &emsp; <b>[5, 9, 10].sort();</b> // returns [10, 5, 9]. It goes by the
          first digit <br /><br />
          Using indexof method to check if the array contains a particular value:
          <br /><br />
          &emsp; <b>avengers.indexof('Iron Man');</b> // returns 3 <br /><br />
          &emsp; <b>avengers.indexof('Thor');</b> // returns -1 because Thor is
          no longer in the array <br /><br />
          You can also verify if a value is within an array:
          <br /><br />
          &emsp; <b>avengers.includes('Iron Man'</b> // returns true
          <br /><br />
          &emsp; <b>avengers.includes('Thor'</b> // returns false <br /><br />
          You can also look for an item searching from an element within the
          array
          <br /><br />
          &emsp; <b>avengers.includes('Black Widow', 1);</b> // returns false
          because it will start the search from the second elemet in the array
          <br /><br />
          You can have an array of arrays. This is known as a multidimensional
          array:
          <br /><br />
          &emsp; <b>const coordinates = [[1,3],[4,2]];</b> <br /><br />
          &emsp; <b>coordinates[0][0];</b> // The first value (1) of the first
          array <br /><br />
          &emsp; <b>coordinates[1][0];</b> // The first value (4) of the second
          array <br /><br />
          &emsp; <b>coordinates[0][1];</b> // The second value (3) of the first
          array <br /><br />
          &emsp; <b>coordinates[1][1];</b> // The second value (2) of the second
          array <br /><br />
          Nested array and flattened array:
          <br /><br />
          &emsp; <b>const summer = ['Jun', 'Jul', 'Aug'];</b>
          <br />
          &emsp; <b>const winter = ['Dec', 'Jan', 'Feb'];</b>
          <br />
          &emsp; <b>const nested = [ summer, winter ];</b> <br /><br />
          &emsp; Returns: [ [ 'Jun', 'Jul', 'Aug' ], [ 'Dec', 'Jan', 'Feb' ] ]
          <br /><br />
          &emsp; <b>const flat = [...summer, ...winter];</b> // returns
          <br />
          &emsp; Returns: [ 'Jun', 'Jul', 'Aug', 'Dec', 'Jan', 'Feb' ]
          <br /><br />
          <u>Sets:</u> Set is a data structure that represents a collection of
          unique values. This will not allow duplicate values. It is also useful
          to keep track of data without having to worry about duplicate values.
          <br /><br />
          &emsp; <b>const list = new Set();</b>
          <br />
          &emsp; <b>list.add(1);</b> // returns Set { 1 }
          <br />
          &emsp; <b>list.add(2).add(3).add(4);</b> // returns Set { 1, 2, 3, 4 }
          <br /><br />
          &emsp; <b>const numbers = new Set([1,2,3]);</b> //returns Set { 1, 2,
          3 } if you use <b>console.log(number)</b> <br /><br />
          If you try to add the same value to a Set in one line of code it will
          not add duplicate values. You can also make the values letters or
          words:
          <br /><br />
          &emsp; <b>const moreNumbers = new Set([7,7,7,7,7,8,8,8,9,9]);</b>
          <br /><br />
          &emsp; Returns: Set {7,8,9} when moreNumbers is displayed
          <br /><br />
          &emsp; <b>const letters = new Set('hello');</b> // returns Set { 'h',
          'e', 'l', 'o' } <br /><br />
          &emsp;
          <b
            >const words = new
            Set().add('the').add('quick').add('brown').add('fox');</b
          >
          <br /><br />
          &emsp; Returns: Set { 'the', 'quick', 'brown', 'fox' }
          <br /><br />
          If you add two arrays to a Set, each array is different.
          <br /><br />
          &emsp; <b>const arrays = new Set().add([1]).add([1]);</b> // would
          return Set { [ 1 ], [ 1 ] } <br /><br />
          You could validate this by the following:
          <br /><br />
          &emsp; <b>[1] === [1];</b> // would return false <br /><br />
          Type coercion is not used when values are added to a set, so the
          string "2" will be added as a new entry, even if the number 2 is
          already an element of the set:
          <br /><br />
          &emsp; <b>const mixedTypes = new Set().add(2).add('2');</b> // would
          return Set { 2, '2' } <br /><br />
          The number of values in a set can be found using the size() method:
          <br /><br />
          &emsp;
          <b
            >const jla = Set().add('Superman').add('Batman').add('Wonder
            Woman');</b
          >
          <br /><br />
          To see the Set type jla and it hit enter which would return:
          <br /><br />
          &emsp; Set { 'Superman', 'Batman', 'Wonder Woman' }
          <br /><br />
          To check the size:
          <br /><br />
          &emsp; <b>jla.size();</b> // would return 3 You can also check to see
          if a value is in a set. The has() method that sets use is a very
          efficient operation and much faster than using the includes() or
          indexOf() methods to check if a value is in an array. <br /><br />
          &emsp; <b>jla.has('Superman');</b> // would return true <br /><br />
          &emsp; <b>jla.has('Green Lantern');</b> // would return false
          <br /><br />
          You can remove values from Sets as well:
          <br /><br />
          &emsp; <b>jla.delete('Superman');</b> // would return true
          <br /><br />
          &emsp; <b>jla.delete('Flash');</b> // would return false because it is
          not in the Set <br /><br />
          &emsp; <b>jla.clear();</b> // would clear the Set of all remaining
          values <br /><br />
          You can convert Sets to an array. First create a Set, then convert it
          to an array: &emsp;
          <b
            >const shoppingSet = new
            Set().add('Apples').add('Bananas').add('Beans');</b
          >
          <br />
          &emsp; <b>const shoppingArray = [...shoppingSet]</b> <br /><br />
          Or this way:
          <br /><br />
          &emsp; <b>const shoppingArray = Array.from(shoppingSet);</b>
          <br /><br />
          You can also pass an array to a new Set():
          <br /><br />
          &emsp; Array:
          <b>const duplicate = [3, 1, 4, 1, 5, 9, 2, 6 ,5,3,5,9];</b> // This
          woud return: <br /><br />
          &emsp; [ 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 9 ]
          <br /><br />
          &emsp; <b>const nonDuplicate = [...new Set(repeatedArray)];</b> //
          This woud return: <br /><br />
          &emsp; [ 3, 1, 4, 5, 9, 2, 6 ] because there are no duplicates in a
          Set.
          <br /><br />
          <u>Creating Maps:</u> An empty map object can be created using the new
          operator and Map() constructor: <br /><br />
          &emsp; <b>const romanNumerals = new Map();</b>
          You can use the set method with maps.
          <br /><br />
          &emsp; <b>romanNumerals.set(1,'I');</b> // returns map { 1 => 'I' }
          <br /><br />
          You can add multiple items to Maps:
          <br /><br />
          &emsp;
          <b>romanNumerals.set(2,'II').set(3,'III').set(4,'IV').set(5,'V');</b>
          // which returns &emsp; Map { 1 => 'I', 2 => 'II', 3 => 'III', 4 =>
          'IV', 5 => 'V' }
          <br /><br />
          You can look up a value in a Map by using the get() method:
          <br /><br />
          &emsp; <b>romanNumerals.get(4);</b> // would return 'VI' <br /><br />
          You can also use the has() method the same way you would use it for
          Set().
          <br /><br />
          &emsp; <b>romanNumerals.has(5);</b> // would return true <br /><br />
          &emsp; <b>romanNumerals.has(10);</b> // would return false
          <br /><br />
          You can also create a map with multiple values by using a nested
          array:
          <br /><br />
          &emsp;
          <b
            >const heroes = new Map([ ['Clark Kent','Superman'], ['Bruce Wayne',
            'Batman'] ]);</b
          >
          // <b>heros.size</b> would return 2 <br /><br />
          You can also remove items from a map by using the delete() method:
          <br /><br />
          &emsp; <b>heroes.delete('Clark Kent');</b> // which the size would not
          be 1 <br /><br />
          You can also clear a map using the clear() method:
          <br /><br />
          &emsp; <b>heros.clear();</b> // which the size would not be 0
          <br /><br />
          It is possible to convert a Map to an array by using the spread
          operator:
          <br /><br />
          &emsp; <b>[...romanNumerals]</b> // which would return [ [ 1, 'I' ], [
          2, 'II' ], [ 3, 'III' ], [ 4, 'IV' ], [ 5, 'V' ] ] <br /><br />
          Or by using the Array.from() method:
          <br /><br />
          &emsp; <b>Array.from(romanNumerals)</b> // which would return the same
          as the above method. <br /><br />
          If statements are really nice to use. I have used them in BASIC
          language many years ago. Because of this I will not put an example of
          he IF statement, ELSE statement, or ELSE IF. But I will show examples
          just because:
          <br /><br />
          &emsp;
          <b
          >if (condition) {</b
            >
          <br />
          &emsp;&emsp; // code to run if condition is true</b
          >
          <br />
          &emsp; <b>}</b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          &emsp; <b>if (condition) {</b>
          <br />
          &emsp;&emsp; // code to run if condition is true
          <br />
          &emsp; <b>} else {</b>
          <br />
          &emsp;&emsp; // code to run if condition is false
          <br />
          &emsp; <b>}</b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <b>
          &emsp; if (number === 4) {
          <br />
          &emsp;&emsp; console.log('You rolled a four');
          <br />
          &emsp; } else if (number === 5) {
          <br />
          &emsp;&emsp; console.log('You rolled a five');
          <br />
          &emsp; } else if(number === 6){
          <br />
          &emsp;&emsp; console.log('You rolled a six');
          <br />
          &emsp; } else {
          <br />
          &emsp;&emsp; console.log('You rolled a number less than four');
          <br />
          &emsp; }
          <br /><br />
          Switches are pretty cool but I still like the IF Statement. The book says it is easier to follow when there are lots of conditions to test. It does make sense and it would be less code in my opinion.
          <br><br>
          <b>switch (number) {
          <br />
          &emsp;  case 4:
          <br />
          &emsp;&emsp;  console.log('You rolled a four');
          <br />
          &emsp;&emsp;  break;
          <br />
          &emsp;  case 5:
          <br />
          &emsp;&emsp;  console.log('You rolled a five');
          <br />
          &emsp;&emsp;  break;
          <br />
          &emsp;  case 6:
          <br />
          &emsp;&emsp;  console.log('You rolled a six');
          <br />
          &emsp;&emsp;  break;
          <br />
          &emsp;  default:
          <br />
          &emsp;&emsp; console.log('You rolled a number less than four');
          <br />
          &emsp;&emsp; break;
          }</b>
          Now we get into some of the fun stuff. I personally like the FOR Loop more than the others, but I understand some of the others are better for certain situations.
          <br><br>
          <u> While Loops:</u>
          <br><br>
          &emsp; <b>while (condition) {</b>
          <br>
          &emsp;&emsp; // do something
          <br>
          &emsp; <b>}</b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <b>
            &emsp; let bottles = 10;
            <br><br>
            &emsp; while (bottles > 0){
              <br>
            &emsp;&emsp; console.log(`There were ${bottles} green bottles, hanging on
            <br>
            &emsp;&emsp; a wall. And if one green bottle should accidentally fall,
            <br>
            &emsp;&emsp; there'd be ${bottles-1} green bottles hanging on the wall`);
            <br><br>
            &emsp;&emsp; bottles--;
            <br>
            &emsp; }
          </b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          A better way of writing this code would be as follows. Zero is always FALSE.
          <br><br>
          <b>let bottles = 11;<br><br>
            &emsp; while (--bottles){<br>
            &emsp;&emsp; console.log(`There were ${bottles} green bottles, hanging on<br>
            &emsp;&emsp; a wall. And if one green bottle should accidentally fall,<br>
            &emsp;&emsp; there'd be ${bottles-1} green bottles hanging on the wall`);<br>
            &emsp; }
          </b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <u>Infinite Loops:</u>
          <br><br>
          <b>let n = 1<br>
            &emsp; while(n>0) {<br>
            &emsp;&emsp; console.log('Hello');<br><br>
            &emsp;&emsp; n++;<br>
            &emsp; }
          </b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <u>do ... while Loops</u>
          <br><br>
          &emsp; <b>do {<br>
          &emsp;&emsp; do something<br>
          &emsp; } while(condition)</b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <b>&emsp; let bottles = 10;<br><br>
          &emsp; do {<br>
          &emsp; &emsp; console.log(`There were ${bottles} green bottles, hanging on<br>
          &emsp; &emsp; a wall. And if one green bottle should accidentally fall,<br>
          &emsp; &emsp; there'd be ${bottles-1} green bottles hanging on the wall`);<br><br>
          &emsp; &emsp; bottles--;<br>
          &emsp; } while (bottles > 0)</b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <u>for Loops:</u>
          <br><br>
          &emsp; <b>for (initialization ; condition ; after) { do something }</b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          &emsp; <b>for (let bottles = 10 ; bottles > 0 ; bottles--) {<br>
          &emsp;&emsp; console.log(`There were ${bottles} green bottles, hanging on<br>
          &emsp;&emsp; a wall. And if one green bottle should accidentally fall,<br>
          &emsp;&emsp; there'd be ${bottles-1} green bottles hanging on the wall`);<br>
          &emsp; }</b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          This for Loop could be done with out each part.
          <br><br>
          &emsp; <b>let bottles = 10;</b> // bottles is initialized here instead
          <br><br>
          &emsp;<b>for ( ; bottles > 0 ; ) {</b> // empty initialization and increment
          <br>
          &emsp;&emsp; <b>console.log(`There were ${bottles} green bottles, hanging on
          <br>
          &emsp;&emsp; a wall. And if one green bottle should accidentally fall,
          <br>
          &emsp;&emsp; there'd be ${bottles-1} green bottles hanging on the wall`);</b>
          <br><br>
          &emsp;&emsp; <b>bottles--;</b> // increment moved into code block
          <br>
          &emsp; <b>}</b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <u>Nested for Loops</u>
          <br><br>
          <b>
            &emsp; for(let i=1 ; i&lt;13 ; i++){
            <br>
            &emsp;&emsp; for(let j=1 ; j&lt;13 ; j++){
            <br>
            &emsp;&emsp;&emsp; console.log(`${j} multiplied by ${i} is ${i*j}`);
            <br>
            &emsp; }
          </b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <u>Loops over Arrays:</u>
          <br><br>
          &emsp; <b>for(let i=0, max=avengers.length; i &lt; max; i++) { console.log(avengers[i] ); }</b>
          <br><br>
          &emsp; Returns:<br>
          &emsp;&emsp; 'Black Widow'<br>
          &emsp;&emsp; 'Captain America'<br>
          &emsp;&emsp; 'Hawkeye'<br>
          &emsp;&emsp; 'Iron Man'<br>
          &emsp;&emsp; 'Quicksilver'<br>
          &emsp;&emsp; 'Scarlet Witch'
          <br><br>
          ---------------------------------------------------------
          <br><br>
          ES6 improved the iterator function for arrays called a for-of loop.
          <br><br>
          <b>
            &emsp; for(const [key,value] of RomanNumerals.entries()) {<br>
            &emsp;&emsp; console.log(`${key} in Roman numerals is ${value}`);<br>
            &emsp; }
          </b>
          <br><br>
          &emsp; Returns:<br>
          &emsp;&emsp; 'Black Widow'<br>
          &emsp;&emsp; 'Captain America'<br>
          &emsp;&emsp; 'Hawkeye'<br>
          &emsp;&emsp; 'Iron Man'<br>
          &emsp;&emsp; 'Quicksilver'<br>
          &emsp;&emsp; 'Scarlet Witch'
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <u>Looping Over Sets:</u>
          <br><br>
          The loop will iterate over each value in the same order they were added to the set.
          <br><br>
          &emsp; <b>const letters = new Set('hello');</b>
          <br><br>
          <b>
            &emsp; for(const letter of letters) {<br>
            &emsp;&emsp; console.log(letter);<br>
            &emsp;}</b>
            <br><br>
            &emsp; Returns:<br>
            &emsp;&emsp; h<br>
            &emsp;&emsp; e<br>
            &emsp;&emsp; l<br>
            &emsp;&emsp; o
          <br><br>
          <u>Looping Over Maps</u>
          <br><br>
          The loop will iterate over each key-value pair in the same order as they were added to the map.
          <br><br>
          <b>
            &emsp;const romanNumerals = new Map();<br>
            &emsp;&emsp; romanNumerals.set(1,'I').set(2,'II').set(3,'III').set(4,'IV').set(5,'V');
          </b>
          <br><br>
          &emsp; As demonstrated earlier the return would be:
          <br><br>
          &emsp; Map { 1 => 'I', 2 => 'II', 3 => 'III', 4 => 'IV', 5 => 'V' }
          <br><br>
          &emsp; Every map object has a keys() method lets us iterate over each key with the
          following for-of loop:
          <br><br>
          <b>
            &emsp; for(const key of romanNumerals.keys()) {<br>
              &emsp;&emsp; console.log(key);
          </b>
          }
          <br><br>
          &emsp; Returns:<br>
          &emsp;&emsp; 1<br>
          &emsp;&emsp; 2<br>
          &emsp;&emsp; 3<br>
          &emsp;&emsp; 4<br>
          &emsp;&emsp; 5
          <br><br>
          &emsp; There is also a values() method that lets us iterate over the values in a similar
          126 JavaScript: Novice to Ninja, 2nd Edition
          way:
          <br><br>
          <b>
            &emsp; for(const value of romanNumerals.values()) {<br>
            &emsp;&emsp; console.log(values);
          </b>
          }
          <br><br>
          &emsp; Returns:<br>
          &emsp;&emsp; I<br>
          &emsp;&emsp; II<br>
          &emsp;&emsp; III<br>
          &emsp;&emsp; IV<br>
          &emsp;&emsp; V
          <br><br>
          If you wanted to access both the key and value, you canuse the enteries() method:
          <br><br>
          <b>
          &emsp; for(const [key,value] of RomanNumerals.entries()) { <br>
            &emsp;&emsp; console.log(`${key} in Roman numerals is ${value}`); <br>
            &emsp; }</b>
          <br><br>
          &emsp; Returns:<br>
          &emsp;&emsp; 1 in Roman numerals is I<br>
          &emsp;&emsp; 2 in Roman numerals is II<br>
          &emsp;&emsp; 3 in Roman numerals is III<br>
          &emsp;&emsp; 4 in Roman numerals is IV<br>
          &emsp;&emsp; 5 in Roman numerals is V<br>
        </p>
        <hr>
        <!-- Notes from Chapter 4 -->
      <div>
        <h1>Notes from JavaScript: Novice to Ninja - Chapter 4:</h1>
        <h2>Functions:</h2>
        <p>
          There are different types of functions we will be going over in this chapter. These functions are function declarations, function expressions, Function() constructors, and the new arrow synax. Below I will show some examples of each from the book.
          <br><br>
          <u>Function Declarations:</u>
          <br><br>
          In the function declaration, the name of the function is hello followed by paraentheses. Inside the paraentheses is where arguments can go which are variables that are being passed into the function. This is then followed by a block which contains the code for that funciton. This is also know as a named function. Notice that the functino expressions ends with a semicolon at the end of the block of code. One if the main reasons functions are used is to make it so you do not have to repeat the same code over and over throughout your program/code. If you want to fix or change part of that code, you just need to go to that function. This is known as the DRY principle, which stands for Don't Repeat Yourself. Here is a Function Declaration example:
          <br><br>
          <b>
            &emsp; function hello() {<br>
            &emsp;&emsp; console.log('Hello World!');<br>
            &emsp;}
          </b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <u>Function Expressions:</u>
          <br><br>
          Function expressions is another way of defining a function literal. Here an anonymous function is assigned to the vaiable boodbye:
          <br><br>
          <b>
            &emsp; const goodbye = function() {<br>
            &emsp;&emsp; console.log('Goodbye World!');<br>
            &emsp;};
          </b>
          <br><br>
          We can even create a named function expression indead if we wanted. The function name is goodbye and it is being assigned to the variable goodbye.
          <br><br>
          <b>
            &emsp; const goodbye = function bye() {<br>
            &emsp;&emsp; console.log('Goodbye World!');<br>
            &emsp; };
          </b>
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <u>Function() Constructors:</u>
          <br><br>
          With this function, the body is entered as a string. These type of functions are not recommended to decalre functions. It can cause numerous problems with placing the function body inside a string. The reason why is because this type of function is also created in the global scope. One should always decalare a function using function literals, function declarations, or function expressions. Here is an example of a function() constructor:
          <br><br>
          &emsp; <b>const hi = new Function('console.log("Hi World!");');</b>
          <br><br>
          To run the code within a function is called invoking a function. The way this is done is by entering the name of the function or the variable. There is no examples of a function that is attached to a variable but if you were to invoke/call a function without the paraentheses, this is what would be returned:
          <br><br>
          &emsp; <b>goodbye;</b><br>
          &emsp; [Function: goodbye]
          <br><br>
          <u>Return values:</u>
          <br><br>
          A function can be invoked and have something returned which allows you to use that in another part of the code. If nothing is returned then everything that happens inside the block of code in a function, stays in the function. Here is an example of using a function to return a value of somekine:
          <br><br>
          &emsp; <b>function howdy(){<br>
          &emsp;&emsp; return 'Howdy World!';<br>
          &emsp; } </b>
          <br><br>
          You can even assign a varuable to a function that will do the same and can be easily used throughout the code if desired. Here is an example:
          <br><br>
          const message = howdy(); // If used in a string, it would return 'Howdy World!'
          <br><br>
          Parameters and arguments are often used interchangeably to represent values that are sent to a function to be used by it and maybe even returned to where the function was invoked/called from. Here is an example:
          <br><br>
          <u>Parameters:</u>
          <br><br>
          &emsp; <b>function square(x) {
          &emsp;&emsp; return x * x;
          &emsp; }</b>
          <br><br>
          This is how the parameter would be sent to the function and what the result would be:
          <br><br>
          &emsp; <b>square(4, 5);</b> // would ruturn 20.25
          <br><br>
          You can also use many parameters:
          <br><br>
          &emsp; <b>function mean(a, b, c) {<br>
          &emsp;&emsp; return (a + b + c) / 3;<br>
          &emsp; }</b>
          <br><br>
          This is what it would look like being called and what would be returned.
          <br><br>
          &emsp; <b>mean(1, 3, 6);</b><br>
          &emsp; 3.3333333333333335
          <br><br>
          If you try to use less parameters than the function requires you will get a return of NaN.
          <br><br>
          &emsp; <b>mean(1, 2);</b><br>
          &emsp; NaN
          <br><br>          
          If you try to send more than the function requires, it will only go up to the amount of parameters it needs. The rest will be ignored.
          <br><br>
          &emsp; <b>mean(1, 2, 3, 4, 5):</b> // will only find the mean of 1, 2, and 3.<br>
          &emsp; 2
          <br><br>
          <u>Arguments:</u>
          <br><br>
          &emsp; <b>arguments('hello', NaN);</b>
          &emsp; { '0': 'hello', '1': NaN }
          <br><br>
          Or another example would be:
          <br><br>
          &emsp; <b>arguments(1,2,3,4,5);</b>
          &emsp; { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5 }
          <br><br>
          Note: From <a href="https://developer.mozilla.org/en-US/docs/Glossary/Parameter">MDN Web Docs</a>, I looked up the differences between parameters and arguments, this is what I found:
          <ul>
            <li>Function parameters are the names listed in the function's definition.</li>
            <li>Function arguments are the real values passed to the function.</li>
            <li>Parameters are initialized to the values of the arguments supplied.</li>
          </ul>
          </p>
          <p>
          <u>Rest Operator:</u>
          <br><br>
          In the book, it talks about the arguments not being an array. It has a length property that can be read from and each element written using index notation. The ES6 has introduced a better solution called the rest operator. The following function will have access to an array of all arguments entered:
          <br><br>
          <b>
            &emsp; function rest(...args){<br>
            &emsp;&emsp; return args;<br>
            &emsp; }
          </b>
          <br><br>
          You can use the for-of loop in the rest operator:
          <br><br>
          <b>
            &emsp; function rest(...args){<br>
            &emsp;&emsp; for(arg of args){<br>
            &emsp;&emsp;&emsp; console.log(arg);<br>
            &emsp;&emsp; }<br>
            &emsp; }</b>
          <br><br>
          &emsp;<b>rest(2, 4, 6, 8);</b> // which would return
          <br>
          &emsp; 2<br>
          &emsp; 3<br>
          &emsp; 6<br>
          &emsp; 8
          <br><br>
          Improved Mean Function using the rest parameter with a for-of loop. Here is an example:
          <br><br>
          <b>
            &emsp;function mean(...values) {<br>
            &emsp;&emsp; let total = 0;<br>
            &emsp;&emsp; for(const value of values) {<br>
            &emsp;&emsp;&emsp; total += value;<br>
            &emsp;&emsp; }<br>
            &emsp;&emsp; return total/values.length;<br>
            &emsp; }
          </b>
          <br><br>
          &emsp; <b>mean(2,8,13,11,4,2);</b> //This would return
          <br>
          &emsp; 6.666666666666667
          <br><br>
          <u>Default Parameters:</u>
          <br><br>
          ES6 hs introduced a way of having a default parameter for a function if one is not provided. In the book, it says it is the same as '<b>name = name || "World";</b>' Here is an example:
          <br><br>
          &emsp; <b>Function hello(name = 'world') {<br>
          &emsp;&emsp; console.log(`Hello ${name});<br>
          &emsp; }</b>
          <br><br>
          Here is how it would look if you did not provide an argument:
          <br><br>
          &emsp; <b>hello();</b> // It would return<br>
          &emsp; 'Hello World'
          <br><br>
          This is what it would look like if you provided an argument:
          <br><br>
          &emsp; <b>hello('Universe');</b> // It would return<br>
          &emsp; 'Hello Universe'
          <br><br>
          You can even have a parameter/argument and a default parameter. Here is an example:
          <br><br>
          <b>
            &emsp; function discount(price, amount=10) {<br>
            &emsp;&emsp; return price*(100-amount)/100;<br>
            &emsp; }
          </b>
          <br><br>
          For this example, here are a ways you could send parameters/arguments:
          <br><br>
          &emsp; <b>discount(20);</b> // standard discount of 10%<br>
          &emsp; 18
          <br><br>
          &emsp; <b>discount(15, 20);</b> // discount of 20%<br>
          &emsp; 12
          <br><br>
          <u>Arror Functions:</u>
          <br><br>
          Last week some of my classmates said that they like the arrow funciton more than the others.
          <br><br>
          An arrow function can be identified by the arrow symbol. It looks different than the other functions. Because this function is anonymous, you need to assign them to a variable. There are some advantages using an arrow function over the others:
          <ul>
            <li>They are much less verbose than normal function declarations.</li>
            <li>Single parameters don’t need putting into parentheses.</li>
            <li>The body of the function doesn’t need placing inside a block if it’s only one line.</li>
            <li>The return keyword isn’t required if the return statement is the only statement in the body of the function.</li>
            <li>They don’t bind their own value of this to the function (we’ll see why this is a particularly useful property when we cover objects later in the book).</li>
          </ul>
        </p>
        <p>
          Here are some examples of functions from earlier but being created with an arrow function:
          <br><br>
          <b>const square = x => x*x;</b>
          <br><br>
          <b>const add = (x,y) => x + y;</b>
          <br><br>
          <b>const hello = () => alert('Hello World!');</b>
          <br><br>
          When you create an arrow function that has more code, the benefits are lost. It is a perfect candidate for short and anonymous functions. With that said, this is what it would look like this:
          <br><br>
          <b>
            &emsp; const tax = (salary) => {<br>
            &emsp;&emsp; const taxable = salary - 8000;<br>
            &emsp;&emsp; const lowerRate = 0.25 * taxable;<br>
            &emsp;&emsp; taxable = taxable - 20000;<br>
            &emsp;&emsp; const higherRate = 0.4 * taxable;<br><br>
            &emsp;&emsp; return lowerRate + higherRate;<br>
            &emsp; }
          </b>
          <br><br>
          <u>Function Hoisting & Variable Hoisting</u>
          <br><br>
          This does not make a lot of sense to me. From what I have been taught in the past, you should always declare your variables before it gets to the function. But since I don't really understand what this section is saying, I will have to do some more research on this and maybe ask my classmates. I can also look through it more at <a href="https://www.sitepoint.com/javascript-hoisting/">sitepoint</a>'s website.
          <br><br>
          I just looked at the link I just shared. I am sorta lost because how it is discribed in the book seems different than the website. From the site it says, "... function declarations are also hoisted. However, functions that are assigned to variables are not hoisted. For example, the following code will work as expected due to function declaration hoisting."
          <br><br>
          Here is the example of one that is hoisted:
          <br><br>
          &emsp; <b>foo();
          <br><br>          
          &emsp; function foo() {<br>
          &emsp;&emsp; alert('Hello!');<br>
          &emsp; }
          </b>
          <br><br>
          This example would not work because the variable declaration for foo was hoisted before the functioncall:
          <br><br>
          &emsp; <b>foo();
          <br><br>
            &emsp; function foo() {<br>
            &emsp;&emsp; alert("hello!");<br>
            &emsp; }
          </b>
          <br><br>
          <u>Callbacks:</u>
          <br><br>
          This is a basic example of a function called sing():
          <br><br>
          <b>
            &emsp; function sing(song) {<br>
              &emsp;&emsp; console.log(`I'm singing along to ${song}`);<br>
              &emsp; }
          </b>
          <br><br>
          &emsp; <b>sing('Let It Go')</b> // would return
          <br>
          &emsp; 'I'm singing along to Let It Go'
          <br><br>
          We can make the wing() function more flexible by adding a callback parameter:
          <br><br>
          <b>
            &emsp;function sing(song,callback) {<br>
            &emsp;&emsp; console.log(`I'm singing along to ${song}.`);<br>
            &emsp;&emsp; callback();<br>
            &emsp; }
          </b>
          <br><br>
          Now we can create another function called dance() that can be used as the callback:
          <br><br>
          <b>
            &emsp; function dance() {<br>
              &emsp;&emsp; console.log("I'm moving my body to the groove.");<br>
              &emsp; } </b>
              <br><br>
              &emsp; <b>sing('Let It Go',dance);</b>  // would return<br>
              &emsp;'I'm singing along to Let It Go.'<br>
              &emsp; 'I'm moving my body to the groove.'
          <br><br>
          <u>Sorting Arrays With A Callback:</u>
          <br><br>
          Remember from earlier when we stried to sort numbers, it sorted them by the first number in each element:
          <br><br>
          &emsp;<b>[1,3,12,5,23,18,7].sort();</b> // returns <br>  
          &emsp;[1, 12, 18, 23, 3, 5, 7]
          <br><br>
          This function will be used at a callback function to sort numbers:
          <br><br>
          <b>
            &emsp; function numerically(a,b){<br>
            &emsp;&emsp; return a-b;<br>
            &emsp; }
          </b>
          <br><br>
          With the following function, and the callback function we can sort the numbers correctly:
          <br><br>
          &emsp; <b>[1,3,12,5,23,18,7].sort(numerically);</b> // returns <br>
          &emsp; [1, 3, 5, 7, 12, 18, 23]
        <br><br>
        If an array includes some very large and negative numbers, you may get an overflow error. This would be because a - b becomes smaller than the smallest number JavaScript can deal with. IF that is the case, this function can be used as a callback function:
        <br><br>
        <b>
          &emsp; function numerically (a,b) {<br>
          &emsp;&emsp; if (a &lt; b) {<br>
          &emsp;&emsp;&emsp; return -1;<br>
          &emsp;&emsp; } else if (a> b) {<br>
          &emsp;&emsp;&emsp; return 1;<br>
          &emsp;&emsp; } else {<br>
          &emsp;&emsp;&emsp; return 0;<br>
          &emsp;&emsp; }<br>
          &emsp; }
        </b>
        <br><br>
        <u>Array Iterators:</u>
        <br><br>
        Arrays have a number of methods that can utilize callbacks to make them more flexable. Arrow functions are frequently used to declare the callbacks in these examples.
        <br><br>
        <u>forEach()</u>
        <br><br>
        We say in chapter 3 that FOR Loops can be used to go through each value.
        <br><br>
        <b>const colors = ['Red', 'Green', 'Blue']</b>
        <br><br>
        <b>
          &emsp; for(let i = 0, max = colors.length ; i &lt; max ; i++ ) {<br>
          &emsp;&emsp; console.log(`Color at position ${i} is ${colors[i]}`);<br>
          &emsp; }</b>
          <br><br>
          Another way we can create a loop is by using the forEach() method:
          <br><br>
          &emsp; <b>colors.forEach( (color,index) => console.log(`Color at position ${index} is ${color}`) );</b><br><br>
          Both of these would return the following:
          <br><br>
          &emsp; 'Color at position 0 is Red'<br>
          &emsp; 'Color at position 1 is Green'<br>
          &emsp; 'Color at position 2 is Blue'
          <br><br>
          <u>map()</u>
          <br><br>
          Here are some examples of the map() method that can be used as a callback function:
          <br><br>
          &emsp; <b>[1,2,3].map( square )</b> // returns [1, 4, 9]
          <br><br>
          ---------------------------------------------------------
          <br><br>
          This example will double all the numbers in the array:
          <br><br>
          &emsp; <b>[1,2,3].map( x => 2 * x);</b> // returns [2,4,6]
          <br><br>
          ---------------------------------------------------------
          <br><br>
          This example takes each item in the array and places them in uppercase inside paragraph HTML tags:
          <br><br>
          &emsp; <b>['red','green','blue'].map( color => &lt;p&gt;${color.toUpperCase()}&lt/p&gt; );</b> // returns 
          <br>
          &emsp; ['&lt;p&gt;RED&lt/p&gt;', '&lt;p&gt;GREEN&lt/p&gt;', '&lt;p&gt;BLUE&lt/p&gt;']
          <br><br>
          ---------------------------------------------------------
          <br><br>
          This callback can take two more parameters. The second parameter refers to the indes number in the array and the third refers to the array itself. This example shows all three:
          <br><br>
          <span id="tooLong"><b>&emsp;[ 'red','green','blue'].map( (color, index, array) => `Element ${index} is ${color}. There are ${array.length} items in total.` );
          </b> // returns</span>
          <br><br>
          <span b id="tooLong">&emsp; [ 'Element 0 is red. There are 3 items in total.', 'Element 1 is green. There are 3 items in total.', 'Element 2 is blue. There are 3 items in total.' ]</span>
          <br><br>
          <u>Reduce()</u>
          <br><br>
          The reduce() method is another method that iterates over each vlaue in an array, but this time is cumulatively combines each result to return a single value. The following examples shows how to sum an array of numbers. The value of acc starts at 1 (first item in the array) and then keeps track of the accumulated total.
          <br><br>
          &emsp;<b>[1,2,3,4,5].reduce( (acc,val) => prev + val );</b> // returns 15
          <br><br>
          The reduce() method also takes a second parameter after the callback, which is the initial value of the accumulator, acc. This example start at 10, instead of 1:
          <br><br>
          &emsp;<b>[1,2,3,4,5].reduce( (acc,val) => acc + val,10);</b> // '&lt;---- second parameter of 10 here and returns 25
          <br><br>
          ---------------------------------------------------------
          <br><br>
          &emsp; <b>const sentence = 'The quick brown fox jumped over the lazy dog'</b>
          <br>
          &emsp; 'The quick brown fox jumped over the lazy dog'
          <br><br>
          When you use the split() method you get this as a return:
          <br><br>
          &emsp; ['The', 'quick', 'brown', 'fox', 'jumped', 'over', 'the', 'lazy', 'dog']
          <br><br>
          Now we can use the reduce() function to calculate the total number of letters in the sentence:
          <br><br>
          &emsp; <b>const total = words.reduce( (acc,word) => acc + word.length,0 );</b> // returns 36
          <br><br>
          And now we can figure out the average word length:
          <br><br>
          &emsp; <b>const average = total/words.length</b> // returns 4
          <br><br>
          ---------------------------------------------------------
          <br><br>
          <u>Filter()</u>
          <br><br>
          We can create a new array that only contains items from the original array that return true by using the filter() method. For example we can filter just the even numbers using the following code:
          <br><br>
          &emsp; <b>const numbers = [ 2, 7, 6, 5, 11, 23, 12 ];</b>
          <br><br>
          &emsp; <b>numbers.filter(x => x%2 === 0 );</b> // this returns true if the number is even 
          <br>
          &emsp; [ 2, 6, 12 ]
          <br><br>
          This next example provides a useful way of finding all the truthly values from an array:
          <br><br>
          &emsp; <b>const array = [ 0, 1, '0', false, true, 'hello' ];</b>
          <br>
          &emsp; <b>array.filter(Boolean);</b> // returns [ 1, '0', true, 'hello' ]
          <br><br>
          And if you wanted to find falsy values you can do so with this code:
          <br><br>
          &emsp; <b>array.filter(x => !x);</b> // [ 0, false ]
          <br><br>
          Some of the other methods I will have to look into that were mentioned in the book are:
          <ul>
            <li>reduceRight()</li>
            <li>every()</li>
            <li>find()</li>
            <li>some()</li>
          </ul>
      </p>
      <p>
        <u>Chaining Iterators Together</u>
        <br><br>
        We can combine various iterator functions together to create some powerful tranformations of data stored in arrays. I is achieved by a process called chaining methods together. It works because iterator functions returns an array. Iterator functions are chained to the end and will be applied to a new array.
        <br><br>
        In this example we will chain a map() method and the reduce() method on to the end to add the results together:
        <br><br>
        &emsp;<b>[1,2,3].map( x => x*x ).reduce((acc,x) => acc + x );</b> // returns 14
        <br><br>
        Another more complex example could be used to take an array of orders, apply a sales tax to them using map() and then use reduce() to find the total:
        <br><br>
        &emsp;<span id="tooLong"><b>const sales = [ 100, 230, 55]; totalAfterTaxSales = sales.map( (amount) => amount * 1.15 ).reduce( (acc,val) => acc + val );</b> // returns 442.75</span>
        <br><br>
        <u>Improving the mean() Function</u>
        Once again we are shown a better way to do the mean() function from chapter 2. The mean() function can be improved by using the reduce() method to add up all the values provided:
        <br><br>
        <b>
          &emsp; function mean(array) {<br>
          &emsp;&emsp; const total = array.reduce((a, b) => a + b);<br>
          &emsp;&emsp; return total/array.length;<br>
          &emsp; }
        </b>
        <br><br>
        And they even had another improment to the mean() function by adding a callback function.
        <br><br>
        <b>
          &emsp; function mean(array,callback) {<br>
            &emsp;&emsp; if (callback) {<br>
            &emsp;&emsp;&emsp; array.map( callback );<br>
            &emsp;&emsp; }<br>
            &emsp;&emsp; const total = array.reduce((a, b) => a + b);<br><br>
            &emsp;&emsp; return total/array.length;<br>
          &emsp; }
        </b>
        <br><br>
        This code is similar to our previous mean() function, except in the following if block where we check to see if a callback has been provided. If it has, then the callback is applied to each value before being added to the total; otherwise, the total is calculated using just the values from the array given as the first argument:
        <br><br>
        Here are three examples using the mean() function with the reduce() method, map() method, and callback function:
        <br><br>
        &emsp; <b>mean([2,5,7,11,4]);</b> // this should just calculate the mean <br> 
        &emsp; 58
        <br><br>
        &emsp; <b>mean([2,5,7,11,4],x => 2*x);</b><br>
        &emsp; 11.6
        <br><br>
        &emsp; <b>mean([2,5,7,11,4],square);</b>
        <br>
        &emsp; 43
      </p>
        <hr>
        <h1>Questions:</h1>
        <p>
          A question I have it about invoking a function. I understand that when you invoke a function, you need to use the name of the function and paraentheses. But how do you invoke a function that is a varable? Do you still type the variable name and paraentheses? In the book it does say, "... either by name or by reference to the variable it is assigned to." There is just not an example showing this so I can verify what I am reading.
          <br><br>
          In the Improved Mean Function, I do not understand what it means when it says, "We can use a rest parameter to improve our mean() function...". Maybe it is because of the '...values' array as the argument.
          <br><br>
          I don't 100% understand <b>Function Hoisting</b> and <b>Variable Hoisting</b>. I read some more about it from <a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting">MDN Web Docs</a> and from what I am understanding:
          <br><br>
          &emsp; <b>var a = 1;</b> // is declared
          <br>
          &emsp; <b>b = 1;</b> // is not declared but is initialized
          <br><br>
          Not sure if I am correct.
          <br><br>
          There are a lot of these I am not sure I would ever use. Depends on the amount of exposure I get working with HTML in the future.
        </p>
      </div>
    </main>

    <!-- FOOTER HERE -->
    <footer id="footerWrapper">
      <p>
        &copy;2021 | Jesse Wilson | Cardston, AB |
        <a href="https://www.byui.edu/online" target="_blank"
          >BYU-I Online Learning
        </a>
      </p>
    </footer>
  </body>
</html>
