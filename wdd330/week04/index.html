<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="description" content="infomation about site." />
    <meta name="author" content="Jesse Wilson" />

    <!-- SITE TITLE -->
    <title>Week 4 Notes & Codes</title>

    <!-- TELLS PHONES NOT TO LIE ABOUT THEIR WIDTH & stops the font from
      enlarging when a phone is turned sideways-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- STYLE SHEETS -->
    <link href="css/normalize.css" rel="stylesheet" />
    <!-- phone-default -->
    <link href="css/small.css" rel="stylesheet" />
    <!-- enhance-tablet -->
    <link href="css/medium.css" rel="stylesheet" />
    <!-- enhance-desktop -->
    <link href="css/large.css" rel="stylesheet" />

    <!-- JAVASCRIPTS-->
    <script defer src="js/styles.js"></script>
  </head>
  <body>
    <!-- HEADER HERE -->
    <header id="headerWrapper">
      <h1>Week 4 Notes & Codes</h1>
    </header>

    <!-- NAVIGATION HERE -->
    <nav></nav>

    <!-- CONTENT HERE -->
    <main>
      <div>
        <a href="activity/index.html"><h2>Team Activity</h2></a>
        <h1>Notes from JavaScript: Novice to Ninja - Chapter 8:</h1>
        <h2>Forms</h2>
        <p>
          Forms are commonly used to interact with a web page. Logging into the
          users favorite site is the most used form. Forms are made up of a
          &#60;form> element. Some of the form controls are the input fields,
          select menus, and buttons. Since most of this chapter was creating two
          different forms I thought I would just share the pages here.
          Everything seemed to work except the very last bit of code from pages
          311 - 313. I am not sure where it should be calling the
          validateInline() function.
        </p>
        <ul>
          <li><a href="search/search.html" target="_blank">Search Form</a></li>
          <li><a href="hero/hero.html" target="_blank">Hero Form</a></li>
        </ul>
      </div>
      <hr />
      <div>
        <h1>Notes from JavaScript: Novice to Ninja - Chapter 12:</h1>
        <h2>Object-Oriented Programming (OOP)</h2>
        <p>
          Object-Oriented Programming is a style of programming that involves
          the code into objects that have properties and methods. The objects
          can be reused or modified easily when needed. There are three main
          concepts in OOP:
        </p>
        <ul>
          <li>
            Encapsulation - The inner workings are kept hidden inside the object
            and only the essential functionalities are exposed to the end user.
          </li>
          <li>
            Polymorphism - The same process can be used for different objects
            which allows various objects share the same method or override
            shared methods with a more specific implementation.
          </li>
          <li>
            Inheritance - Taking the features of one object then adding some new
            features. This allows an object that already exsists and inherit all
            its properties and methods. You can then improve its functionality
            by adding new properties and methods.
          </li>
        </ul>
        <p>
          <u>Classes:</u> Some object-oriented languages like Java & Ruby are
          class-based languages and are also know as prototype-based languages.
          In the book it talked about building a prototype juicer and making all
          other juciers from that prototype. I don't know if I am 100% correct,
          but to me it would be like creating the basics of a car which would be
          the prototype of all cars. Then taking that prototype to build other
          cars but add more features like bells and whistles to make many
          different cars. Defferences like more powerful engines, build in gps,
          soft top, battery or gas engine, etc.
        </p>
        <u>Constructor Functions:</u>
        <p>
          Here is an example of an object as we learned in the objects chapter:
        </p>
        <pre>
    const dice = {
      sides: 6,
      roll() {
        return Math.floor(this.sides * Math.random() + 1)
      }
    }
        </pre>
        <p>
          Here is that the same object but rewritten as a constructor function:
        </p>
        <pre>
    const Dice = function(sides=6){
      this.sides = sides;
      this.roll = function() {
        return Math.floor(this.sides * Math.random() + 1)
      }
    }
        </pre>
        <p>
          I was curious how it knew the random number was to be between 1 & 6. I
          am not sure if I missed it in that chapter seemed to answer my
          question. The keyword <b>this</b> is used to represent the object that
          will be returned by the constructor function. In a preveous chapter
          the same dice example was shown. In the previous example, we use it to
          set the sides property to the argument that is provided to the
          constructor function, or 6, if no argument provided. It also adds a
          method called roll(), which returns a random number from 1 up to the
          number of sides the dice has. With constructor function above this is
          how you would create an instance of the dice constructor:
        </p>
        <pre>
    const redDice = new Dice();
    &#60;&#60; Dice { sides: 6, roll: [Function] }

    or

    const redDice = new Dice; // You don't need the parentheses
    &#60;&#60; Dice { sides: 6, roll: [Function] }
        </pre>
        <p>
          If you any defauly arguments need to be provided, yo will need to have
          the parentheses. This would be good if you wanted to have a six, four,
          or twelve sided dice. This would look like the following:
        </p>
        <pre>
    const whiteDice = new Dice(4); // Change 4 to 12 for twelve sided dice.
        </pre>
        <p>
          If you wanted to, you could check to see is redDice is using the the
          instance of Dice and even roll the dice:
        </p>
        <pre>
    redDice instanceof Dice
    &#60;&#60; true 

    redDice.sides 
    &#60;&#60; 6

    redDice.roll() 
    &#60;&#60; 4
        </pre>
        <p>
          With ES6 you can use the new class declaration syntax to rewrite the
          code as the constructor function. Here is how that would look:
        </p>
        <pre>
    class Dice {
      constructor(sides=6) {
        this.sides = sides;
      }
      roll() {
        return Math.floor(this.sides * Math.random() + 1)
      }
    }

    const blueDice = new Dice(20); // create a new instance of the Dice class
    &#60;&#60; Dice { sides: 20 }

    blueDice instanceof Dice // Lets you see if blueDice is a new instance of the Dice class
    &#60;&#60; true

    blueDice.sides // Displays how many sides the blueDice has
    &#60;&#60; 20

    blueDice.roll() // Displays a random number between 1 & 20 
    &#60;&#60; 13
        </pre>
        <p>I just wanted to put a few examples of creating an object:</p>
        <pre>
    const literalObject = {}; // Easiest way to create a new object is to use the literal syntax
    &#60;&#60; {}

    constructedObject = new Object(); // It is also possible to use the Object constructor function
    &#60;&#60; {}
        </pre>
        <p>
          All objects have a constructor property that returns the constructor
          function that created it:
        </p>
        <pre>
    blueDice.constructor
    &#60;&#60; [Function: Dice]
        </pre>
        <p>
          We can use the constructor property to instantiate a copy of an
          object, without having to reference the actual constructor function or
          class declaration directly.
        </p>
        <pre>
    const greenDice = new redDice.constructor(10);
    greenDice instanceOf Dice
    &#60;&#60; true
        </pre>
        <u>Static Methods:</u>
        <p>
          The static keyword can be used in class declarations to create a
          static method. These are sometimes called class methods in other
          programming languages. A static method is called by the class directly
          rather than by instances of the class. I like that you can do a
          description like this. It is not a function so you would get an error
          if you tried to use it like one because static methods are not
          available to instances of the class.
        </p>
        <pre>
    class Dice {
      constructor(sides=6) {
        this.sides = sides;
      }
      roll() {
        return Math.floor(this.sides * Math.random() + 1)
      }
      static description() {
        return 'A way of choosing random numbers'
      }
    }

    Dice.description()
    &#60;&#60; 'A way of choosing random numbers'

    redDice.description
    &#60;&#60; TypeError: red.description is not a function
        </pre>
        <p>
          I have learned that I am a literal learner and thinker. I am hoping
          that by adding these next lines of code will help me understand how
          Objects work for future reference. I can try some of these in the
          console when I inspect this page. The following code is in the JS for
          this page. Inspect the page and you can try to type the code in bold
          letters to see it work.
        </p>
        <pre>
    <a href="classTurtle1.html" target="_blank">class Turtle</a> {
      constructor(name) {
        this.name = name;
        this.weapon = 'hands';
      }
      sayHi() {
        return `Hi dude, my name is ${this.name}`;
      }
      attack(){
        return `Feel the power of my ${this.weapon}!`;
      }
    }
        </pre>
        <p>Now we will create a new turtle instance.</p>
        <pre>
    <b>const leo = new Turtle('Leonardo');</b>
    &#60;&#60; Turtle { name: 'Leonardo' }
        </pre>
        <p>
          The variable leo points to an instance of the Turtle class. It has a
          name property and a sayHi() method that references the name property.
        </p>
        <pre>
    <b>leo.name;</b>
    &#60;&#60; 'Leonardo'
    
    <b>leo.sayHi();</b>
    &#60;&#60; 'Hi dude, my name is Leonardo'
        </pre>
        <p>
          If you enter <b>leo.sayHi</b> you will get this instead of the desired
          result.
        </p>
        <pre>
    sayHi() {
      return `Hi dude, my name is ${this.name}`;
    }
        </pre>
        <p>
          We things we can see is the turtles name and weapon. We can add a
          method to the prototype:
        </p>
        <pre>
  <b>
    Turtle.prototype.attack = function(){
      return `Feel the power of my ${this.weapon}!`;
    }
  </b>
        </pre>
        <p>
          We have Leonado but lets add Raphael and display his information in
          the console.
        </p>
        <pre>
    <b>const raph = new Turtle('Raphael');</b>

    <b>raph.weapon = "ninjakens"</b>

    <b>raph.name;</b> 
    &#60;&#60; 'Raphael'

    <b>raph.sayHi();</b>
    &#60;&#60; 'Hi dude, my name is Raphael'

    <b>raph.attack();</b>
    `Feel the power of my ninjakens!`
        </pre>
        <u>Finding Out the Prototype</u>
        <p>There are a number of ways to find the prototype of an object:</p>
        <pre>
    // Each of these return the same thing 
    &#60;&#60; Turtle { attack: [Function], weapon: 'Hands' }
      
    <b>raph.constructor.prototype;</b> // Use the constructor function’s prototype property

    <b>Object.getPrototypeOf(raph);</b> // Use the Object.getPrototypeOf() method, which takes the
    object as a parameter

    // Many JavaScript engines also support the non-standard __proto__ property known as
    // double underscore proto or dunder proto. It seems it is getting replaced by the
    // isPrototypeOf() method
    <b>raph.__proto__;</b>

    // Every object also has a isPrototypeOf() method that returns a boolean to check
    if it’s the prototype of an instance
    <b>Turtle.prototype.isPrototypeOf(raph)</b>
    &#60;&#60; true
        </pre>
        <p>
          The object raph has access to both name and weapon properties, but the
          name property is considered to be its own property, while the weapon
          property is inherited from the prototype. Every object has a
          hasOwnProperty() method that can be used to check if a method is its
          own property, or is inherited from the prototype.
        </p>
        <pre>
    <b>raph.hasOwnProperty('name');</b>
    &#60;&#60; true

    <b>raph.hasOwnProperty('weapon');</b>
    &#60;&#60; false
        </pre>
        <p>
          Difference between an object’s own properties and prototype. Prototype
          properties are shared by every instance of the Turtle class. The
          objects all have the same properties. For example, every time an
          instance of the Turtle class queries the weapon property, it will
          return “Hands”.
        </p>
        <pre>
    <b>const don = new Turtle('Donatello');</b>
    &#60;&#60; Turtle { name: 'Donatello' }

    <b>don.weapon;</b>
    &#60;&#60; 'Hands'

    <b>don.attack();</b>
    &#60;&#60; 'Feel the power of my Hands!'
        </pre>
        <p>
          Now supposedly we are able to change the weapon which seems to be
          'Hands' by default because of the way it is in the Turtle Class. I
          will put code here but so far I have not been able to get it to work.
        </p>
        <pre>
    <b>Turtle.prototype.weapon = 'Feet';</b> // This part works 
    &#60;&#60; 'Feet'
        </pre>
        <p>
          And the results are suppose to look like the following but I have not
          been able to get it to work. I keep getting 'Feel the power of my
          hands!'
        </p>
        <pre>
    <b>leo.attack();</b>
    &#60;&#60; 'Feel the power of my Feet!'

    <b>raph.attack();</b>
    &#60;&#60; 'Feel the power of my Feet!'
    
    <b>don.attack();</b>
    &#60;&#60; 'Feel the power of my Feet!'
        </pre>
        <u> Overwriting Prototype Properties </u>
        <p>
          I like this part. We can change the weapon that each ninja turtle uses
          and it stays with that turtle. Right now the weapon SHOULD be feet but
          in my case so far, it is hands. But we will change them this way.
        </p>
        <pre>
    <b>leo.weapon = 'Katana Blades';</b>
    &#60;&#60; 'Katana Blades'

    <b>raph.weapon = 'Sai';</b>
    &#60;&#60; 'Sai'

    <b>don.weapon = 'Bo Staff';</b>
    &#60;&#60; 'Bo Staff'
        </pre>
        <p>Now if we want to see the results we can do this:</p>
        <pre>
    <b>leo.attack();</b>
    &#60;&#60; 'Feel the power of my Katana Blades!'

    <b>raph.attack();</b>
    &#60;&#60; 'Feel the power of my Sai!'

    <b>don.attack();</b>
    &#60;&#60; 'Feel the power of my Bo Staff!'
        </pre>
        <p>
          Prototypes should be used to define any properties that will remain
          the same for every instance of the class. All of the turtles use
          different weapons but they all like the same food, pizza!
        </p>
        <pre>
    <b>Turtle.prototype.food = 'Pizza';</b> // Adding Prototype property that is not in the original class declaration

    <b>Turtle.prototype.eat = function() { // Adding method to the prototype
      return 'Mmm, this ${this.food} tastes great!';
    }</b>
        </pre>
        <p>Now we can create another turtle instance.</p>
        <pre>
    <b>const mike = new Turtle('Michelangelo');</b>     

    <b>mike.eat();</b>
    &#60;&#60; 'Mmm, this Pizza tastes great!'

    <b>mike.weapon = 'Nunchakus';</b>
    &#60;&#60; 'Nunchuks'

    <b>mike.attack();</b>
    &#60;&#60; 'Feel the power of my Nunchakus!'
        </pre>
        <u>Public and Private Methods</u>
        <p>
          Public methods and properties can be queried directly and changed by
          assignment even after it has been created. The name and weapon
          properties are said to be public in this example because we can query
          their value and they can be changed. giving users or external services
          too much access to properties and methods could be a recipe for
          disaster!
        </p>
        <pre>
    <b>raph.weapon;</b>
    &#60;&#60; 'Sai'

    <b>raph.weapon = 3;</b>
    &#60;&#60; 3

    <b>raph.attack();</b>
    &#60;&#60; 'Feel the power of my 3!'
        </pre>
        <p>
          The concept of variable scope can be used to keep some properties and
          methods private inside a class declaration. This will prevent the user
          from accessing or changeing the methods and/or properties.
        </p>
        <pre>
    <a href="classTurtle2.html" target="_blank">class Turtle</a> {
      constructor(name,color) {
        this.name = name;
        let _color = color;
        this.setColor = color => { return _color = color; }
      this.getColor = () => _color;
      }
    }
        </pre>
        <p>
          By creating the _color property inside the scope of the constructor
          function inside the class declaration. It makes it impossible to
          access outside of this scope. The getColor() and setColor are known as
          getter and setting methods.
        </p>
        <pre>
    <b>raph = new Turtle('Raphael','Red');</b>
    &#60;&#60; Turtle { name: 'Raphael', setColor: [Function], getColor: [Function] }

    <b>raph.getColor();</b>
    &#60;&#60; 'Red'

    <b>raph.setColor(4);</b>
    &#60;&#60; 4

    // You can also insist that the color property is a string
    this.setColor = (color) => {
      if(typeof color === 'string'){
        return _color = color;
      } else {
        throw new Error('Color must be a string');
      }
    }

    <b>raph.setColor(4);</b>
    &#60;&#60; Error: Color must be a string
        </pre>
        <u>The Prototype Chain</u>
        <p>
          An example of a prototype chain by looking at the prototype of the
          raph instance of the Turtle class that we created in the last section,
          using the Object.getPrototypeOf() method:
        </p>
        <pre>
    <b>Object.getPrototypeOf(raph);</b>
    &#60;&#60; Turtle {}
        </pre>
        <p>
          We can peer further down the prototype chain, but calling the
          Object.getPrototypeOf() method recursively. This shows us that the
          prototype of the prototype is an apparently empty object literal,
          although it’s actually an instance of the built-in Object()
          constructor function
        </p>
        <pre>
    <b>Object.getPrototypeOf(Object.getPrototypeOf(raph))</b>
    &#60;&#60; {}
        </pre>
        <figure>
          <img src="images/prototypeChain.jpg" alt="Prototype Chain" />
          <figcaption>The prototype chain example</figcaption>
        </figure>
        <u>The Object Constructor</u>
        <p>
          All objects ultimately inherit from the prototypeof the Object()
          constructor function. Here is what happens when an object calls a
          method:
        </p>
        <ul>
          <li>
            JavaScript engine will check to see if the object has that method
          </li>
          <li>
            If it doesn’t, it will check if the object’s prototype has the
            method
          </li>
          <li>
            If not, it will check whether the prototype’s prototype has it
          </li>
          <li>
            It will continue all the way up the prototype chain, until it
            reaches the prototype of the Object() constructor function
          </li>
          <li>
            If the prototype of Object() is without the method, an error will be
            returned saying the object doesn’t exist
          </li>
        </ul>
        <p>
          The prototype of the Object constructor function has a large number of
          methods that are inherited by all objects. The reason why the
          prototype appears as an empty object literal is because all of its
          methods are not enumerable. Properties of objects in JavaScript are
          said to be enumerable or non-enumerable. If they aren’t enumerable,
          this means they will not show up when a for-in loop is used to loop
          through an object’s properties and methods. There is a method called
          propertyIsEnumerable() that every object has (because it's a methos of
          Object.prototype) that is used to check if a property is enumerable.
        </p>
        <pre>
    <b>Turtle.prototype.propertyIsEnumerable('eat');</b>
    &#60;&#60; true

    <b>Object.prototype.propertyIsEnumerable('toString');</b>
    &#60;&#60; false

    <b>Object.prototype.propertyIsEnumerable('propertyIsEnumerable');</b>
    &#60;&#60; false
        </pre>
        <u>Inheritance Using extends</u>
        <p>
          We can use the key <i>extends</i> keyword in a class declaration so a
          class can inherit from another class.
        </p>
        <pre>
    <a href="classTurtle3.html">class Turtle</a> {
      constructor(name) {
        this.name = name;
      }
      sayHi() {
        return `Hi dude, my name is ${this.name}`;
      }
      swim() {
        return `${this.name} paddles in the water`;
      }
    }

    class NinjaTurtle extends Turtle {
      constructor(name) {
        super(name);
        this.weapon = 'hands';
    }
      attack() { return `Feel the power of my ${this.weapon}!` }
    }
        </pre>
        <p>
          To show how this works lets do some examples. Lets create a turtle.
          Not a special turtle, just one from a cartoon. Lets say Verne from
          'Over the Hedge'. There is nothing special about him other than he is
          a turtle.
        </p>
        <pre>
    <b>verne = new Turtle('Verne');</b>
    &#60;&#60; 'Verne'
        </pre>
        <p>
          Now lets see Verne's name, how he introduces himself and see how he
          swims.
        </p>
        <pre>
    <b>verne.name;</b>
    &#60;&#60; Verne

    <b>verne.sayHi();</b>
    &#60;&#60; `Hi dude, my name is Verne`

    <b>verne.swim();</b>
    &#60;&#60; `Verne paddles in the water.'
        </pre>
        <p>Now lets see if he uses a weapon and if he can attack with it.</p>
        <pre>
    <b>verne.weapon;</b>
    &#60;&#60; undefined
    
    <b>verne.attack();</b>
    &#60;&#60; Uncaught TypeError: verne.attack is not a function at &#60;anonymous>:1:7
        </pre>
        <p>
          Why did weapon and attack() not work. It is because they are not Ninja
          Turtles. So lets create one of the Ninja Turtles and see if he has a
          weapon and can attack. Also see if he can swim and introduce himself
          without creating him in the Turtle class.
        </p>
        <pre>
    <b>don = new NinjaTurtle("Donatello");</b>
    &#60;&#60; NinjaTurtle {name: 'Donatello', weapon: 'hands'}

    <b>don.name;</b>
    &#60;&#60; 'Donatello'

    <b>don.weapon;</b>
    &#60;&#60; 'hands'

    <b>don.attack();</b>
    &#60;&#60; 'Feel the power of my hands!'

    <b>don.swim();</b>
    &#60;&#60; 'Donatello paddles in the water'

    <b>don.sayHi();</b>
    &#60;&#60; 'Hi dude, my name is Donatello'
        </pre>
        <p>
          As you can see because Donatello is a Ninja Turtle he has all the
          traits of the NinjaTurtles class and also the Turtle class. If I am
          understanding correctly, Turtle would be the parent class and
          NinjaTurtle would be a child class. So NinjaTurtle inherits what is
          inside Turtle.
        </p>
        <u> Polymorphism </u>
        <p>
          The concept of polymorphism means that different objects can have the
          same method, but implement it in different ways. Polymorphism means
          that objects are able to override this method with a more specific
          implementation. Although every object has a toString() method, the way
          it’s implemented can vary between different objects. For example,
          calling it on an array object will return each value in a
          comma-separated string:
        </p>
        <pre>
    [1,2,3].toString();
    &#60;&#60; '1,2,3'

    2..toString();
    &#60;&#60; '2'

    2 === 2.string();
    &#60;&#60; false

    '2' === 2.string();
    &#60;&#60; true 
        </pre>
        <p>
          The toString() method is used by a number of built-in functions in the
          background. It can be used without fear of causing an error because
          every object has the method, as it’s inherited from Object.prototype.
          One example of a function that uses the toString() method is the
          console.log() method. It’s often a useful exercise to override the
          toString() method using the prototype, so something more meaningful is
          displayed. This line of code has been added to the JS file already:
        </p>
        <pre>
    toString() {
      return `A turtle called ${this.name}`;
    }

    // Without the code above it could look like this
    <b>raph.toString();</b>
    '[object Object]'

    // With the code above added to the JS it could look like this
    <b>raph.toString();</b>
    &#60;&#60; 'A turtle called Raphael'
        </pre>
        <u> Adding Methods to built-in Objects</u>
        <p>
          You are able to add more methods to the prototype of JavaScript’s
          built-in objects — such as Number, String, and Array to more
          functionality. This practice is known as monkey-patching, but it’s
          mostly frowned upon in the JavaScript community, despite it being an
          incredibly powerful technique.
        </p>
        <pre>
    <b>Number.prototype.isEven = function() {
      return this%2 === 0;
    }</b>

    <b>Number.prototype.isOdd = function() {
      return this%2 === 1;
    }</b>

    <b>42..isEven();</b>
    &#60;&#60; true

    <b>765234..isOdd();</b>
    &#60;&#60; false 
        </pre>
        <p>
          Arrays are powerful objects, but seem to have some basic methods
          missing in JavaScript that are found in other languages. We can add a
          first() and last() methods that return the first and last items in the
          array:
        </p>
        <pre>
    <b>Array.prototype.first = function() {
      return this[0];
    }</b>

    <b>Array.prototype.last = function() {
        return this[this.length -1];
    }</b>

    <b>const turtles = ['Leonardo', 'Donatello', 'Michaelangelo', 'Raphael'];</b>

    <b>turtles.first();</b>
    &#60;&#60; 'Leonardo'

    <b>turtles.last();</b>
    &#60;&#60; 'Raphael'
        </pre>
        <p>
          If you want or need to remove whitespace from the beginning and end of
          a string:
        </p>
        <pre>
    <b>String.prototype.trim = String.prototype.trim || function() {
      return this.replace(/^\s+|\s+$/,'');
    }</b>
    
    <b>' hello '.trim();</b>
    &#60;&#60; 'hello'
        </pre>
        <p>
          While monkey-patching built-in objects can seem a good way to add
          extra or missing functionality, it can also add unexpected behavior.
          The current consensus in the JS community is that this shouldn’t be
          done, so you should avoid monkey-patching any of the built-in object
          constructor prototypes, unless you have a very good reason. Further
          problems could occur if the method you’ve added is then implemented
          natively in the language. An alternative way to avoid causing problems
          is to use extends to subclass a built class and create your own class.
          For example, you could create your own array class by extending the
          built in array class, like so:
        </p>
        <pre>
    <b>class myArray extends Array {
      constructor(...args){
        super(...args);
      }
      
      delete(i) {
        return this.splice(i,1);
      }
    }</b>

    <b>const list = new myArray(1,2,3);</b>
    &#60;&#60; myArray [ 1,2,3 ]

    <b>list.delete(1);</b>
    &#60;&#60; myArray [ 2 ]

    <b>list</b>
    &#60;&#60; myArray [ 1, 3 ]
        </pre>
        <u>Property Attributes and Descriptors</u>
        <p>
          Objects are a collection of key-value paired properties. each property
          has a number of attributes that provide information about the
          property. These attributes are stored in a property descriptor, which
          is an object that contains values of each attribute. All object
          properties have the following attributes stored in a property
          descriptor:
        </p>
        <ul>
          <li>
            value ― This is the value of the property and is undefined by
            default
          </li>
          <li>
            writable ― This boolean value shows whether a property can be
            changed or not, and is false by default
          </li>
          <li>
            enumerable ― this boolean value shows whether a property will show
            up when the object is displayed in a for in loop, and is false by
            default
          </li>
          <li>
            configurable ― this boolean value shows whether you can delete a
            property or change any of its attributes, and is false by default.
          </li>
        </ul>
        <p>
          Up to this point we have only set properties by assignment, which only
          allows us to set the value attributes by using a property descriptor.
          Here is an example of a single property of name:
        </p>
        <pre>
          <b>const me = { name: 'DAZ' };</b>
        </pre>
        <p>To get or set the property descriptors:</p>
        <pre>
    // To get the property descriptors. Because writable is set to true, we can change the name value to something else if we wanted 
    <b>Object.getOwnPropertyDescriptor(me,'name');</b>
    &#60;&#60; { value: 'DAZ', writable: true, enumerable: true, configurable: true }

    //To set/add properties to an object. Because writeable is set to false, we cannot change the value of eyeColor.
    <b>Object.defineProperty(me, 'eyeColor', { value: 'blue', writable: false, enumerable: true });</b>
    &#60;&#60; { name: 'DAZ', age: 21, eyeColor: 'blue' }

    <b>me.eyeColor = 'purple'</b>
    &#60;&#60; 'purple'

    <b>me.eyeColor;</b>
    &#60;&#60; 'blue'
        </pre>
        <p>
          An object property descriptor can have get() and set() methods instead
          of a value attribute. All objects must have one or the other, they
          can’t have both. The get() and set() methods can be used to control
          how a property is set using assignment and the value that is returned
          when a property is queried. They are particularly useful if a property
          relies on the value of another property. For example, if we add age
          and retirementAge properties to the me object, we can then create a
          yearsToRetirement property that depends on these properties:
        </p>
        <pre>
    <b>me.age = 21;

    me.retirementAge = 65;
    
    Object.defineProperty(me, 'yearsToRetirement',{
      get() {
        if(this.age > this.retirementAge) { return 0; }
        else { return this.retirementAge - this.age; }
      },
      set(value) {
        this.age = this.retirementAge - value;
        return value;
      }
    });</b>

    <b>me.yearsToRetirement;</b>
    &#60;&#60; 44

    // Setter also allows the age to be changed by setting the yearsToRetirement property
    <b>me.yearsToRetirement = 10;</b>
    &#60;&#60; 10

    <b>me.age</b>
    &#60;&#60; 55
        </pre>
        <p>
          We are able to have more fine-grained control over how assignment
          works with the use of gett and setter methods. To me it seems like you
          are setting a values default no matter what the value is later set to.
        </p>
        <pre>
  <b> Object.defineProperty(me, 'age', {
      get() {
        return 21;
      },
      set(value) {
        return value;
      }
    });</b>

    <b>me.age = 30;</b>
    &#60;&#60; 30

    <b>me.age;</b>
    &#60;&#60; 21
        </pre>
        <p>
          The next example shows how we can create a Dice class that uses a get
          function that will return a description of the number of sides, rather
          than just the actual number, and a set function that prohibits a
          non-positive number of sides to be set. These getter and setter
          methods give you much more power in controlling the way property
          assignment works. However, they should be used sparingly and with
          care, as changing the expected behavior of an assignment has the
          potential to cause a lot of confusion.
        </p>
        <pre>
    <b>class Dice {
      constructor(sides=6){
        Object.defineProperty(this, 'sides', {
        get() {
          return `This dice has ${sides} sides`;
        },
        set(value) {
          if(value > 0) {
          sides = value;

          return sides;
          } else {
            throw new Error('The number of sides must be
            positive');
          }
        }
      });

      this.roll = function() {
        return Math.floor(sides * Math.random() + 1)
        }
      }
    }</b>

    <b>const yellowDice = new Dice;</b>

    <b>yellowDice.sides;</b>
    &#60;&#60; "This dice has 6 sides"

    <b>yellowDice.sides = 10;</b>
    &#60;&#60; 10

    <b>yellowDice.sides;</b>
    &#60;&#60; "This dice has 10 sides"

    <b>yellowDice.sides = 0;</b>
    &#60;&#60; Error: "The number of sides must be positive"
        </pre>
        <u>Creating Objects from Other Objects</u>
        <p>
          We can create an object from another object. The original object acts
          sort of like a blueprint or a prototype. This is simply created as an
          object literal:
        </p>
        <pre>
    <b><a href="objectHuman.html" target="_blank">const Human</a> = {
      arms: 2,
      legs: 2,
      walk() { console.log('Walking'); }
    }</b>
        </pre>
        <p>
          We can create another human object from the one above by using the
          Object.create() method:
        </p>
        <pre>
    <b>const lois = Object.create(Human);</b>

    <b>lois.arms;</b>
    &#60;&#60; 2

    <b>lois.legs;</b>
    &#60;&#60; 2

    <b>lois.walk();</b>
    &#60;&#60; Walking

    <b>Human.isPrototypeOf(lois);</b> // The Human object is the prototype of the lois object
    &#60;&#60; true
        </pre>
        <p>
          We can even add extra properties to each instance using assignment.
        </p>
        <pre>
    <b>lois.name = 'Lois Lane';</b>
    &#60;&#60; 'Lois Lane'

    <b>lois.job = 'Reporter';</b>
    &#60;&#60; 'Reporter'
        </pre>
        <p>
          There is an alternative way to add a second argument to the
          Object.create() method containing properties that are to be added to
          the new object:
        </p>
        <pre>
    <b>const jimmy = Object.create(Human, { name: { value: 'Jimmy Olsen', enumerable: true }, job: { value: 'Photographer', enumerable: true } });</b>
        </pre>
        <p>
          This method is a little unwieldy as the properties have to be added
          using property descriptors, making the syntax awkward and overly
          verbose. It’s often easier to create the object, then add each new
          property one by one.
        </p>
        <p>
          The Human object can also act like a ‘super-class’, and become the
          prototype of another object called Superhuman. This will have all the
          properties and methods that the Human object has, but with some extra
          methods
        </p>
        <pre>
    const Superhuman = Object.create(Human);

    Superhuman.change = function() {
      return `${this.realName} goes into a phone box and comes out as ${this.name}!`;
    };
        </pre>
        <p>
          This method relies on the name and realName properties. It can be a
          good idea to create default values in the prototype so the method will
          still work. In this case, we can use names that prompt some real data
          to be added:
        </p>
        <pre>
    <b>Superhuman.name = 'Name Needed';</b>
    &#60;&#60; 'Name Needed'

    <b>Superhuman.realName = 'Real Name Needed';</b>
    &#60;&#60; 'Real Name Needed'
        </pre>
        <p>
          We can now use the Superhuman object as a prototype to create more
          objects based on it.
        </p>
        <pre>
    <b>const superman = Object.create(Superhuman);</b>

    <b>superman.name = 'Superman';</b>
    superman.realName = 'Clark Kent';

    <b>superman.change();</b>
    &#60;&#60; Clark Kent goes into a phone box and comes out as Superman!
        </pre>
        <p>
          Adding custom properties in this way is certainly more long-winded
          than using a constructor function, where the initial values are passed
          as an argument to the constructor function. This can be fixed by
          adding a init() method to the Superhuman object that accepts
          initialization properties:
        </p>
        <pre>
    <b>Superhuman.init = function(name,realName){
      this.name = name;</b>

      <b>this.realName = realName;</b>

      <b>this.init = undefined;</b> // this line removes the init function, so it can only be called once
      
      <b>return this;
    }</b>

    // A new ojbect can easily be created and initialized
    <b>const batman = Object.create(Superhuman);</b> 
    <b>batman.init('Batman','Bruce Wayne');</b>

    <b>batman.change();</b>
    &#60;&#60; 'Bruce Wayne goes into a phone box and comes out as Batman!'

    // A new object can also be created and initialized in a single line by adding the call
    to the init() method at the end of the line that creates the object.
    <b>const aquaman = Object.create(Superhuman).init('Aquaman', 'Arthur Curry');</b>

    <b>aquaman.change();</b>
    &#60;&#60; 'Arthur Curry goes into a phone box and comes out as Aquaman!'
        </pre>
        <u>Ojbect Prototype Chain</u>
        <p>
          When we create an object from another object, using the
          Object.create() method, the new object will inherit all the properties
          and methods from the parent object it was created from.
        </p>
        <pre>
    <b>Superhuman.isPrototypeOf(superman);</b>
    &#60;&#60; true

    <b>Human.isPrototypeOf(Superhuman);</b>
    &#60;&#60; true

    <b>Superhuman.isPrototypeOf(batman);</b>
    &#60;&#60; true
        </pre>
        <figure>
          <img
            src="images/humanPrototypeChain.jpg"
            alt="Human Prototype Chain"
          />
          <figcaption>The prototype chain</figcaption>
        </figure>
        <p>
          Because of this chain, the superman object has all the properties and
          methods of the Human and Superhuman objects:
        </p>
        <pre>
    <b>superman.walk();</b>
    &#60;&#60; Walking

    <b>built-insuperman.change();</b>
    &#60;&#60; 'Clark Kent goes into a phone box and comes out as Superman!'
        </pre>
        <u><a href="mixin.html"></a>Mixins</u>
        <p>
          A mixin is a way of adding properties and methods of some objects to
          another object without using inheritance. It allows more complex
          objects to be created by ‘mixing’ basic objects together. This one is
          interesting. Basic mixin functionality is provided by the
          Object.assign() method. This will assign to the object provided as the
          first argument all of the properties from any objects provided as
          further arguments. After that you can name them what you want
          indiviually.
        </p>
        <pre>
    <b>const a = {};</b>

    <b>const b = { name: 'JavaScript' };</b>
    
    <b>Object.assign(a,b);</b>
    &#60;&#60; { name: 'JavaScript' }

    <b>a.name;</b>
    &#60;&#60; 'JavaScript'

    <b>b.name;</b>
    &#60;&#60; 'JavaScript'

    <b>a.name = "BASIC";</b>
    'Java'

    <b>a.name;</b>
    &#60;&#60; 'BASIC'

    <b>b.name;</b>
    &#60;&#60; 'JavaScript'
        </pre>
        <p>
          For the example above it works well. The problem come when you try to
          do the same thing with an array. Arrays and functions are objects, so
          whenever they’re copied by assignment they will just point to the same
          object. And when one changes, they all change. This is known as making
          a shallow copy of an object.
        </p>
        <pre>
    <b>const a = {};</b>

    <b>const b = { numbers: [1,2,3] };</b>

    <b>Object.assign(a,b);</b>
    &#60;&#60; { numbers: [1,2,3] }

    <b>b.numbers.push(4);</b>
    &#60;&#60; 4

    <b>b.numbers;</b>
    &#60;&#60; [1,2,3,4]

    <b>a.numbers;</b> // This has also changed
    &#60;&#60; [1,2,3,4]

    // It does not matter which one you update, they will both change.
    <b>a.numbers.push(5);</b>
    &#60;&#60; 5

    <b>a.numbers;</b>
    &#60;&#60; [1,2,3,4,5]

    <b>b.numbers;</b> // This has also changed
    &#60;&#60; [1,2,3,4,5]
        </pre>
        <p>
          You can avoid a shallow copy by creaing your own mixin() function that
          will assign all properties of an object to another object as a deep
          copy. Here is the example the book gave but there are some issues with
          it. It does not work with the code that follows this code. There was
          an extra '{' in the code. I removed it and I get an illegal return
          error.
        </p>
        <pre>
    <b>function mixin(target, ...objects) {
        for (const object of objects) {
          if (typeof object === "object") {
            for (const key of Object.keys(object)) {
              if (typeof object[key] === "object") {
                target[key] = Array.isArray(object[key]) ? [] : {};
                mixin(target[key], object[key]);
              } else {
                Object.assign(target, object);
              }
            }
          }
        }
        return target;
      }</b>
        </pre>
        <p>
          Here is the code above explained in the book. If the property is an
          object, we use a ternary operator to check whether it is an array or
          an object using the Array.isArray() method. If it is an array, then
          its constructor function will be Array. We create a new array literal,
          otherwise we create a new object literal.
        </p>
        <p>
          Important part: This ensures a deep copy. The problematic properties
          that are not deep copied are arrays and objects. Both of these return
          object when the typeof operator is used. If that is the case, we need
          to do something different than just use Object.assign() to copy the
          property. Here is an example the book gives to test if it makes a deep
          copy. No time to look into it yet but the code above this is what it
          is suppose to look like.
        </p>
        <pre>
          <b>const a = {}, b = { foo: 'bar' }, c = { numbers: [1,2,3] };</b>

          <b>mixin(a,b,c);</b>
          &#60;&#60; { foo: 'bar', numbers: [ 1, 2, 3 ] }

          <b>c.numbers.push(4);</b>
          &#60;&#60; 4

          <b>a.numbers;</b>
          &#60;&#60; [ 1, 2, 3 ]

          <b>c.numbers</b>
          &#60;&#60; [ 1, 2, 3, 4]
        </pre>
        <u>Using Mixins to Add Properties</u>
        <p>
          One use for the mixin() function is to add a large number of
          properties to an object all at once. For example, we can instantiate a
          new Superhuman object, then add all its individual properties in one
          go, instead of one at a time, as we did earlier, while avoiding having
          to use the more verbose property descriptor notation. But like the
          code example above it will not work because the mixin() function is
          not working but this is what it would look like it if was.
        </p>
        <pre>
    <b>const wonderWoman = Object.create(Superhuman);</b>

    // Assigning each property, one by one
    <b>wonderWoman.name = 'Wonder Woman';</b>
    &#60;&#60; 'Wonder Woman'

    <b>wonderWoman.realName = 'Diana Prince';</b>
    &#60;&#60; 'Diana Prince'

    // We can just mix in an object literal and add both properties at once
    <b>mixin(wonderWoman,{ name: 'Wonder Woman', realName: 'Diana Prince' });</b>

    <b>wonderWoman.change();</b>
    &#60;&#60; 'Diana Prince goes into a phone box and comes out as Wonder Woman'
        </pre>
        <u>Using Mixins to Create a copy() Function</u>
        <p>
          Another use of the mixin() function is to create a copy() method that
          can be used to make an exact, deep copy of an object:
        </p>
        <pre>
    <b>function copy(target) {
      const object =  Object.create(Object.getPrototypeOf(target));

      mixin(object,target);

      return object;
  }</b>

    <b>const bizarro = copy(superman);</b>

    <b>bizarro.name = 'Bizarro';</b>
    &#60;&#60; 'Bizarro';

    <b>bizarro.realName = 'Subject B-0';</b>
    &#60;&#60; 'Subject B-0'

    <b>bizarro.change();</b>
    &#60;&#60; 'Subject B-0 goes into a phone box and comes out as Bizzaro!'
        </pre>
        <p>
          The copy() function can now be used to create a factory function for
          superheros. A factory function is a function that can be used to
          return an object. The factory function will be based on the Superhuman
          object. The createSuperhuman() function is an example of a factory
          function that can now be used to create as many superhuman objects as
          required.
        </p>
        <pre>
    <b>function createSuperhuman(...mixins) {
      const object = copy(Superhuman);
      
      return mixin(object,...mixins);
    }</b>

    <b>const hulk = createSuperhuman({name: 'Hulk', realName: 'Bruce Banner'});</b>

    <b>hulk.change();</b>
    &#60;&#60; 'Bruce Banner goes into a phone box and comes out as Hulk!'
        </pre>
        <u>Using the Mixin Function to Add Modular Functionality</u>
        <p>
          Inheritance allows us to add functionality to objects by inheriting
          properties and methods from other objects. It can be undesirable to
          create a chain of inheritance. Sometimes we just want to add
          properties and methods without linking the two objects together. The
          mixin() function lets us encapsulate properties and methods in an
          object, then add them to other objects without the overhead of an
          inheritance chain being created. The difference between prototypal
          inheritance and inheritance from mixin objects is to consider whether
          an object is something or whether it has something. For example, a
          tank is a vehicle, so it might inherit from a Vehicle prototype. The
          tank also has a gun, so this functionality could be added using a gun
          mixin object. This gives us extra flexibility, since other objects
          might also use a gun, but not be a vehicle, such as a soldier object,
          for example. The soldier object might inherit from a Human prototype
          and also have the gun mixin. We can use this idea to add superpowers
          to our superhero objects used earlier. All the superheroes are super
          human, so they inherited any common traits from a Superhuman
          prototype. But they also have superpowers, and each superhero has a
          Object-Oriented Programming in JavaScript 489 different mix of powers.
          This is a perfect use case for mixin objects: we can create some
          superpower mixin objects that can then be added to any of our
          superhero objects as required.
        </p>
        <pre>
    <b>const flight = {
      fly() {
        console.log(`Up, up and away! ${this.name} soars through the air!`);
        return this;
      }
    }
    
    const superSpeed = {
      move() {
        console.log(`${this.name} can move faster than a speeding bullet!`);
        return this;
      }  
    }
    
    const xRayVision = {
      xray() {
        console.log(`${this.name} can see right through you!`);
        return this;
      }  
    }</b>
        </pre>
        <p>
          Now we can add the relevant superpowers to each object in a modular
          fashion using the mixin() function and see they have gained some extra
          methods.
        </p>
        <pre>
    <b>mixin(superman,flight,superSpeed,xRayVision);</b>

    <b>mixin(wonderwoman,flight,superSpeed);</b>

    <b>superman.xray();</b>
    &#60;&#60; 'Superman can see right through you!'

    <b>wonderWoman.fly();</b>
    &#60;&#60; 'Up, up and away! Wonder Woman soars through the air!'
        </pre>
        <p>
          We can also add the mixins as an argument to the createSuperhero()
          factory function that we made earlier to create a superhero object
          with all the relevant methods from the start:
        </p>
        <pre>
    <b>const flash = createSuperhuman({ name: 'Flash', realName: 'Barry Allen' }, superSpeed);</b>

    <b> flash.change();</b>
    &#60;&#60; 'Barry Allen goes into a phone box and comes out as Flash!'

    <b>flash.move();</b>
    &#60;&#60; Flash can move faster than a speeding bullet!
        </pre>
        <p>
          If a method returns this, its methods can be chained together to form
          a sequence Object-Oriented Programming in JavaScript 491 of method
          calls that are called one after the other. For example, the superman
          object can call all three of the superpower methods at once:
        </p>
        <pre>
    <b>superman.fly().move().xray();</b>
    &#60;&#60; Up, up and away! Superman soars through the air!
       Superman can move faster than a speeding bullet!
       Superman can see right through you!
        </pre>
        <p>
          Binding this allows us to create generalized methods that refer to
          properties specific to a particular object. When a function is nested
          inside another function, which can often happen when using methods in
          objects, especially ones that accept callback functions. The problem
          is that the value of this loses its scope, and points to the global
          object inside a nested function, as can be seen in this example.
        </p>
        <pre>
    // Bad example
    <b>superman.findFriends = function () {
      this.friends.forEach(function (friend) {
        console.log(`${friend.name} is friends with ${this.name}`);
      });
    };</b>

    // Better example
    <b>superman.findFriends = function () {
      const that = this;

      this.friends.forEach(function (friend) {
        console.log(`${friend.name} is friends with ${that.name}`);
      });
    };</b>

    // Both return the same results but the second one is better 
    <b>superman.findFriends();</b>
    &#60;&#60; Batman is friends with Superman
       Wonder Woman is friends with Superman
       Aquaman is friends with Superman
        </pre>
        <p>
          ES6 introduced the for-of syntax for arrays and this does not require
          a nested function to be used, so this remains bound to the superman
          object:
        </p>
        <pre>
    <b>superman.findFriends = function () {
      for (const friend of this.friends) {
        console.log(`${friend.name} is friends with ${this.name}`);
      }
    };</b>

    <b>superman.findFriends();</b>
    &#60;&#60; Batman is friends with Superman
       Wonder Woman is friends with Superman
       Aquaman is friends with Superman
        </pre>
        <p>
          Arrow functions were introduced in ES6, and one of the advantages of
          using them is that they don’t have their own this context, so this
          remains bound to the original object making the function call
        </p>
        <pre>
    <b>superman.findFriends = function () {
      this.friends.forEach((friend) => {
        console.log(`${friend.name} is friends with ${this.name}`);
      });
    };</b>

    <b>superman.findFriends();</b>
    &#60;&#60; Batman is friends with Superman
       Wonder Woman is friends with Superman
       Aquaman is friends with Superman
        </pre>
        <u>Borrowing Methods from Prototypes</u>
        <p>
          It is possible to borrow methods from objects withouthaving to inherit
          all their properties and methods. This is done by making a reference
          to the function that you want to borrow (that is, without parentheses
          so that it isn’t invoked). For example, the batman object doesn’t have
          any of the superpower methods that the superman object has, but we can
          create a reference to them that can then be used by another object.
          For example, we can create a fly() function by referencing the
          superman object’s fly method:
        </p>
        <pre>
    <b>const fly = superman.fly;</b>
        </pre>
        <p>
          This method can now be called on another object using the call method
          that all functions have.
        </p>
        <pre>
    <b>fly.call(batman);</b>
    &#60;&#60; Up, up and away! Batman soars through the air!
        </pre>
        <u>Borrowing Array Methods</u>
        <p>
          One of the most common uses of borrowing methods was to borrow methods
          from arrays in ES5. There are many array-like objects in JavaScript,
          such as the arguments object that’s available in functions, and the
          node lists that many of the DOM methods return. These act like arrays
          but are missing a lot of the methods arrays have — often it would be
          convenient if they had them. the arguments object can use the slice()
          method from the Array constructor’s prototype by assigning a variable
          that points to it.
        </p>
        <pre>
    <b>const slice = Array.prototype.slice;</b>
        </pre>
        <p>
          This method can then be called on the arguments object using the
          call() method:
        </p>
        <pre>
    <b>slice.call(arguments, 1, 3);</b>
        </pre>
        <p>
          An array-like object can effectively be turned into an array using the
          slice() method with no arguments. This will return the arguments
          object as an array (since the slice() method returns an array).
        </p>
        <pre>
    <b>const argumentsArray = Array.prototype.slice.call(arguments);</b>
        </pre>
        <p>
          Most of these techniques are not needed from ES6 onwards as the
          Array.from() method can be used to turn an array-like object into an
          array:
        </p>
        <pre>
    <b>const argumentsArray = Array.from(arguments);</b>
        </pre>
        <p>
          Alternatively, the spread operator can be used to easily turn an
          array-like object into an array like so:
        </p>
        <pre>
    <b>const argumentsArray = [...arguments];</b>
        </pre>
        <u>Composition Over Inheritance</u>
        <p>
          If you do decide to use classes, it’s recommended to make them
          “skinny” ― meaning they don’t have too many properties and methods.
          Another good practice when creating classes is to keep inheritance
          chains short. If you have long lines of inheritance, the objects at
          the end of these chains will usually end up being bloated with
          properties and methods they don’t need. It also causes problems if any
          of the objects in the chain need to change, as these changes will also
          affect other objects in the chain. A good rule of thumb is to only
          inherit once, keeping the inheritance chain to just two objects makes
          unpicking any issues far easier.
        </p>
        <p>
          If you want to use a particular method from a class, but it has lots
          of properties and methods you don’t need, then it would be preferable
          to just borrow the method instead, as we saw in the last section.
        </p>
      </div>
      <hr />
      <div>
        <h1>Notes from JavaScript: Novice to Ninja - Chapter 15:</h1>
        <h2>Modular</h2>
        <p>
          A module is a self-contained piece of code that provides functions and
          methods that can then be used in other files and by other modules.
          This helps keep the code orgainzed in seperate, reusable files. This
          improves code maintainability. Like what I was tought in WDD 230, a
          function should only have a single purpose. The code in a module
          should also have a single purpose. For example, you might keep any
          functions used for Ajax in their own module. This could then be used
          in any projects where Ajax was required. By doing so, it allows you to
          easily swap one module for another without affecting other parts of a
          project. Modules also allow a public API to be exposed, while keeping
          the implementation hidden away inside the module.
        </p>
        <p>
          The coupling of code refers to how dependent certain elements or
          modules of code are on each other. Two pieces of code are said to be
          tightly coupled if one relies on the other to run. This often occurs
          if a piece of code makes hard-coded references to another piece of
          code, requiring it to be used. This will often mean that changes to
          one piece of code will necessitate changes in the other. On the other
          hand, two pieces of code are said to loosely coupled if one piece of
          code can be easily substituted by another without affecting the final
          outcome. This is often achieved by referring to common methods that
          are shared by the alternative modules.
        </p>
        <p>
          Here is an example of a very simple Pi module. The following code
          would be saved in a file called pi.js.
        </p>
        <pre>
    export const PI = 3.1415926;
        </pre>
        <p>
          This would then be imported into your main JavaScript file, main.js
          using the following code and allow you to use the variable PI inside
          the main.js file.
        </p>
        <pre>
    import { PI } from './pi.js';
        </pre>
        <p>
          You can also export functions from a module. For example, we could
          create a library for our stats functions that we used earlier:
        </p>
        <pre>
    function square(x) {
      return x * x;
    }
    
    function sum(array, callback) {
      if (callback) {
        array = array.map(callback);
      }
      return array.reduce((a, b) => a + b);
    }
    
    function variance(array) {
      return sum(array, square) / array.length - square(mean(array));
    }
    
    function mean(array) {
      return sum(array) / array.length;
    }
    
    export {
      variance,
      mean
    };
        </pre>
        <p>
          Notice that an alternative to using export when the function is
          defined is to add the export directive after the function definition,
          as seen in the example above with the variance() function. To import
          these functions into the main.js file, you’d add this line of code:
        </p>
        <pre>
    // To import these functions into the main.js file
    import { mean, variance } from './stats.js';

    // Or you can be selective and only import the mean() function
    import { mean } from './stats.js';
        </pre>
        <p>
          If there are lots of values and functions that need to be imported,
          then everything in a module file can be imported using the wildcard
          symbol * along with a namespace for the imported values and functions
          using the following notation:
        </p>
        <pre>
          import * as stats from './stats.js';
        </pre>
        <p>
          This will then import all the functions from the stats.js module and
          they’ll be given a namespace of stats. So, the mean function could be
          used as follows:
        </p>
        <pre>
          stats.mean([2,6,10]);
        </pre>
        <u>Default Exports</u>
        <p>
          Default exports refer to a single variable, function or class in a
          module that can be imported without having to be explicitly named. The
          syntax for default exports is purposely easier to read because this is
          how modules were designed to be used.
        </p>
        <pre>
    // The following example demonstrates how this would be done for a variable
    const PI = 3.145926;

    export default PI;

    // The next example demonstrates exporting a single default function:
    function square(x) {
      return x * x;
    }
    
    export default square;

    // The last example shows how to export an object as the default value
    const stats = {
      square(x) {
        return x * x;
      },
      sum(array, callback) {
        if (callback) {
          array = array.map(callback);
        }
        return array.reduce((a, b) => a + b);
      },
      mean(array) {
        return this.sum(array) / array.length;
      },
      variance(array) {
        return (
          this.sum(array, this.square) / array.length -
          this.square(this.mean(array))
        );
      },
    };
    export default stats;

    // To import these default values, you would use the following code:
    import PI from './pi.js';
    import square from './square.js';
    import stats from './stats.js';
        </pre>
        <p>
          The big difference with default exports is that you don’t need to use
          curly braces or make any mention of the value that is being imported,
          making the statement read more elegantly.
        </p>
        <u>Aliases</u>
        <p>
          The alias that is assigned to the imported module does not have to
          match its name in the actual module. For example, you could import the
          square function in the following way:
        </p>
        <pre>
    import sq from './square.js';

    // The function would then be called using sq() rather than square()
    sq(8)
    &#60;&#60; 64
        </pre>
        <u>Node.js Modules</u>
        <p>
          Node.js had already implemented modules before they were introduced in
          ES6, and used a slightly different notation called Common JS modules.
          Node.js will support ES6 modules in some way in the future. But till
          then Common JS module will most like be be used for years to come.
        </p>
        <p>
          A Common JS module is created in a separate file, and the
          module.exports method is used to make any functions available to other
          files, in a similar way to ES6 modules. For example, we could create a
          module for squaring numbers using the following code inside a file
          called squareFunction.js:
        </p>
        <pre>
    module.exports = x => x * x;
        </pre>
        <p>
          This is simply the square() function we saw earlier in the chapter
          written as an anonymous function that’s assigned to module.exports as
          if it was a variable.
        </p>
        <p>
          To use the module, it needs to then be required inside the another JS
          file (or from within the Node REPL). This is done using the require()
          method. This takes the file that contains the module as an argument
          and returns the function that was exported:
        </p>
        <pre>
    const square = require('./squareFunction');
        </pre>
        <p>
          The function that was exported in the module is now assigned to the
          variable square, which is then used to call the function in the usual
          way:
        </p>
        <pre>
    square(6);
    &#60;&#60; 36
        </pre>
      </div>
    </main>

    <!-- FOOTER HERE -->
    <footer id="footerWrapper">
      <p>
        &copy;2021 | Jesse Wilson | Cardston, AB | WDD 330: Frontend Web
        Development II
      </p>
    </footer>
  </body>
</html>
