<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="description" content="infomation about site." />
    <meta name="author" content="Jesse Wilson" />

    <!-- SITE TITLE -->
    <title>Week 5 Notes & Codes</title>

    <!-- TELLS PHONES NOT TO LIE ABOUT THEIR WIDTH & stops the font from
      enlarging when a phone is turned sideways-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- STYLE SHEETS -->
    <link href="css/normalize.css" rel="stylesheet" />
    <!-- phone-default -->
    <link href="css/small.css" rel="stylesheet" />
    <!-- enhance-tablet -->
    <link href="css/medium.css" rel="stylesheet" />
    <!-- enhance-desktop -->
    <link href="css/large.css" rel="stylesheet" />

    <!-- JAVASCRIPTS-->
    <script defer src="js/styles.js"></script>
  </head>
  <body>
    <!-- HEADER HERE -->
    <header id="headerWrapper">
      <h1>Week 5 Notes & Codes</h1>
    </header>

    <!-- NAVIGATION HERE -->
    <nav></nav>

    <!-- CONTENT HERE -->
    <main>
      <u>Errors, Exceptions, and Warnings</u>
      <p>
        Errors are caused by one of the following when something goes wrong in
        the program:
      </p>
      <ul>
        <li>
          System error ― there’s a problem with the system or external devices
          with which the program is interacting
        </li>
        <li>
          Programmer error ― the program contains incorrect syntax or faulty
          logic; it could even be as simple as a typo
        </li>
        <li>
          User error ― the user has entered data incorrectly, which the program
          is unable to handle
        </li>
      </ul>
      <p>
        As prorammers, we have little influence how external systems work but we
        should be aware of them and attempt to reduce ther impact. Programmer
        errors are our responsibility, so we must ensure they are minimized as
        much as possible and fixed promptly. We should try to limit user errors
        by predecting any possible interactions that may throw an error, and
        ensure they are dealt with in a way that doesn’t negatively affect the
        user experience. It might even be argued that user errors are in fact
        also programmer errors, because the program should be designed in a way
        that prevents the user from making the error.
      </p>
      <u>Exceptions</u>
      <p>
        An exception is an error that produces a return value that can then be
        used by the program to deal with the error. One example is calling a
        method that does not exsist. This is what it looks like when you call a
        method that does not exsist:
      </p>
      <pre>
  unicorn();
  &#60;&#60; ReferenceError: unicorn is not defined
      </pre>
      <p>
        An exception will produce a stack trace. It looks like it is set up to
        work backwards as you will see in the example below. It is usually one
        function or method that will cause the error. In this example, we have
        three functions: function one()invokes function two(), which then
        invokes function three(). Function three()then invokes the
        unicorn()function that doesn't exist and causes an error. We can use the
        stack trace to work backwards and see that this error was caused by
        invoking the function one()in the first place:
      </p>
      <pre>
  function three(){ unicorn(); } // calls function unicorn which is undefined
  function two(){ three(); } // calls function three
  function one(){ two(); } // calls function two
  one(); // calls function one

  &#60;&#60; index.html:13 Uncaught ReferenceError: unicorn is not defined
     at three (index.html:13)
     at two (index.html:17)
     at one (index.html:21)
     at index.html:24`
      </pre>
      <p>
        A warning can occur if there’s an error in the code that isn't enough to
        cause the program to crash. This means the program will continue to run
        after a warning. This might sound good, but it can be problematic, since
        the issue that produced the warning may cause the program to continue
        running incorrectly. An example of a mistake that could cause a warning
        is assigning a value to a variable that’s undeclared:
      </p>
      <pre>
  pi = 3.142;
  &#60;&#60; JavaScript Warning: assignment to undeclared variable

  let pi = 3.142;
  &#60;&#60; 3.142
      </pre>
      <p>
        Warnings and exceptions are presented differently in various
        environments. Some browsers will show a small icon in the corner of the
        browser window to indicate that an exception or warning has occurred.
        Others require the console to be open to see any warnings or exceptions.
      </p>
      <u>The Importance of Testing and Debugging</u>
      <p>
        I have worked in the DISA for four years and in the IT field longer. The
        hardest thing is troubleshooting and replicating the problem. Javascript
        can be a fairly forgiving language. exceptions were not implemented
        until ECMAScript version 3. If no alert is given, the error might give
        unexpectd or incorrect results that no one spots and may run in the
        background for some time before the program crashes. To help programmers
        should encure their code fails loud so it can be identified and fixed
        quickly.
      </p>
      <u>Strict Mode</u>
      <p>
        Increasing the chance of errors might seem like a bad idea at first, but
        it’s much better to spot errors early on, rather than have them cause
        problems later. Writing code in strict mode can also help improve its
        clarity and speed, since it follows conventions and will throw
        exceptions if any sloppy code practices are used. I find it interesting
        that not using strict mode is often referred to as 'sloppy mode'. I am
        not sure how you know there are problems in the code by using 'use
        strict' but I will see when and if I use it. Here are three examples of
        how 'use strict' can be used:
      </p>
      <pre>
  'use strict';

  e = 2.718;
  &#60;&#60; ReferenceError: e is not defined
      </pre>
      <p>
        By adding the line inside a function, strict mode will then only be
        applied to anything inside that function.
      </p>
      <pre>
  function strictly(){
    'use strict';
    // function code goes here
  }
      </pre>
      <p>
        The recommended way to invoke strict mode is to place all your code into
        a self-invoking function.
      </p>
      <pre>
  (function() {
    'use strict';

    // All your code would go inside this function
  
  }());
      </pre>
      <u>Linting Tools</u>
      <p>
        Linting tools such asJS Lint,JS Hint,andES Lintcan be used to test the
        quality of JavaScript code. They are designed to highlight any sloppy
        programming practices or syntax errors, and can be very unforgiving.
        It's possible to add a linting tool as a text-editor plugin; this will
        then highlight any sloppy code as you type. For more information about
        ESLint go to
        <a
          href="https://www.sitepoint.com/up-and-running-with-eslint-the-pluggable-javascript-linter/"
          target="_blank"
          >this article on SitePoint</a
        >.
      </p>
      <u>Feature Detection</u>
      <p>
        Programming in JavaScript can be something of a moving target as the
        APIs it uses are in a constant state of flux and there are new APIs
        being developed as part of the HTML5 specification all the time. Browser
        vendors add support for these new features but may not always keep up
        with the changes. Some vendors don't support certain features. You can't
        always rely on users having the most up-to-date browser. To help
        determine browser support for a feature you should use feature
        detection. For example, say we want to use the shiny new holoDeck API
        (as far as I know, this doesn't actually exist ... yet), we would wrap
        any method calls inside the following if block:
      </p>
      <pre>
  if (window.holoDeck) {
    virtualReality.activate();
  }
      </pre>
      <p>
        This ensures that no error occurs if the browser doesn’t support the
        method, because referencing a nonexistent object such as
        window.virtualReality will return undefined.
      </p>
      <u>Debugging in the Browser</u>
      <p>
        Debugging is the process of finding out where bugs occur in the code and
        then dealing with them. It is useful to do this by creating breakpoints,
        which will stop the process of the code and allow us to go line by line
        to see what is or is not happening.
      </p>
      <p>
        The most basic form of debugging is to use the alert() method to show a
        dialog at certain points in the code. The alert() method allows us to
        effectively put breakpoints in the code that let us check the value of
        variables at that point to see if they’re what we expect them to be.
      </p>
      <u>The console.log() method:</u>
      <pre>
  function amIOldEnough(age){
    if (age &#60; 12) {
        alert(age);
        return 'No, sorry.';
    } else if (age &#60; 18) {
        return 'Only if you are accompanied by an adult.';
    }
    else {
        return 'Yep, come on in!';
    }
  }
      </pre>
      <u>Debugger Command</u>
      <p>
        One of the most useful commands is the debugger keyword. This will
        create a breakpoint in your code that will pause the execution of the
        code and allow you to see where the program is currently up to. Just
        remember to remove any references to the debugger command before
        shipping any code.
      </p>
      <pre>
  function amIOldEnough(age){
    debugger;
        if (age &#60; 12) {
          debugger;
          return 'No, sorry.';
        } else if (age &#60; 18) {
          debugger;
          return 'Only if you are accompanied by an adult.';
        } else {
          debugger;
          return 'Yep, come on in!';
    }
  }
      
  amIOldEnough(16);
      </pre>
      <u>Error Objects</u>
      <p>
        An error object can be created by the host environment when an exception
        occurs, or it can be created in the code using a constructor function,
        like so:
      </p>
      <pre>
  const error = new Error();

  // This constructor function takes a parameter that’s used as the error message:
  const error = new Error('Oops, something went wrong');
      </pre>
      <p>
        There are seven more error objects that are used for specific errors:
      </p>
      <ul>
        <li>
          <b>EvalError</b> is not used in the current ECMAScript specification
          and only retained for backwards compatibility. It was used to identify
          errors when using the global eval() function.
        </li>
        <li>
          <b>RangeError</b> is thrown when a number is outside an allowable
          range of values.
        </li>
        <li>
          <b>ReferenceError</b> is thrown when a reference is made to an item
          that doesn’t exist. For example, calling a function that hasn’t been
          defined.
        </li>
        <li>
          <b>SyntaxError</b> is thrown when there’s an error in the code’s
          syntax.
        </li>
        <li>
          <b>TypeError</b> is thrown when there’s an error in the type of value
          used; for example, a string is used when a number is expected.
        </li>
        <li>
          <b>URIError</b> is thrown when there’s a problem encoding or decoding
          the URI.
        </li>
        <li>
          <b>InternalError</b> is a non-standard error that is thrown when an
          error occurs in the JavaScript engine. A common cause of this is too
          much recursion.
        </li>
      </ul>
      <p>
        These error objects can also be used as constructors to create custom
        error objects:
      </p>
      <pre>
  const error = new TypeError('You need to use numbers in this function');
      </pre>
      <p>
        All error objects have a number of properties, but they’re often used
        inconsistently across browsers. The only properties that are generally
        safe to use are:
      </p>
      <ul>
        <li>
          The name property returns the name of the error constructor function
          used as a string, such as “Error” or “ReferenceError”.
        </li>
        <li>
          The message property returns a description of the error and should be
          provided as an argument to the Error constructor function.
        </li>
        <li>
          The stack property will return a stack trace for that error. This is a
          nonstandard property and it’s recommended that it is not safe to use
          in production sites.
        </li>
      </ul>
      <u>try, catch, and finally</u>
      <p>
        If we suspect a piece of code will result in an exception, we can wrap
        it in a try block. This will run the code inside the block as normal,
        but if an exception occurs it will pass the error object that is thrown
        onto a catch block. Here’s a simple example using our squareRoot()
        function from earlier:
      </p>
      <pre>
  function imaginarySquareRoot(number) {
    'use strict';
    try {
        return String(squareRoot(number));
    } catch(error) {
        return squareRoot(-number)+'i';
    }
  }

  // If we suspect a piece of code will result in an exception, we can wrap it in
  // a try block.
  imaginarySquareRoot(-49) // no error message shown
  &#60;&#60; '7i'

  // A finally block can be added after a catch block. This will always be
  // executed after the try or catch block, regardless of whether an exception
  // occurred or not.
  function imaginarySquareRoot(number) {
    'use strict';
    let answer;
    try {
        answer = String(squareRoot(number));
    } catch(error) {
        answer = squareRoot(-number)+"i";
    } finally {
        return `+ or - ${answer}`;
    }
  }
      </pre>
      <u>Tests</u>
      <p>
        Testing is an important part of programming that can often be
        overlooked. A test can simply be a function that tests a piece of code
        runs as it should.
      </p>
      <pre>
  function itSquareRoots4() {
    return squareRoot(4) === 2;
  }
      </pre>
      <p>
        Here we’re comparing the result of squareRoot(4) with the number 2. This
        will return true if our function works as expected, which it does:
      </p>
      <pre>
  itSquareRoots4();
  &#60;&#60; true
      </pre>
      <u>Test-driven development(TDD)</u>
      <p>
        TDD is the process of writing tests before any actual code. Obviously
        these tests will initially fail, because there is no code to test. The
        next step is to write some code to make the tests pass. The code is
        continually tested at each stage to make sure it continues to work. This
        process should be followed in small piecemeal chunks every time a new
        feature is implemented, resulting in the following workflow. This is
        often referred to as the “red-green-refactor” cycle of TDD, as failing
        tests 368 JavaScript: Novice to Ninja, 2nd Edition usually show up as
        red, and tests that pass show as green.
      </p>
      <ul>
        <li>Write tests (that initially fail)</li>
        <li>Write code to pass the tests</li>
        <li>Refactor the code</li>
        <li>Test refactored code</li>
        <li>Write more tests for new features</li>
      </ul>
      <u>Jest</u>
      <p>Stopped on page 370 in the book (p. 389 in PDF)</p>
    </main>

    <!-- FOOTER HERE -->
    <footer id="footerWrapper">
      <p>
        &copy;2021 | Jesse Wilson | Cardston, AB | WDD 330: Frontend Web
        Development II
      </p>
    </footer>
  </body>
</html>
