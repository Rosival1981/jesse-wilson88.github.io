<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="description" content="infomation about site." />
    <meta name="author" content="Jesse Wilson" />

    <!-- SITE TITLE -->
    <title>Week 5 Notes & Codes</title>

    <!-- TELLS PHONES NOT TO LIE ABOUT THEIR WIDTH & stops the font from
      enlarging when a phone is turned sideways-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- STYLE SHEETS -->
    <link href="css/normalize.css" rel="stylesheet" />
    <!-- phone-default -->
    <link href="css/small.css" rel="stylesheet" />
    <!-- enhance-tablet -->
    <link href="css/medium.css" rel="stylesheet" />
    <!-- enhance-desktop -->
    <link href="css/large.css" rel="stylesheet" />

    <!-- JAVASCRIPTS-->
    <script defer src="js/styles.js"></script>
  </head>
  <body>
    <!-- HEADER HERE -->
    <header id="headerWrapper">
      <h1>Week 5 Notes & Codes</h1>
    </header>

    <!-- NAVIGATION HERE -->
    <nav></nav>

    <!-- CONTENT HERE -->
    <main>
      <u>Errors, Exceptions, and Warnings</u>
      <p>
        Errors are caused by one of the following when something goes wrong in
        the program:
      </p>
      <ul>
        <li>
          System error ― there’s a problem with the system or external devices
          with which the program is interacting
        </li>
        <li>
          Programmer error ― the program contains incorrect syntax or faulty
          logic; it could even be as simple as a typo
        </li>
        <li>
          User error ― the user has entered data incorrectly, which the program
          is unable to handle
        </li>
      </ul>
      <p>
        As prorammers, we have little influence how external systems work but we
        should be aware of them and attempt to reduce ther impact. Programmer
        errors are our responsibility, so we must ensure they are minimized as
        much as possible and fixed promptly. We should try to limit user errors
        by predecting any possible interactions that may throw an error, and
        ensure they are dealt with in a way that doesn’t negatively affect the
        user experience. It might even be argued that user errors are in fact
        also programmer errors, because the program should be designed in a way
        that prevents the user from making the error.
      </p>
      <u>Exceptions</u>
      <p>
        An exception is an error that produces a return value that can then be
        used by the program to deal with the error. One example is calling a
        method that does not exsist. This is what it looks like when you call a
        method that does not exsist:
      </p>
      <pre>
  unicorn();
  &#60;&#60; ReferenceError: unicorn is not defined
      </pre>
      <p>
        An exception will produce a stack trace. It looks like it is set up to
        work backwards as you will see in the example below. It is usually one
        function or method that will cause the error. In this example, we have
        three functions: function one()invokes function two(), which then
        invokes function three(). Function three()then invokes the
        unicorn()function that doesn't exist and causes an error. We can use the
        stack trace to work backwards and see that this error was caused by
        invoking the function one()in the first place:
      </p>
      <pre>
  function three(){ unicorn(); } // calls function unicorn which is undefined
  function two(){ three(); } // calls function three
  function one(){ two(); } // calls function two
  one(); // calls function one

  &#60;&#60; index.html:13 Uncaught ReferenceError: unicorn is not defined
     at three (index.html:13)
     at two (index.html:17)
     at one (index.html:21)
     at index.html:24`
      </pre>
      <p>
        A warning can occur if there’s an error in the code that isn't enough to
        cause the program to crash. This means the program will continue to run
        after a warning. This might sound good, but it can be problematic, since
        the issue that produced the warning may cause the program to continue
        running incorrectly. An example of a mistake that could cause a warning
        is assigning a value to a variable that’s undeclared:
      </p>
      <pre>
  pi = 3.142;
  &#60;&#60; JavaScript Warning: assignment to undeclared variable

  let pi = 3.142;
  &#60;&#60; 3.142
      </pre>
      <p>
        Warnings and exceptions are presented differently in various
        environments. Some browsers will show a small icon in the corner of the
        browser window to indicate that an exception or warning has occurred.
        Others require the console to be open to see any warnings or exceptions.
      </p>
      <u>The Importance of Testing and Debugging</u>
      <p>
        I have worked in the DISA for four years and in the IT field longer. The
        hardest thing is troubleshooting and replicating the problem. Javascript
        can be a fairly forgiving language. exceptions were not implemented
        until ECMAScript version 3. If no alert is given, the error might give
        unexpectd or incorrect results that no one spots and may run in the
        background for some time before the program crashes. To help programmers
        should encure their code fails loud so it can be identified and fixed
        quickly.
      </p>
      <u>Strict Mode</u>
      <p>
        Increasing the chance of errors might seem like a bad idea at first, but
        it’s much better to spot errors early on, rather than have them cause
        problems later. Writing code in strict mode can also help improve its
        clarity and speed, since it follows conventions and will throw
        exceptions if any sloppy code practices are used. I find it interesting
        that not using strict mode is often referred to as 'sloppy mode'. I am
        not sure how you know there are problems in the code by using 'use
        strict' but I will see when and if I use it. Here are three examples of
        how 'use strict' can be used:
      </p>
      <pre>
  'use strict';

  e = 2.718;
  &#60;&#60; ReferenceError: e is not defined
      </pre>
      <p>
        By adding the line inside a function, strict mode will then only be
        applied to anything inside that function.
      </p>
      <pre>
  function strictly(){
    'use strict';
    // function code goes here
  }
      </pre>
      <p>
        The recommended way to invoke strict mode is to place all your code into
        a self-invoking function.
      </p>
      <pre>
  (function() {
    'use strict';

    // All your code would go inside this function
  
  }());
      </pre>
      <u>Linting Tools</u>
      <p>
        Linting tools such asJS Lint,JS Hint,andES Lintcan be used to test the
        quality of JavaScript code. They are designed to highlight any sloppy
        programming practices or syntax errors, and can be very unforgiving.
        It's possible to add a linting tool as a text-editor plugin; this will
        then highlight any sloppy code as you type. For more information about
        ESLint go to
        <a
          href="https://www.sitepoint.com/up-and-running-with-eslint-the-pluggable-javascript-linter/"
          target="_blank"
          >this article on SitePoint</a
        >.
      </p>
      <u>Feature Detection</u>
      <p>
        Programming in JavaScript can be something of a moving target as the
        APIs it uses are in a constant state of flux and there are new APIs
        being developed as part of the HTML5 specification all the time. Browser
        vendors add support for these new features but may not always keep up
        with the changes. Some vendors don't support certain features. You can't
        always rely on users having the most up-to-date browser. To help
        determine browser support for a feature you should use feature
        detection. For example, say we want to use the shiny new holoDeck API
        (as far as I know, this doesn't actually exist ... yet), we would wrap
        any method calls inside the following if block:
      </p>
      <pre>
  if (window.holoDeck) {
    virtualReality.activate();
  }
      </pre>
      <p>
        This ensures that no error occurs if the browser doesn’t support the
        method, because referencing a nonexistent object such as
        window.virtualReality will return undefined.
      </p>
      <u>Debugging in the Browser</u>
      <p>
        Debugging is the process of finding out where bugs occur in the code and
        then dealing with them. It is useful to do this by creating breakpoints,
        which will stop the process of the code and allow us to go line by line
        to see what is or is not happening.
      </p>
      <p>
        The most basic form of debugging is to use the alert() method to show a
        dialog at certain points in the code. The alert() method allows us to
        effectively put breakpoints in the code that let us check the value of
        variables at that point to see if they’re what we expect them to be.
      </p>
      <u>The console.log() method:</u>
      <pre>
  function amIOldEnough(age){
    if (age &#60; 12) {
        alert(age);
        return 'No, sorry.';
    } else if (age &#60; 18) {
        return 'Only if you are accompanied by an adult.';
    }
    else {
        return 'Yep, come on in!';
    }
  }
      </pre>
      <u>Debugger Command</u>
      <p>
        One of the most useful commands is the debugger keyword. This will
        create a breakpoint in your code that will pause the execution of the
        code and allow you to see where the program is currently up to. Just
        remember to remove any references to the debugger command before
        shipping any code.
      </p>
      <pre>
  function amIOldEnough(age){
    debugger;
        if (age &#60; 12) {
          debugger;
          return 'No, sorry.';
        } else if (age &#60; 18) {
          debugger;
          return 'Only if you are accompanied by an adult.';
        } else {
          debugger;
          return 'Yep, come on in!';
    }
  }
      
  amIOldEnough(16);
      </pre>
      <u>Error Objects</u>
      <p>
        An error object can be created by the host environment when an exception
        occurs, or it can be created in the code using a constructor function,
        like so:
      </p>
      <pre>
  const error = new Error();

  // This constructor function takes a parameter that’s used as the error message:
  const error = new Error('Oops, something went wrong');
      </pre>
      <p>
        There are seven more error objects that are used for specific errors:
      </p>
      <ul>
        <li>
          <b>EvalError</b> is not used in the current ECMAScript specification
          and only retained for backwards compatibility. It was used to identify
          errors when using the global eval() function.
        </li>
        <li>
          <b>RangeError</b> is thrown when a number is outside an allowable
          range of values.
        </li>
        <li>
          <b>ReferenceError</b> is thrown when a reference is made to an item
          that doesn’t exist. For example, calling a function that hasn’t been
          defined.
        </li>
        <li>
          <b>SyntaxError</b> is thrown when there’s an error in the code’s
          syntax.
        </li>
        <li>
          <b>TypeError</b> is thrown when there’s an error in the type of value
          used; for example, a string is used when a number is expected.
        </li>
        <li>
          <b>URIError</b> is thrown when there’s a problem encoding or decoding
          the URI.
        </li>
        <li>
          <b>InternalError</b> is a non-standard error that is thrown when an
          error occurs in the JavaScript engine. A common cause of this is too
          much recursion.
        </li>
      </ul>
      <p>
        These error objects can also be used as constructors to create custom
        error objects:
      </p>
      <pre>
  const error = new TypeError('You need to use numbers in this function');
      </pre>
      <p>
        All error objects have a number of properties, but they’re often used
        inconsistently across browsers. The only properties that are generally
        safe to use are:
      </p>
      <ul>
        <li>
          The name property returns the name of the error constructor function
          used as a string, such as “Error” or “ReferenceError”.
        </li>
        <li>
          The message property returns a description of the error and should be
          provided as an argument to the Error constructor function.
        </li>
        <li>
          The stack property will return a stack trace for that error. This is a
          nonstandard property and it’s recommended that it is not safe to use
          in production sites.
        </li>
      </ul>
      <u>try, catch, and finally</u>
      <p>
        If we suspect a piece of code will result in an exception, we can wrap
        it in a try block. This will run the code inside the block as normal,
        but if an exception occurs it will pass the error object that is thrown
        onto a catch block. Here’s a simple example using our squareRoot()
        function from earlier:
      </p>
      <pre>
  function imaginarySquareRoot(number) {
    'use strict';
    try {
        return String(squareRoot(number));
    } catch(error) {
        return squareRoot(-number)+'i';
    }
  }

  // If we suspect a piece of code will result in an exception, we can wrap it
  // in a try block.
  imaginarySquareRoot(-49) // no error message shown
  &#60;&#60; '7i'

  // A finally block can be added after a catch block. This will always be
  // executed after the try or catch block, regardless of whether an exception
  // occurred or not.
  function imaginarySquareRoot(number) {
    'use strict';
    let answer;
    try {
        answer = String(squareRoot(number));
    } catch(error) {
        answer = squareRoot(-number)+"i";
    } finally {
        return `+ or - ${answer}`;
    }
  }
      </pre>
      <u>Tests</u>
      <p>
        Testing is an important part of programming that can often be
        overlooked. A test can simply be a function that tests a piece of code
        runs as it should.
      </p>
      <pre>
  function itSquareRoots4() {
    return squareRoot(4) === 2;
  }
      </pre>
      <p>
        Here we’re comparing the result of squareRoot(4) with the number 2. This
        will return true if our function works as expected, which it does:
      </p>
      <pre>
  itSquareRoots4();
  &#60;&#60; true
      </pre>
      <u>Test-driven development(TDD)</u>
      <p>
        TDD is the process of writing tests before any actual code. Obviously
        these tests will initially fail, because there is no code to test. The
        next step is to write some code to make the tests pass. The code is
        continually tested at each stage to make sure it continues to work. This
        process should be followed in small piecemeal chunks every time a new
        feature is implemented, resulting in the following workflow. This is
        often referred to as the “red-green-refactor” cycle of TDD, as failing
        tests 368 JavaScript: Novice to Ninja, 2nd Edition usually show up as
        red, and tests that pass show as green.
      </p>
      <ul>
        <li>Write tests (that initially fail)</li>
        <li>Write code to pass the tests</li>
        <li>Refactor the code</li>
        <li>Test refactored code</li>
        <li>Write more tests for new features</li>
      </ul>
      <u>Jest</u>
      <p>
        Jest is a TDD framework that was created by Facebook and has gained a
        lot of popularity. Before you can use jest, you need to install it. You
        can do this by typing the following command in the terminal:
      </p>
      <pre>
  npm install -g jest
      </pre>
      <p>
        Jest should be installed globally now. You can check to see what version
        is installed by typing the following command:
      </p>
      <pre>
  jest -v
  &#60;&#60; v19.0.2
      </pre>
      <p>Here is the squareRoot() function fro earlier:</p>
      <pre>
  function squareRoot(number) {
    'use strict';
    if (number &#60; 0) {
      throw new RangeError("You can't find the square root of negative numbers")
    }
    return Math.sqrt(number);
  };
  
    test('square root of 4 is 2', () => {
    expect(squareRoot(4)).toBe(2);
  });
      </pre>
      <p>
        To run this test, simply navigate to the folder that contains the file
        squareRoot.test.js and enter the following command:
      </p>
      <pre>
  jest -c {}

  // If everything is working okay, it should produce the following output:
  &#60;&#60; PASS  ./squareRoot.test.js
  ✓ square root of 4 is 2 (2ms)

  Test Suites: 1 passed, 1 total
  Tests:       1 passed, 1 total
  Snapshots:   0 total
  Time:        2.996s
      </pre>
      <u>Crunching Some Numbers</u>
      <p>
        To demonstrate the TDD process, we’ll have a go at creating a small
        library called “Number Cruncher” that will contain some functions that
        operate on numbers. The first function we’ll try to implement will be
        called factorsOf(). This will take a number as a parameter and return
        all the factors12 of that number as an array. Since we’re doing TDD, we
        need to start by writing the tests first, so create a file called
        numberCruncher.test.js and add the following code. We have used the
        toEqual() match in this test. This is because we are testing an array.
      </p>
        <pre>
    test('factors of 12', () => {
      expect(factorsOf(12)).toEqual([1,2,3,4,6,12]);
    });

    // This test says our factorsOf() function should return an array containing
    // all the factors of 12 in order, when 12 is provided as an argument. If we
    // run this test, we can see that it fails spectacularly:
    jest -c {}
    &#60;&#60; FAIL  ./numberCruncher.test.js
    ● factors of 12

       ReferenceError: factorsOf is not defined

       at Object.<anonymous>.test (numberCruncher.test.js:2:10)
       at process._tickCallback (internal/process/next_tick.js:103:7)

    ✕ factors of 12 (6ms)

    Test Suites: 1 failed, 1 total
    Tests:       1 failed, 1 total
    Snapshots:   0 total
    Time:        1.424s
        </pre>
        <p>
          Well, what did you expect? We haven’t written any code yet! Let’s have
          a go at writing the factorsOf() function. Add the following to the top
          of the numberCruncher.test.js file:
        </p>
        <pre>
  'use strict';

  function factorsOf(n) {
    const factors = [];
      for (let i=1; i &#60; n ; i++) {
        if (n/i === Math.floor(n/i)){
          factors.push(i);
        }
      }
    return factors;
  }

  // Run the test again 
  jest -c {}
  &#60;&#60; FAIL ./numberCruncher.test.js
  ● factors of 12

      expect(received).toBe(expected)

      Expected value to be (using ===):
      [1, 2, 3, 4, 6, 12]
      Received:
      [1, 2, 3, 4, 6]

      Difference:

      - Expected
      + Received

      @@ -2,7 +2,6 @@
      1,
      2,
      3,
      4,
      6,
      - 12,
      ]

      at Object.<anonymous>.test (numberCruncher.test.js:14:25)
      at process._tickCallback (internal/process/next_tick.js:103:7)

  ✕ factors of 12 (12ms)
  Test Suites: 1 failed, 1 total
  Tests: 1 failed, 1 total
  Snapshots: 0 total
  Time: 0.801s, estimated 1s
  Ran all test suites.
        </pre>
        <p>
          It still failed. This time, the failure message is a bit more
          specific. It says it was expecting the array [1,2,3,4,6,12] but
          received the array [1,2,3,4,6]― the last number 12 is missing. Looking
          at our code, this is because the loop only continues while i &#60; n.
          We need i to go all the way up to and including n, requiring just a
          small tweak to our code:
        </p>
        <pre>
  function factorsOf(n) {
    const factors = [];
    for (let i=1 , max = Math.sqrt(n); i &#60;= max ; i++) {
      if (n%i === 0){
        factors.push(i,n/i);
      }
    }
    return factors.sort((a,b) => a - b);
  }
        </pre>
        <p>
          Now run the test again to confirm it still passes:
        </p>
        <pre>
  jest -c {}
  &#60;&#60; PASS  ./numberCruncher.test.js
  ✓ factors of 12 (8ms)

  Test Suites: 1 passed, 1 total
  Tests:       1 passed, 1 total
  Snapshots:   0 total
  Time:        1.615s
  Ran all test suites.
        </pre>
        <p>
          Now our tests are passing, and our code has been refactored, it’s time
          to add some more functionality. Let’s write another function called
          isPrime() that will return true if a number is prime and false if it
          isn’t. Let’s start by writing a couple of new tests for this at the
          end of numberCruncher.test.js:
        </p>
        <pre>
  test('2 is prime', () => {
    expect(isPrime(2)).toBe(true);
  });
  
  test('10 is not prime', () => {
    expect(isPrime(10)).not.toBe(true);
  });
        </pre>
        <p>
          The first test checks whether true is returned when a prime number (2)
          is provided as an argument, and another to check that true is not
          returned if a nonprime number (10) is given as an argument. These
          tests use the toBe() matcher to check if the result is true. Note the
          nice use of negation using the not matcher (although we should
          probably be checking if it’s false because this test will pass if
          anything but true is returned). If you run the tests again, you’ll see
          that our new tests are failing, and our factors test is still passing:
        </p>
        <pre>
  jest -c {}
  &#60;&#60; FAIL  ./numberCruncher.test.js
  ● 2 is prime

     ReferenceError: isPrime is not defined

     at Object.<anonymous>.test (numberCruncher.test.js:18:10)
     at process._tickCallback (internal/process/next_tick.js:103:7)

  ● 10 is not prime

     ReferenceError: isPrime is not defined

     at Object.<anonymous>.test (numberCruncher.test.js:22:10)
     at process._tickCallback (internal/process/next_tick.js:103:7)

  ✓ factors of 12 (4ms)
  ✕ 2 is prime (1ms)
  ✕ 10 is not prime (1ms)

  Test Suites: 1 failed, 1 total
  Tests:       2 failed, 1 passed, 3 total
  Snapshots:   0 total
  Time:        0.812s, estimated 1s
  Ran all test suites.
        </pre>
        <p>
          This is to be expected, since we’re yet to write any code for them.
          We’d better write the isPrime() function. This will use the
          factorsOf() function and check to see if the number of factors in the
          array returned by the factorsOf() function is 2. This is because all
          prime numbers have precisely two factors. Add the following code to
          the bottom of the numberCruncher.test.js file:
        </p>
        <pre>
  function isPrime(n) {
    return factorsOf(n).length === 2;
  }

  // If we run the tests again, we can see that all three of our
  // tests have passed
  jest -c {}
  &#60;&#60; PASS  ./numberCruncher.test.js
  ✓ factors of 12 (6ms)
  ✓ 2 is prime (1ms)
  ✓ 10 is not prime (1ms)

  Test Suites: 1 passed, 1 total
  Tests:       3 passed, 3 total
  Snapshots:   0 total
  Time:        2.853s
  Ran all test suites.
        </pre>
        <p>
          Our library of functions is growing! The next step is to again
          refactor our code. It’s a bit brittle at the moment, because both
          functions accept negative and non-integer values, neither of which
          are prime. They also allow non-numerical arguments to be provided. It
          turns out that the factorsOf() function fails silently and returns an
          empty array if any of these are passed to it. It would be better to
          throw an exception to indicate that an incorrect argument has been
          used. Let’s create some tests to check that this happens. Add the
          following tests to the numberCruncher.test.jsfile:
        </p>
        <pre>
  it('should throw an exception for non-numerical data', () => {
      expect(factorsOf('twelve').toThrow();
  });
  
  it('should throw an exception for negative numbers', () => {
      expect(() => factorsOf(-2)).toThrow();
  });
  
  it('should throw an exception for non-integer numbers', () => {
      expect(() => factorsOf(3.14159)).toThrow();
  });
        </pre>
        <p>
          These tests all use the toThrow() method to check that an exception
          has been thrown if the wrong data is entered as an argument. While
          we’re at it, we can add some extra tests so the isPrime() function
          also deals with any incorrect arguments. No exceptions are necessary
          in these cases; non-numerical data, negative numbers and non-integers
          are simply not prime, so the function should just return false. Add
          the following code to the bottom of the numberCruncher.test.js file:
        </p>
        <pre>
  test('non-numerical data returns not prime', () => {
    expect(isPrime('two')).toBe(false);
  });
  
  test('non-integer numbers return not prime', () => {
    expect(isPrime(1.2)).toBe(false);
  });
  
  test('negative numbers return not prime', () => {
    expect(isPrime(-1)).toBe(false);
  });
        </pre>
        <p>
          If you run the tests again, you’ll see that the new tests for the
          factorsOf() function fail as expected, but the new tests for the
          isPrime() function actually pass. This is a happy accident because
          the factorsOf() function is returning an empty array, which is
          conveniently not of length 2, so false is returned by the function
          anyway. Let’s try and make all the tests pass by throwing some
          exceptions in the factorsOf() function. Change the factorsOf()
          function to the following in numberCruncher.test.js:
        </p>
        <pre>
  function factorsOf(n) {
    if(Number.isNaN(Number(n))) {
      throw new RangeError('Argument Error: Value must be an integer');
    }
    if(n &#60; 0) {
      throw new RangeError('Argument Error: Number must be positive');
    }
    if(!Number.isInteger(n)) {
      throw new RangeError('Argument Error: Number must be an integer');
    }
    const factors = [];
    for (let i=1 , max = Math.sqrt(n); i &#60;= max ; i++) {
      if (n%i === 0){
        factors.push(i,n/i);
      }
    }
    return factors.sort((a,b) => a - b);
  }
        </pre>
        <p>
          Now the function checks to see if a negative number or non-integer
          has been provided as an argument, and throws an exception in both
          cases. Let’s run our tests again:
        </p>
        <pre>
  jest -c{}
  &#60;&#60; FAIL  ./numberCruncher.test.js
  ● non-numerical data returns not prime

      RangeError: Argument Error: Value must be an integer

      at factorsOf (numberCruncher.test.js:5:11)
      at isPrime (numberCruncher.test.js:23:10)
      at Object.<anonymous>.test (numberCruncher.test.js:57:10)

  ● non-integer numbers return not prime

      RangeError: Argument Error: Number must be an integer

      at factorsOf (numberCruncher.test.js:11:11)
      at isPrime (numberCruncher.test.js:23:10)
      at Object.<anonymous>.test (numberCruncher.test.js:61:10)

  ● negative numbers return not prime

      RangeError: Argument Error: Number must be positive

      at factorsOf (numberCruncher.test.js:8:11)
      at isPrime (numberCruncher.test.js:23:10)
      at Object.<anonymous>.test (numberCruncher.test.js:65:10)

  ✓ Returns factors of 12 (4ms)
  ✓ 2 is prime (1ms)
  ✓ 10 is not prime
  ✓ Exception for non-numerical data
  ✓ Exception for negative numbers (1ms)
  ✓ Exception for non-integer numbers
  ✕ Non-numerical data returns not prime (2ms)
  ✕ Non-integer numbers return not prime
  ✕ Negative numbers return not prime (1ms)

  Test Suites: 1 failed, 1 total
  Tests:       3 failed, 6 passed, 9 total
  Snapshots:   0 total
  Time:        3.516s
  Ran all test suites.
        </pre>
        <p>
          Oh, no! Our tests for the factorsOf() function all pass... but the
          exceptions have caused the isPrime() function to choke and fail the
          tests. We need to add code that handles any exceptions that might be
          thrown when the factorsOf() function is called from within the
          isPrime() function. This sounds like a job for a try and catch block!
          Change the isPrime() function in the numberCruncher.test.js file to
          the following:
        </p>
        <pre>
  function isPrime(n) {
    try {
      return factorsOf(n).length === 2;
    } catch (error) {
      return false;
    }
  }
        </pre>
        <p>
          Now we’ve placed the original code inside a try block, so if
          factorsOf() throws an exception, we can pass it on to the catch block
          and handle the error. All we have to do here is simply return false if
          an error is thrown. Now we’ll run our tests again, and hopefully
          you’ll see the following message:
        </p>
        <pre>
  jest -c{}
  &#60;&#60; PASS  ./numberCruncher.test.js
  ✓ Returns factors of 12 (4ms)
  ✓ 2 is prime (1ms)
  ✓ 10 is not prime
  ✓ Exception for non-numerical data (1ms)
  ✓ Exception for negative numbers
  ✓ Exception for non-integer numbers (1ms)
  ✓ Non-numerical data returns not prime
  ✓ Non-integer numbers return not prime (1ms)
  ✓ Negative numbers return not prime

  Test Suites: 1 passed, 1 total
  Tests:       9 passed, 9 total
  Snapshots:   0 total
  Time:        2.381s
  Ran all test suites.
        </pre>
        <u>Questions</u>
        <P>
          1) I wonder how many people that create web pages and use JavaScript use these types of tests to make sure things could/would work? At this stage of my programming HTML  I am not 100% sure I would. I understand the benefit but for one thing, it seems like a lot of work before you even get started with programming your site. Only time will tell.
        </P>
        <p>
          2) I wonder if BYU-I will implement more little programs as well as all the reading? I am not one that does well with reading and applying what I learned because there are not enough examples to really play with.
        </p>
    </main>

    <!-- FOOTER HERE -->
    <footer id="footerWrapper">
      <p>
        &copy;2021 | Jesse Wilson | Cardston, AB | WDD 330: Frontend Web
        Development II
      </p>
    </footer>
  </body>
</html>
