<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta
      name="description"
      content="Notes for week 7 from JavaScript: Novice To Ninja, 2nd Edition."
    />
    <meta name="author" content="Jesse Wilson" />

    <!-- SITE TITLE -->
    <title>Week 7 Notes & Codes</title>

    <!-- TELLS PHONES NOT TO LIE ABOUT THEIR WIDTH & stops the font from
      enlarging when a phone is turned sideways-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- STYLE SHEETS -->
    <link href="css/normalize.css" rel="stylesheet" />
    <!-- phone-default -->
    <link href="css/small.css" rel="stylesheet" />
    <!-- enhance-tablet -->
    <link href="css/medium.css" rel="stylesheet" />
    <!-- enhance-desktop -->
    <link href="css/large.css" rel="stylesheet" />

    <!-- JAVASCRIPTS-->
    <script defer src="js/styles.js"></script>
  </head>
  <body>
    <!-- HEADER HERE -->
    <header id="headerWrapper">
      <h1>Week 7 Notes & Codes</h1>
    </header>

    <!-- NAVIGATION HERE -->
    <nav></nav>

    <!-- CONTENT HERE -->
    <main>
      <h1>Errors, Exceptions, and Warnings</h1>
      <u>Function Properties and Methods</u>
      <p>
        Functions are first-class objects that can have properties and methods
        themselves.
      </p>
      <pre>
  <b>function square(x) {
    return x*x;
  }</b>

  // We can query the length property and see that is accepts one parameter.
  <b>square.length</b> 
  << 1
      </pre>
      <u>Call and Apply Methods</u>
      <p>
        The call() method can be used to set the value of
        <b><i>this</i></b> inside a function to an object that is provided as
        the first argument. Below is an example of the sayHello() function which
        refers to an unspecific object called <b><i>this</i></b> that has a
        property called name:
      </p>
      <pre>
  <b>function sayHello(){
    return `Hello, my name is ${ <i>this</i>.name }`;
  }</b>
      </pre>
      <p>
        Multiple objects can have the same property (ex name) and use the call()
        method to invoke the sayHello() function providing each object as an
        argument. This will then take the value of <b><i>this</i></b> in the
        function:
      </p>
      <pre>
  <b>const clark = { name: 'Clark' };
  const bruce = { name: 'Bruce' };</b>

  <b>sayHello.call(clark);</b>
  << 'Hello, my name is Clarke'

  <b>sayHello.call(bruce);</b>
  << 'Hello, my name is Bruce'
      </pre>
      <p>
        Now if we were to update the sayHello() function to give a more
        generalized greeting that is provided as an argument. If we call a
        functoin that requires any parameters we need to provide those as an
        argument, which is always the value of <b><i>this</i></b
        >. This is how it could look like if we updated the sayHello() function
        that is provided as an argument.
      </p>
      <pre>
  <b>function sayHello(greeting='Hello'){ // Greetings is a default argument
    return `${ greeting }, my name is ${ <i>this</i>.name }`;
  }</b>
  
  <b>sayHello.call(clark, 'How do you do');</b>
  << 'How do you do, my name is Clark'

  sayHello.call(bruce);
  << 'Hello, my name is Bruce'
      </pre>
      <p>
        Function can sill be called using the call method even if it does not
        refer to an object as the <b><i>this</i></b> in its body. We will use
        the square function from above. Because <b><i>this</i></b> is not in its
        body, we need to make the first argument null.
      </p>
      <pre>
<b>square.call(null, 4)</b>
<< 16
      </pre>
      <p>
        The apply() method works in the same way, except the arguments of the
        function are provided as an array, even if there is only one argument:
      </p>
      <pre>
<b>square.apply(null, [4])</b>
<< 16
      </pre>
      <u>Custom Properties</u>
      <p>
        We can add our own properties to functions the same way we add
        properties to any object in JS. Here we will add the description
        property to a function that describes what it does.
      </p>
      <pre>
  <b>square.description = 'Squares a number that is provided as an argument'</b>
  << 'Squares a number that is provided as an argument'
      </pre>
      <u>Memoization</u>
      <p>
        If it takes some time for a function to return a value, the value can be
        saved as a cache property that can be used again later. For example, say
        squaring a number was an expensive computational operation that took a
        long time. Here is the square() function rewritten to show how this
        would look.
      </p>
      <pre>
  <b>function square(x) {
    square.cache = square.cache || {};
    if (!square.cache[x]) {
      square.cache[x] = x * x;
    }
    return square.cache[x];
  }</b>
      </pre>
      <p>
        If we call the function we will see that the cache object stores the
        results.
      </p>
      <pre>
  <b>square(3);</b>
  << 9

  <b>square(-11);</b>
  << 121

  <b>square.cache;</b>
  << {"3": 9, "-11": 121}
      </pre>
      <u>Immediately Invoked Function Expressions</u>
      <p>
        An Immediately Invoked Function Expression – or IIFE (pronounced “iffy”)
        – is an anonymous function that, as the name suggests, is invoked as
        soon as it’s defined. To achieve this,
        <b
          ><span style="color: red"
            >parentheses placed at the end of the function definition</span
          ></b
        >. The function also has to be made into an expression, which is done by
        placing the whole declaration inside parentheses IIFEs are a useful way
        of performing a task while keeping any variables wrapped within the
        scope of the function which. This means the global namespace is not
        polluted with lots of variable names.
      </p>
      <pre>
  <b>(function () {
    const temp = "World";
    console.log(`Hello ${temp}`);
  })<span style="color:red">()</span>;</b>

  << 'Hello World'
      </pre>
      <u>Temporary Variables</u>
      <p>
        The book says there is no way to remove a variable from a scope once it
        has been declared.A variable that is only purpose is Temporarily may
        cause problems.
      </p>
      <ul>
        <li>Cause confussion if it is still available later in the code</li>
        <li>
          The variable name may clash with another piece of code (an external
          JavaScript library)
        </li>
      </ul>
      <p>
        Placing any code that uses the temporary variable inside an IIFE will
        ensure it’s only available while the IIFE is invoked, then it will
        disappear. The following example uses a IIFE to swap the value of two
        global variables (a & b). Temp is a temporary variable that only exists
        while the IIFE is invoked.
      </p>
      <pre>
  <b>let a = 1;
    let b = 2;
    
  (() => {
    const temp = a;
    a = b;
    b = temp;
  })();</b>

  <b>a;</b>
  << 2

  <b>b;</b>
  << 1

  // Temp does not exist after the function has been invoked
  <b>console.log(temp);</b>
  << Error: "temp is not defined" 
      </pre>
      <p>
        You do not need to swap two variable in ES6 if you use destructuring.
      </p>
      <pre>
  <b>let [a,b] = [1,2];
    [a,b] = [b,a];</b>

  <b>a;</b>
  << 2

  <b>b;</b>
  << 1
      </pre>
      <u>Initialization Code</u>
      <p>
        An IIFE can be used to set up an Initialization code that you will not
        need again. The code is only used one so there is not need to create any
        reusable, named functions and all the variables will also be temporary.
        An IIFE will be invoked once, and can set up any variables, objects and
        event handlers when the page loads.
      </p>
      <pre>
  <b>(function () {
    const name = "Peter Parker"; // This might be obtained from a cookie in reality
    const days = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ];
    const date = new Date(),
      today = days[date.getDay()];
    console.log(`Welcome back ${name}. Today is ${today}`);
  })();</b>

        << 'Welcome back Peter Parker. Today is Tuesday'
      </pre>
      <p>This is how you would achieve the same code above in ES6.</p>
      <pre>
  <b>{
    const name = "Peter Parker"; // This might be obtained from a cookie in reality

    const days = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ];
    const date = new Date(),
      today = days[date.getDay()];

    console.log(`Welcome back ${name}. Today is ${today}`);
  }</b>

  << 'Welcome back Peter Parker. Today is Tuesday'
      </pre>
      <u>Creating Self-contained Code Blocks</u>
      <p>
        An IIFE can be used to enclose a block of code inside its own private
        scope so it doesn’t interfere with any other part of the program. Using
        IIFEs in this way means code can be added or removed separately. Below
        are two blocks of code that run independently of each other.
      </p>
      <pre>
  <b>(function () {
    // block A
    const name = "Block A";
    console.log(`Hello from ${name}`);
  })();

  (function () {
    // block B
    const name = "Block B";
    console.log(`Hello from ${name}`);
  })();
  </b>

  << Hello from Block A
  << Hello from Block B
      </pre>
      <p>
        Both code blocks include a variable called name but the modules do not
        interfere with each other. This is useful for testing purposes because
        we are separating parts of a program into discrete sections.
      </p>
      <u>Functions that Define and Rewrite Themselves</u>
      <p>
        A function is able to not only call itself but it can define itself and
        even redefine itself because of the dynamic nature of JavaScript. This
        can be done by assigning an anonymous function to a variable that has
        the same name as the function.
      </p>
      <pre>
  <b>function party() {
    console.log("Wow this is amazing!");
    party = function () {
      console.log("Been there, got the T-Shirt");
    };
  }</b>
  
  // When the function has been called once, it will be as if it was defined like this:
  <b>function party() {
    console.log("Been there, got the T-Shirt");
  }</b>

  <b>party();</b>
  << 'Wow this is amazing!'

  // After the first time, it will log the message "Been there, got the T-Shirt:
  <b>party();</b>
  << 'Been there, got the T-Shirt'

  <b>party();</b>
  << 'Been there, got the T-Shirt'
      </pre>
      <p>
        If the function is also assigned to another variable, this variable will
        maintain the original function definition and not be rewritten. This is
        because the original function is assigned to a variable, then within the
        function, a variable with the same name as the function is assigned to a
        different function.
      </p>
      <pre>
  <b>function party() {
    console.log("Wow this is amazing!");
    party = function () {
      console.log("Been there, got the T-Shirt");
    };
  }</b>

  <b>const beachParty = party;</b> // note that the party function has not been invoked

  <b>beachParty();</b> // the party() function has now been redefined, even though it hasn't been called explicitly
  << 'Wow this is amazing!'

  <b>party();</b>
  << 'Been there, got the T-Shirt'

  <b>beachParty();</b> // but this function hasn't been redefined
  << 'Wow this is amazing!'

  <b>beachParty();</b> // no matter how many times this is called it will remain the same
  << 'Wow this is amazing!'
      </pre>
      <p>
        If any properties have previously been set on the function, these will
        be lost when the function redefines itself. In the previous example, we
        can set a music property, and see that it no longer exists after the
        function has been invoked and redefined
      </p>
      <pre>
  <b>function party() {
    console.log("Wow this is amazing!");
    party = function () {
      console.log("Been there, got the T-Shirt");
    };
  }</b>

  <b>party.music = 'Classical Jazz';</b> // set a property of the function

  <b>party();</b>
  << "Wow this is amazing!"

  <b>party.music;</b> // function has now been redefined, so the property doesn't exist
  << undefined
      </pre>
      <p>
        This is called the <b>Lazy Definition Pattern</b> and is often used when
        some initialization code is required the first time it’s invoked. This
        means the initialization can be done the first time it’s called, then
        the function can be redefined to what you want it to be for every
        subsequent invocation.
      </p>
      <u>Init-Time Branching</u>
      <p>PDF_Page_416</p>
      <!-- This is where my questions are added. This is to help me know that I will be continuing my notes above this sectin. -->
      <h2>Questions:</h2>
      <p>
        When would you use the description property to describe what a function
        does? When would you see it. I thought that was why we put comments in
        our code.
      </p>
    </main>

    <!-- FOOTER HERE -->
    <footer></footer>
  </body>
</html>
