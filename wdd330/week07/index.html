<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta
      name="description"
      content="Notes for week 7 from JavaScript: Novice To Ninja, 2nd Edition."
    />
    <meta name="author" content="Jesse Wilson" />

    <!-- SITE TITLE -->
    <title>Week 7 Notes & Codes</title>

    <!-- TELLS PHONES NOT TO LIE ABOUT THEIR WIDTH & stops the font from
      enlarging when a phone is turned sideways-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- STYLE SHEETS -->
    <link href="css/normalize.css" rel="stylesheet" />
    <!-- phone-default -->
    <link href="css/small.css" rel="stylesheet" />
    <!-- enhance-tablet -->
    <link href="css/medium.css" rel="stylesheet" />
    <!-- enhance-desktop -->
    <link href="css/large.css" rel="stylesheet" />

    <!-- JAVASCRIPTS-->
    <script defer src="js/styles.js"></script>
  </head>
  <body>
    <!-- HEADER HERE -->
    <header id="headerWrapper">
      <h1>Week 7 Notes & Codes</h1>
    </header>

    <!-- NAVIGATION HERE -->
    <nav></nav>

    <!-- CONTENT HERE -->
    <main>
      <h1>Errors, Exceptions, and Warnings</h1>
      <h2>Function Properties and Methods</h2>
      <p>
        Functions are first-class objects that can have properties and methods
        themselves.
      </p>
      <pre>
  <b>function square(x) {
    return x*x;
  }</b>

  // We can query the length property and see that is accepts one parameter.
  <b>square.length</b> 
  << 1
      </pre>
      <u>Call and Apply Methods</u>
      <p>
        The call() method can be used to set the value of
        <b><i>this</i></b> inside a function to an object that is provided as
        the first argument. Below is an example of the sayHello() function which
        refers to an unspecific object called <b><i>this</i></b> that has a
        property called name:
      </p>
      <pre>
  <b>function sayHello(){
    return `Hello, my name is ${ <i>this</i>.name }`;
  }</b>
      </pre>
      <p>
        Multiple objects can have the same property (ex name) and use the call()
        method to invoke the sayHello() function providing each object as an
        argument. This will then take the value of <b><i>this</i></b> in the
        function:
      </p>
      <pre>
  <b>const clark = { name: 'Clark' };
  const bruce = { name: 'Bruce' };</b>

  <b>sayHello.call(clark);</b>
  << 'Hello, my name is Clarke'

  <b>sayHello.call(bruce);</b>
  << 'Hello, my name is Bruce'
      </pre>
      <p>
        Now if we were to update the sayHello() function to give a more
        generalized greeting that is provided as an argument. If we call a
        functoin that requires any parameters we need to provide those as an
        argument, which is always the value of <b><i>this</i></b
        >. This is how it could look like if we updated the sayHello() function
        that is provided as an argument.
      </p>
      <pre>
  <b>function sayHello(greeting='Hello'){ // Greetings is a default argument
    return `${ greeting }, my name is ${ <i>this</i>.name }`;
  }</b>
  
  <b>sayHello.call(clark, 'How do you do');</b>
  << 'How do you do, my name is Clark'

  sayHello.call(bruce);
  << 'Hello, my name is Bruce'
      </pre>
      <p>
        Function can sill be called using the call method even if it does not
        refer to an object as the <b><i>this</i></b> in its body. We will use
        the square function from above. Because <b><i>this</i></b> is not in its
        body, we need to make the first argument null.
      </p>
      <pre>
  <b>square.call(null, 4)</b>
  << 16
      </pre>
      <p>
        The apply() method works in the same way, except the arguments of the
        function are provided as an array, even if there is only one argument:
      </p>
      <pre>
  <b>square.apply(null, [4])</b>
  << 16
      </pre>
      <u>Custom Properties</u>
      <p>
        We can add our own properties to functions the same way we add
        properties to any object in JS. Here we will add the description
        property to a function that describes what it does.
      </p>
      <pre>
  <b>square.description = 'Squares a number that is provided as an argument'</b>
  << 'Squares a number that is provided as an argument'
      </pre>
      <u>Memoization</u>
      <p>
        If it takes some time for a function to return a value, the value can be
        saved as a cache property that can be used again later. For example, say
        squaring a number was an expensive computational operation that took a
        long time. Here is the square() function rewritten to show how this
        would look.
      </p>
      <pre>
  <b>function square(x) {
    square.cache = square.cache || {};
    if (!square.cache[x]) {
      square.cache[x] = x * x;
    }
    return square.cache[x];
  }</b>
      </pre>
      <p>
        If we call the function we will see that the cache object stores the
        results.
      </p>
      <pre>
  <b>square(3);</b>
  << 9

  <b>square(-11);</b>
  << 121

  <b>square.cache;</b>
  << {"3": 9, "-11": 121}
      </pre>
      <h2>Immediately Invoked Function Expressions</h2>
      <p>
        An Immediately Invoked Function Expression – or IIFE (pronounced “iffy”)
        – is an anonymous function that, as the name suggests, is invoked as
        soon as it’s defined. To achieve this,
        <b
          ><span style="color: red"
            >parentheses placed at the end of the function definition</span
          ></b
        >. The function also has to be made into an expression, which is done by
        placing the whole declaration inside parentheses IIFEs are a useful way
        of performing a task while keeping any variables wrapped within the
        scope of the function which. This means the global namespace is not
        polluted with lots of variable names.
      </p>
      <pre>
  <b>(function () {
    const temp = "World";
    console.log(`Hello ${temp}`);
  })<span style="color:red">()</span>;</b>

  << 'Hello World'
      </pre>
      <u>Temporary Variables</u>
      <p>
        The book says there is no way to remove a variable from a scope once it
        has been declared.A variable that is only purpose is Temporarily may
        cause problems.
      </p>
      <ul>
        <li>Cause confussion if it is still available later in the code</li>
        <li>
          The variable name may clash with another piece of code (an external
          JavaScript library)
        </li>
      </ul>
      <p>
        Placing any code that uses the temporary variable inside an IIFE will
        ensure it’s only available while the IIFE is invoked, then it will
        disappear. The following example uses a IIFE to swap the value of two
        global variables (a & b). Temp is a temporary variable that only exists
        while the IIFE is invoked.
      </p>
      <pre>
  <b>let a = 1;
    let b = 2;
    
  (() => {
    const temp = a;
    a = b;
    b = temp;
  })();</b>

  <b>a;</b>
  << 2

  <b>b;</b>
  << 1

  // Temp does not exist after the function has been invoked
  <b>console.log(temp);</b>
  << Error: "temp is not defined" 
      </pre>
      <p>
        You do not need to swap two variable in ES6 if you use destructuring.
      </p>
      <pre>
  <b>let [a,b] = [1,2];
    [a,b] = [b,a];</b>

  <b>a;</b>
  << 2

  <b>b;</b>
  << 1
      </pre>
      <u>Initialization Code</u>
      <p>
        An IIFE can be used to set up an Initialization code that you will not
        need again. The code is only used one so there is not need to create any
        reusable, named functions and all the variables will also be temporary.
        An IIFE will be invoked once, and can set up any variables, objects and
        event handlers when the page loads.
      </p>
      <pre>
  <b>(function () {
    const name = "Peter Parker"; // This might be obtained from a cookie in reality
    const days = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ];
    const date = new Date(),
      today = days[date.getDay()];
    console.log(`Welcome back ${name}. Today is ${today}`);
  })();</b>

  << 'Welcome back Peter Parker. Today is Tuesday'
      </pre>
      <p>This is how you would achieve the same code above in ES6.</p>
      <pre>
  <b>{
    const name = "Peter Parker"; // This might be obtained from a cookie in reality

    const days = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ];
    const date = new Date(),
      today = days[date.getDay()];

    console.log(`Welcome back ${name}. Today is ${today}`);
  }</b>

  << 'Welcome back Peter Parker. Today is Tuesday'
      </pre>
      <u>Creating Self-contained Code Blocks</u>
      <p>
        An IIFE can be used to enclose a block of code inside its own private
        scope so it doesn’t interfere with any other part of the program. Using
        IIFEs in this way means code can be added or removed separately. Below
        are two blocks of code that run independently of each other.
      </p>
      <pre>
  <b>(function () {
    // block A
    const name = "Block A";
    console.log(`Hello from ${name}`);
  })();

  (function () {
    // block B
    const name = "Block B";
    console.log(`Hello from ${name}`);
  })();
  </b>

  << Hello from Block A
  << Hello from Block B
      </pre>
      <p>
        Both code blocks include a variable called name but the modules do not
        interfere with each other. This is useful for testing purposes because
        we are separating parts of a program into discrete sections.
      </p>
      <h2>Functions that Define and Rewrite Themselves</h2>
      <p>
        A function is able to not only call itself but it can define itself and
        even redefine itself because of the dynamic nature of JavaScript. This
        can be done by assigning an anonymous function to a variable that has
        the same name as the function.
      </p>
      <pre>
  <b>function party() {
    console.log("Wow this is amazing!");
    party = function () {
      console.log("Been there, got the T-Shirt");
    };
  }</b>
  
  // When the function has been called once, it will be as if it was defined like this:
  <b>function party() {
    console.log("Been there, got the T-Shirt");
  }</b>

  <b>party();</b>
  << 'Wow this is amazing!'

  // After the first time, it will log the message "Been there, got the T-Shirt:
  <b>party();</b>
  << 'Been there, got the T-Shirt'

  <b>party();</b>
  << 'Been there, got the T-Shirt'
      </pre>
      <p>
        If the function is also assigned to another variable, this variable will
        maintain the original function definition and not be rewritten. This is
        because the original function is assigned to a variable, then within the
        function, a variable with the same name as the function is assigned to a
        different function.
      </p>
      <pre>
  <b>function party() {
    console.log("Wow this is amazing!");
    party = function () {
      console.log("Been there, got the T-Shirt");
    };
  }</b>

  <b>const beachParty = party;</b> // note that the party function has not been invoked

  <b>beachParty();</b> // the party() function has now been redefined, even though it hasn't been called explicitly
  << 'Wow this is amazing!'

  <b>party();</b>
  << 'Been there, got the T-Shirt'

  <b>beachParty();</b> // but this function hasn't been redefined
  << 'Wow this is amazing!'

  <b>beachParty();</b> // no matter how many times this is called it will remain the same
  << 'Wow this is amazing!'
      </pre>
      <p>
        If any properties have previously been set on the function, these will
        be lost when the function redefines itself. In the previous example, we
        can set a music property, and see that it no longer exists after the
        function has been invoked and redefined
      </p>
      <pre>
  <b>function party() {
    console.log("Wow this is amazing!");
    party = function () {
      console.log("Been there, got the T-Shirt");
    };
  }</b>

  <b>party.music = 'Classical Jazz';</b> // set a property of the function

  <b>party();</b>
  << "Wow this is amazing!"

  <b>party.music;</b> // function has now been redefined, so the property doesn't exist
  << undefined
      </pre>
      <p>
        This is called the <b>Lazy Definition Pattern</b> and is often used when
        some initialization code is required the first time it’s invoked. This
        means the initialization can be done the first time it’s called, then
        the function can be redefined to what you want it to be for every
        subsequent invocation.
      </p>
      <u>Init-Time Branching</u>
      <p>
        This technique can be used with the feature detection to create
        functions that rewrite themselves, known as init-time branching. This
        enables the functions to work more effectively in the browser, and avoid
        checking for features every time they’re invoked. Using the fictional
        unicorn object that is not supported by all browsers. This is how you
        would write your code to support different versions of a browser.
      </p>
      <pre>
  <b>function ride() {
    if (window.unicorn) {
      ride = function () {
        // some code that uses the brand new and sparkly unicorn methods
        return "Riding on a unicorn is the best!";
      };
    } else {
      ride = function () {
        // some code that uses the older pony methods
        return "Riding on a pony is still pretty good";
      };
    }
    return ride();
  }</b>
      </pre>
      <p>
        If the browser supports the unicorn object, the code will run the code
        for the unicorn object. If it does not support the unicorn object it
        will run the code it does support. One thing to be aware of is that the
        function is invoked twice the first time, although it becomes more
        efficient each subsequent time it’s invoked.
      </p>
      <pre>
  <b>ride();</b> // the function rewrites itself, then calls itself
  << 'Riding on a pony is still pretty good'

  // The function is rewritten based on the browser's capabilities. We can check this by inspecting the function without invoking it.
  ride
  << function ride() {
  <<   return 'Riding on a pony is still pretty good';
  << }
      </pre>
      <h2>Recursive Functions</h2>
      <p>
        A recursive function is one that invokes itself until a certain
        condition is met. It’s a useful tool to use when iterative processes are
        involved. A common example is a function that calculates the factorial
        of a number. This function will return 1 if 0 is provided as an argument
        (0 factorial is 1), otherwise it will multiply the argument by the
        result of invoking itself with an argument of one less. The function
        will continue to invoke itself until finally the argument is 0 and 1 is
        returned. This will result in a multiplication of 1, 2, 3 and all the
        numbers up to the original argument.
      </p>
      <pre>
  <b>function factorial(n) {
    if (n === 0) {
      return 1;
    } else {
      return n * factorial(n - 1);
    }
  }</b>
      </pre>
      <p>
        Another example from the world of mathematics is the Collatz
        Conjecture.2 This is a problem that is simple to state, but, so far, has
        not been solved. It involves taking any positive integer and following
        these rules:
      </p>
      <ul>
        <li>If the number is even, divide it by two</li>
        <li>If the number is odd, multiply it by three and add one</li>
      </ul>
      <p>If the number is odd, multiply it by three and add one:</p>
      <p>
        18, 9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4,
        2, 1, 4, 2, 1, ...
      </p>
      <p>
        As you can see, the sequence becomes stuck in a loop at the end, cycling
        through “4,2,1”. The Collatz Conjecture states that every positive
        integer will create a sequence that finishes in this loop. This has been
        verified for all numbers up to 5 × 2<sup>6<sub>o</sub></sup
        >, but there is no proof it will continue to be true for all the
        integers higher than this. To test the conjecture, we can write a
        function that uses recursion to keep invoking the function until it
        reaches a value of 1 (because we want our function to avoid being stuck
        in a recursive loop at the end!):
      </p>
      <pre>
        <b>function collatz(n, sequence = [n]) {
          if (n === 1) {
            return `Sequence took ${sequence.length} steps. It was ${sequence}`;
          }
          if (n % 2 === 0) {
            n = n / 2;
          } else {
            n = 3 * n + 1;
          }
          return collatz(n, [...sequence, n]);
        }</b>
      </pre>
      <p>
        This function takes a number as a parameter, as well as another
        parameter called sequence, which has a default value of an array
        containing the first parameter. The second parameter is only used when
        the function calls itself recursively. The first thing the function does
        is tests to see if n has a value of 1. If it does, the function returns
        a message to say how many steps it took. If it hasn’t reached 1, it
        checks if the value of n is even (in which case it divides it by 2), or
        odd, in which case it multiplies by 3 and then adds 1. The function then
        calls itself, providing the new value of n and the new sequence as
        arguments. The new sequence is constructed by placing the old sequence
        and the value of n inside a new array and applying the spread operator
        to the old sequence.
      </p>
      <pre>
  <b>collatz(18);</b>

  << 'Sequence took 21 steps. It was 18,9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1'
      </pre>
      <p>
        Based on what I see in the code above, we are Forcing the function to
        stop once it gets to one and not continue in a loop.
      </p>
      <h2>Callbacks</h2>
      <p>
        This was covered in Chapter 4 where functioned are passed to other
        functions as arguments and then invoked inside the function they are
        passed to.
      </p>
      <u>Event-driven Asynchronous Programming</u>
      <p>
        Callbacks can be used to facilitate event-driven asynchronous
        programming. JavaScript is a single-threaded environment, which means
        only one piece of code will ever be processed at a time. This may seem
        like a limitation, but nonblocking techniques can be used to ensure that
        the program continues to run. Instead of waiting for an event to occur,
        a callback can be created that’s invoked when the event happens. This
        means that the code is able to run out of order, or asynchronously.
        Events can be DOM events (click and keypress) but it can also be events
        like the completion of a file download, data returned from a database,
        or the result of a complex operation. Here’s an example of a function
        called wait() that accepts a callback.
      </p>
      <pre>
  <b>function wait(message, callback, seconds) {
    setTimeout(callback, seconds * 1000);
    console.log(message);
  }</b>

  // Callback function
  <b>function selfDestruct(){
    console.log('BOOOOM!');
  }</b>

  // Invoke the wait() function
  <b>wait("This tape will self-destruct in five seconds ... ", selfDestruct, 5);

  console.log("Hmmm, should I accept this mission or not ... ?");</b>

  << 'This tape will self-destruct in five seconds ... '
  << 'Hmmm, should I accept this mission or not ... ? '
  << 'BOOOOM!'
      </pre>
      <p>
        This demonstrates that the setTimeout() function did not block the rest
        of the program from running. If we change the value of 5 to 0 BOOOOM! is
        almost instant.
      </p>
      <u>Callback Hell</u>
      <p>
        Callback hell is the term used to refer to this tangled mess of code.
        The increase in the use of asynchronous programming in JavaScript has
        meant that more and more callbacks are being used. This can result in
        messy and confusing “spaghetti code”. This is when more than one
        callback is used in the same function, resulting in a large number of
        nested blocks that are difficult to comprehend. To illustrate this,
        let’s say we had written a game that required the following tasks to be
        completed:
      </p>
      <ul>
        <li>The user logs in and a user object is returned</li>
        <li>
          The user ID is then used to fetch player information from the server
        </li>
        <li>The game then loads based on the player information</li>
      </ul>
      <p>
        These operations are asynchronous, so they can be written as functions
        that use callbacks invoked once each task has been completed. This may
        look like the snippet below.
      </p>
      <pre>
  // uses the error-first callback style popularized by Node.js.
  // In this coding pattern, callbacks have two arguments. The first is the error
  // argument, which is an error object provided if something goes wrong when
  // completing the operation. The second argument is any data returned by the
  // operation that can be used in the body of the callback.
  <b>login(userName, function (error, user) {
    if (error) {
      throw error;
    } else {
      getPlayerInfo(user.id, function (error, info) {
        if (error) {
          throw error;
        } else {
          loadGame(info, function (error, game) {
            if (error) {
              throw error;
            } else {
              // code to run game
            }
          });
        }
      });
    }
  });</b>
      </pre>
      <p>
        You may have noticed there isn’t much actual code in the example above.
        The example only shows the flow from one function to the other, and yet
        it still manages to look extremely complicated due to the large number
        of nested if-else statements. In reality, there would be lots more code
        to implement the actual functionality of the login(), getPlayerInfo()
        and loadGame() functions.
      </p>
      <u>Promises</u>
      <p>
        A promise represents the future result of an asynchronous operation.
        Promises don’t do anything that can’t already be achieved using
        callbacks, but they help simplify the process, and avoid the convoluted
        code that can result from using multiple callbacks. When a promise is
        created, it calls an asynchronous operation and is then said to be
        pending. It remains in this state while the operation is taking place.
        At this stage, the promise is said to be unsettled. Once the operation
        has completed, the promise is said to have been settled. A settled
        promise can result in two different outcomes:
      </p>
      <ul>
        <li>
          Resolved ― the asynchronous operation was completed successfully
        </li>
        <li>
          Rejected ― the asynchronous operation didn’t work as expected, wasn’t
          successfully completed or resulted in an error
        </li>
      </ul>
      <p>
        In the book it gives an example. If shady person gave you a red pill,
        and promised that if you took it, you’d be a superhero. You swollow the
        pill and wait to see what happens. You’re currently in the pending phase
        of a promise, waiting to see what the result will be.
      </p>
      <p>
        Suddenly you find that you have the power to dodge bullets as if time
        was standing still! The promise has been resolved, and now you need to
        go off and use your newly acquired powers. But if nothing happens, you
        would reject the promise and warn people that a stranger is wandering
        around giving out red pills and peddling a fanciful story.
      </p>
      <u>Creating A Promise</u>
      <p>
        A promise is created using a constructor function. This takes a function
        called an executor as an argument. The executor initializes the promise
        and starts the asynchronous operation. It also accepts two functions as
        arguments: the resolve() function is called if the operation is
        successful, and the reject() function is called if the operation fails.
        The general layout of a promise can be seen in the code below:
      </p>
      <pre>
  <b>const promise = new Promise((resolve, reject) => {
    // initialization code goes here
    if (success) {
      resolve(value);
    } else {
      reject(error);
    }
  });</b>
      </pre>
      <p>
        Below is an example of a promise using the dice object we saw in Chapter
        5:
      </p>
      <pre>
  <b>const dice = {
    sides: 6,
    roll() {
      return Math.floor(this.sides * Math.random()) + 1;
    },
  };</b>
      </pre>
      <p>
        Now let’s create a promise that uses the dice.roll() method as the
        asynchronous operation and considers rolling a 1 as a failure, and any
        other number as a success:
      </p>
      <pre>
  <b>const promise = new Promise((resolve, reject) => {
    const n = dice.roll();
    setTimeout(() => {
      n > 1 ? resolve(n) : reject(n);
    }, n * 1000);
  });</b>
      </pre>
      <p>
        This creates a variable called promise that holds a reference to the
        promise. The promise calls the roll() method and stores the return value
        in a variable called n. Next, we use a ternary operator to specify the
        conditions for success (rolling any number higher than 1) and failure
        (rolling a 1). The setTimeout() method we met in Chapter 9 is used to
        add a short delay based on the number rolled. This is to mimic the time
        taken for an asynchronous operation to complete. Notice that both the
        resolve() and reject() functions return the value of the n variable.
        This can be used when dealing with the outcome of the promise once it’s
        been settled.
      </p>
      <u>Dealing With A Settled Promise</u>
      <p>
        The then() method can be used to deal with the outcome. This method
        accepts two arguments. The first argument is a fulfilment function that
        is called when the promise is resolved. Any data returned from the
        resolve() function will be passed along to this function. The second
        argument is a rejection function that’s called if the promise is
        rejected. In the case of our dice example, both functions will receive
        the value of the number rolled.
      </p>
      <pre>
  <b>promise.then(
    (result) => console.log(`Yes! I rolled a ${result}`),
    (result) => console.log(`Drat! ... I rolled a ${result}`)
  );</b>
        </pre>
      <p>
        The first argument is simply a function that logs a celebratory message.
        The second argument logs an annoyed message. Both states the number
        rolled. Alternatively, the catch() method can be used to specify what to
        do if the operation fails instead:
      </p>
      <pre>
  promise.catch( result => console.log(`Drat! ... I rolled a ${result}`));

  promise.then( result => console.log(`I rolled a ${result}`) )
  .catch( result => console.log(`Drat! ... I rolled a ${result}`) );
        </pre
      >
      <p>
        Here is some working code for the dice object used with the promise. It
        can be seen in the console.
      </p>
      <pre>
  <b>const dice = {
    sides: 6,
    roll() {
      return Math.floor(this.sides * Math.random()) + 1;
    },
  };
  
  console.log("Before the roll");
  
  const roll = new Promise((resolve, reject) => {
    const n = dice.roll();
    if (n > 1) {
      setTimeout(() => {
        resolve(n);
      }, n * 200);
    } else {
      setTimeout(() => reject(n), n * 200);
    }
  });
  
  roll.then((result) => console.log(`I rolled a ${result}`))
  .catch((result) => console.log(`Drat! ... I rolled a ${result}`));
  
  console.log("After the roll");</b>

  << before promise 
  << promise pending... 
  << after promise
        </pre>
      <u>Chaining Multiple Promises</u>
      <p>
        You can even chain multiple promises. Promises come into their own when
        multiple asynchronous tasks are required to be carried out one after the
        other. If each function that performs an asynchronous operation returns
        a promise, we can chain the then() methods together to form a sequential
        piece of code that’s easy to read. Each promise will only begin once the
        previous promise has been settled.
      </p>
      <pre>
  <b>login(userName)
    .then(user => getPlayerInfo(user.id))
    .then(info => loadGame(info))
    .catch( throw error)</b>
        </pre>
      <u>Async Functions</u>
      <p>
        These functions are preceded by the async keyword and allow you to write
        asynchronous code as if it was synchronous. This is achieved by using
        the await operator before an asynchronous function. This will wrap the
        return value of the function in a promise that can then be assigned to a
        variable. The next line of code is not executed until the promise is
        resolved.
      </p>
      <pre>
  <b>async function loadGame(userName) {

    try {
        const user = await login(userName);
        const info = await getPlayerInfo (user.id);
        // load the game using the returned info
    }

    catch (error){
        throw error;
    }
  }</b>
      </pre>
      <u>Generalized Functions</u>
      <p>
        Callbacks can be used to build more generalized functions. Instead of
        having lots of specific functions, one function can be written that
        accepts a callback.
      </p>
      <u>Functions That Return Functions</u>
      <p>
        Just as functions can accept another function as an argument (a
        callback), they can also return a function.
      </p>
      <pre>
  <b>function returnHello() {
    console.log("returnHello() called");
    return function () {
      console.log("Hello World!");
    };
  }

  // A messaged is logged to the console when the returnHello() function is
  // invoked and then returns another function
  returnHello()</b>
  << returnHello() called

  // To make use of the function that is returned, we need to assign it to a variable
  <b>const hello = returnHello();</b>
  << returnHello() called

  // Now we can invoke the “Hello World” function by placing parentheses after the
  // variable that it was assigned to
  <b>hello()</b>
  << Hello World!
      </pre>
      <p>
        Here is an example of using this technique to a generic "greeter"
        function that takes a particular greeting as a parameter, then returns a
        more specific greeting function:
      </p>
      <pre>
  <b>function greeter(greeting = "Hello") {
    return function () {
      console.log(greeting);
    };
  }

  const englishGreeter = greeter();  // englishGreeter is a function because it equals a function 
  englishGreeter();</b>
  << Hello

  <b>const frenchGreeter = greeter('Bonjour');
  frenchGreeter();</b>
  << Bonjour

  <b>const germanGreeter = greeter('Guten Tag');
  germanGreeter();</b>
  << Guten Tag
      </pre>
      <h2>Closures</h2>
      <p>
        Closures are one of JavaScript’s most powerful features, but they can be
        difficult to get your head around initially.
      </p>
      <u>Function Scope</u>
      <p>
        The value of a variable is only available inside the block it was
        created inside if the <b>const</b>, <b>let</b> or <b>var</b> keywords
        were used. In the following example, there are two variables: outside,
        which is available throughout the program, and inside, which is only
        available inside the function:
      </p>
      <pre>
  <b>const outside = "In the global scope";

  function fn() {
    const inside = "In the function scope";
  }</b>

  <b>outside</b>
  << 'In the global scope'

  <b>inside</b>
  << ReferenceError: inside is not defined
      </pre>
      <p>
        We cannot access the variable <b>inside</b> from outside the function.
        The variable <b>inside</b> is only kept "alive" while the function is
        active. Once the function has been invoked, any references to variables
        inside its scope are removed.
      </p>
      <p>
        It is possible to gain access to variable outside the function where it
        was created, and after the function has been invoked.
      </p>
      <p>
        A closure is a reference to a variable that was created inside the scope
        of another function, but is then kept alive and used in another part of
        the program.
      </p>
      <p>
        One of the key principles in creating closures is that an “inner”
        function, which is declared inside another function, has full access to
        all of the variables declared inside the scope of the function in which
        it’s declared (the “outer” function).
      </p>
      <pre>
  <b>function outer() {
    const outside = 'Outside!';
    function inner() {
        const inside = 'Inside!';
        console.log(outside);
        console.log(inside);
    }
    console.log(outside);
    inner();
  }

  outer()</b>
  << Outside!
  << Outside!
  << Inside!
      </pre>
      <p>
        This means that whenever a function is defined inside another function,
        the inner function will have access to any variables that are declared
        in the outer function's scope.
      </p>
      <u>Returning Functions</u>
      <p>
        As we saw in the example above, functions declared from within another
        function have access to any variables declared in the outer function’s
        scope. A closure is formed when the inner function is returned by the
        outer function, maintaining access to any variables declared inside the
        enclosing function.
      </p>
      <pre>
  <b>function outer() {
    const outside = "Outside!";
    function inner() {
      const inside = "Inside!";
      console.log(outside);
      console.log(inside);
    }
    return inner;
  }</b>

  // We can now assign a variable to the return value of the outer() function
  <b>const closure = outer();</b>
      </pre>
      <p>
        The variable closure now points to the inner() function that is returned
        by the outer() function. What makes this a closure is that it now has
        access to the variables created inside both the outer() and inner()
        functions, as we can see when we invoke it:
      </p>
      <pre>
  <b>closure();</b>
  << Outside!
  << Inside!
      </pre>
      <p>
        This is important as the variable outside should only exist while the
        outer() function is running. The closure maintains access to this
        variable, however, even though the outer() has been invoked. A closure
        doesn’t just have access to the value of a variable, it can also change
        the value of the variable long after the function in which it was
        originally declared has been invoked.
      </p>
      <u>A Practical Example</u>
      <p>
        A closure is formed when a function returns another function that then
        maintains access to any variables created in the original function’s
        scope. In the following example, two variables, a and b, are created in
        the scope of the closure() function. This then returns an anonymous
        arrow function that maintains access to the variables a and b even after
        the closure() function has been invoked:
      </p>
      <pre>
  <b>function closure() {
    const a = 1.8;
    const b = 32;
    return c => c * a + b;
  }</b>

  // Now we can create a new function by invoking the closure() function and
  // assigning the return value to a variable called toFahrenheit:
  <b>const toFahrenheit = closure();</b>

  // Now the new function can be invoked with its own argument, but the values of
  // a and b from the original function are still kept “alive”:
  <b>toFahrenheit(30);</b>
  << 86
      </pre>
      <u>A Counter Example</u>
      <p>
        Closures not only have access to variables declared in a parent
        function’s scope, they can also change the value of these variables.
        This allows us to do things like create a counter() function like the
        one in the example below:
      </p>
      <pre>
  <b>function counter(start) {
    let i = start;
    return function () {
      return i++;
    };
  }</b>
      </pre>
      <p>
        This function starts a count using the variable i. It then returns a
        function that uses a closure that traps and maintains access to the
        value of i. This function also has the ability to change the value of i,
        so it increments i by one every time it’s invoked. The reference to the
        variable i that is defined in the original function is maintained in the
        new function via a closure. We can create a counter by assigning the
        return value of the counter() function to a variable:
      </p>
      <pre>
  <b>const count = counter(1);</b>
      </pre>
      <p>
        The variable count now points to a function that has full access to the
        variable i that was created in the scope of the counter() function.
        Every time we invoke the count() function, it will return the value of i
        and then increment it by 1:
      </p>
      <pre>
  <b>count();</b>
  << 1

  <b>count();</b>
  2
      </pre>
      <u>Generators</u>
      <p>
        ES6 introduced support for generators. These are special functions used
        to produce iterators that maintain the state of a value. An asterisk
        symbol (*) is placed after the function declaration is used to define a
        generator function.
      </p>
      <pre>
  <b>function* exampleGenerator() {
    // code for the generator goes here
  }</b>
      </pre>
      <p>
        Calling a generator function doesn’t actually run any of the code in the
        function; it returns a Generator object that can be used to create an
        iterator that implements a next() method that returns a value every time
        the next() method is called. Here is an example of a generator to
        produce a Fibonacci-style number series (a sequence that starts with two
        numbers and the next number is obtained by adding the two previous
        numbers together), using the following code:
      </p>
      <pre>
  <b>function* fibonacci(a, b) {
    let [prev, current] = [a, b];
    while (true) {
      [prev, current] = [current, prev + current];
      yield current;
    }
  }</b>
      </pre>
      <p>
        To create a generator object based on this function, we simply assign a
        variable to the function, and provide it with two starting numbers as
        arguments:
      </p>
      <pre>
        <b>const sequence = fibonacci(1,1);</b>

        // The generator object is now stored in the sequence variable. It inherits a method
        called next(), which is then used to obtain the next value produced by the yield
        command:
        <b>sequence.next();</b>
        << 2

        <b>sequence.next();</b>
        << 3

        <b>sequence.next();</b>
        << 5

        // It will continue to add up:
          2  +  3 = 5
          3  +  5 = 8
          5  +  8 = 13
          8  + 13 = 21
          13 + 21 = 34

        // It’s also possible to iterate over the generator to invoke it multiple times:
        <b>for (n of sequence) {
          // stop the sequence after it reaches 100
          if (n > 10) break;
          console.log(n);
        }</b>

        << 8
        << 13
        << 21
        << 34
        << 55
        << 89
      </pre>
      <u>Pure Function</u>
      <p>
        A key aspect of functional programming is its use of pure functions. A
        pure function is a function that adheres to the following rules:
      </p>
      <ul>
        <li>
          The return value of a pure function should only depend on the values
          provided as arguments. It doesn’t rely on values from somewhere else
          in the program.
        </li>
        <li>
          There are no side-effects. A pure function doesn’t change any values
          or data elsewhere in the program. It only makes non-destructive data
          transformations and returns new values, rather than altering any of
          the underlying data.
        </li>
        <li>
          Referential transparency. Given the same arguments, a pure function
          will always return the same result.
        </li>
      </ul>
      <p>In order to follow these rules, any pure function must have:</p>
      <ul>
        <li>
          At least one argument; otherwise the return value must depend on
          something other than the arguments of the function, breaking the first
          rule
        </li>
        <li>
          return value; otherwise there’s no point in the function (unless it
          has changed something else in the program – in which case, it’s broken
          the “no 422 JavaScript: Novice to Ninja, 2nd Edition side-effects”
          rule).
        </li>
      </ul>
      <p>
        Pure functions help to make functional programming code more concise and
        predictable than in other programming styles. The following example
        shows a pure function that writes the string provided as an argument
        backwards:
      </p>
      <pre>
  <b>function reverse(string) {
    return string.split('').reverse().join('');
  }</b>


  // The function does not change the actual value of the argument, it just
  // returns another string that happens to be the argument written backwards
  <b>const message = 'Hello JavaScript';
    reverse(message);</b>
  << 'tpircSavaJ olleH'

  <b>message // hasn't changed</b>
  << 'Hello JavaScript'
      </pre>
      <p>
        If I am correct a pure function is when a function uses arguments to use
        within a function and not a variable used inside a function.
      </p>
      <u>Higher-Order Function</u>
      <p>
        From the book, it says, "Higher-order functions are functions that
        accept another function as an argument, or return another function as a
        result, or both. This sounds like what was described in the
        <i>Functions That Return Functions</i> section.
      </p>
      <u>Currying</u>
      <p>
        Currying is a process that involves the partial application of
        functions. Currying relies on higher-order functions that are able to
        return partially applied functions. Currying allows you to turn a single
        function into a series of functions instead. This is useful if you find
        that you’re frequently calling a function with the same argument. For
        example, the following multiplier() function is a generic function that
        returns the product of two numbers that are provided as arguments:
      </p>
      <pre>
  <b>function multiplier(x,y) {
    return x * y;
  }

  const tax = multiplier(0.22,400);</b>
  << 88

  // The could above can be made more useful by adding some code at the start
  // that allows it to be curried so it returns another function if only one
  // argument is provided:
  <b>function multiplier(x, y) {
    if (y === undefined) {
      return function (z) {
        return x * z;
      };
    } else {
      return x * y;
    }
  }

  calcTax = multiplier(0.22);</b>
  << function (z) {
    return x * z;
  }

<b>calcTax(400);</b>
<< 88

      </pre>
      <h2>Ajax</h2>
      <p>
        Ajax is a technique that allows web pages to communicate asynchronously
        with a server, and it dynamically updates web pages without
        reloading.This enables data to be sent and received in the background,
        as well as portions of a page to be updated in response to user events,
        while the rest of the program continues to run. The use of Ajax
        revolutionized how websites worked, and ushered in a new age of web
        applications. Web pages were no longer static, but dynamic applications.
      </p>
      <h2>Clients and Servers</h2>
      <p>
        The web of computers known as the internet can be separated into two
        parts: clients and servers. A client, such as a web browser, will
        request a resource (usually a web page) from a server, which processes
        the request and sends back a response to the client.
      </p>
      <p>
        JavaScript was originally designed as a client-side scripting language
        and adding dynamic features to a web page that is returned from the
        server. Ajax allows JavaScript to request resources from a server on
        behalf of the client. The resources requested are usually JSON data or
        small fragments of text or HTML rather than a whole web page. A server
        is required when requesting resources using Ajax. Some sever-side
        languages are PHP, Ruby, Node.js, or .NET to serve the data response
        following an Ajax request (usually from a back-end database).
      </p>
      <u>A Brief History of Ajax</u>
      <p>
        The term “Ajax” was coined by Jesse James Garrett in 2005 in the article
        “Ajax: A New Approach to Web Applications,”2 where he referred to
        techniques being used by Google in its recent web applications. Ajax was
        a neat acronym that referred to the different parts of the process being
        used: Asynchronous JavaScript and XML:
      </p>
      <table>
        <tr>
          <td id="td"><b>Asynchronous</b></td>
          <td>
            When a request for data is sent, the program doesn’t have to stop
            and wait for the response. It can carry on running, waiting for an
            event to fire when a response is received. By using callbacks to
            manage this, programs are able to run in an efficient way, avoiding
            lag as data is transferred back and forth.
          </td>
        </tr>
        <tr>
          <td id="td"><b>JavaScript</b></td>
          <td>
            JavaScript was always considered a front-end language, not used to
            communicate with the server. Ajax enabled JavaScript to send
            requests and receive responses from a server, allowing content to be
            updated in real time.
          </td>
        </tr>
        <tr>
          <td id="td"><b>XML</b></td>
          <td>
            When the term Ajax was originally coined, XML documents were often
            used to return data. Many different types of data can be sent, but
            by far the most commonly used in Ajax nowadays is JSON, which is
            more lightweight and easier to parse than XML. (Although it has
            never really taken off, the termAjaj is sometimes used to describe
            the technique.) JSON also has the advantage of being natively
            supported in JavaScript, so you can deal with JavaScript objects
            rather than having to parse XML files using DOM methods.
          </td>
        </tr>
      </table>
      <p>
        I thought this was crazy. When the World Wide Web started, web pages
        contained static content. Any changes to the content on the page
        required a full page reload, often resulting in the screen going blank
        while the new page loaded. Remember, this was back in the 1990s, when
        dial-up modems were the norm. It was not till 2004 and 2005 when Google
        launched Gmail and Google Maps where the user experience by changing the
        parts of the page without a full refresh.
      </p>
      <u>APIs</u>
      <p>
        An application programming interface (API) is a collection of methods
        that allows external access to another program or service. Many websites
        allow controlled access to their data via public APIs. This means that
        developers are able to interact with the data and create mashups of
        third-party services. A weather site, for example, might have an API
        that provides methods that return information about the weather in a
        given location, such as temperature, wind speed, and so on. This can
        then be used to display local weather data on a web page. The
        information that’s returned by APIs is often serialized as JSON. Since
        the data is being provided by an external site, CORS will have to be
        enabled in order to access information from an API. Some services may
        also require authentication in order to access their APIs.
      </p>
      <h2>The Fetch API</h2>
      <p>
        The Fetch API, which is currently a living standard for requesting and
        sending data asynchronously across a network. Fetch API uses promises to
        avoid callback hell.
      </p>
      <u>Basic Usage</u>
      <p>
        The Fetch API provides a global fetch() method that only has one
        mandatory argument, which is the URL of the resource you wish to fetch.
        A very basic example would look something like the following piece of
        code:
      </p>
      <pre>
  <b>fetch('https://example.com/data')
    .then( // code that handles the response )
    .catch( // code that runs if the server returns an error )</b>
      </pre>
      <p>
        The fetch() method returns a promise that resolves to the response
        returned from the URL that was provided as an argument. In the example
        above, the promise will be resolved when a response is received from the
        URL https:example.com/data.
      </p>
      <u>Response Interface</u>
      <p>
        The Fetch API introduced the Response interface that deals with the
        object that’s returned when the promise is fulfilled. Response objects
        have a number of properties and methods that allow us to process the
        response effectively. we can use an if block to check if the request was
        successful, and throw an error otherwise:
      </p>
      <pre>
  <b>const url = 'https:example.com/data';

  fetch(url).then((response) => {
    if(response.ok) {
    return response;
  }throw Error(response.statusText);
  })
  .then( response => console.log("Do something with response")
  .catch( error => console.log('There was an error!') ))</b>
      </pre>
      <p>
        Notice that the error thrown refers to the statusText property of the
        response object and specifies the status message that corresponds to the
        code returned, for example it might be 'Forbidden' for a status code of
        403. Some other properties of the Response object are:
      </p>
      <ul>
        <li>
          headers – A Headers object (see later section) containing any headers
          associated with the response
        </li>
        <li>url – A string containing the URL of response</li>
        <li>
          redirected – A boolean value that specifies if the response is the
          result of a redirect
        </li>
        <li>
          type – A string value of “basic”, “cors”, “error” or “opaque”. A value
          of “basic” is used for a response from the same domain. A value of
          “cors” means the data was received from a valid cross-origin request
          from a different domain. A value of “opaque” is used for a response
          received from “no-cors” request from another domain, which means
          access to the data will be severely restricted. A value of “error” is
          used when a network error occurs.
        </li>
      </ul>
      <u>Redirects</u>
      <p>
        The redirect() method can be used to redirect to another URL but there
        is no support for the redirect() method in any browser.
      </p>
      <u>Text Reponses</u>
      <p>
        The text() method takes a stream of text from the response, reads it to
        completion and then returns a promise that resolves to a USVSting object
        that can be treated as a string in JavaScript. Here is an example of how
        it would bre resolved:
      </p>
      <pre>
  <b>fetch(url)
    .then( response => response.text() ); // transforms the text stream into a JavaScript string
    .then( text => console.log(text) )
    .catch( error => console.log('There was an error: ', error))</b>
      </pre>
      <p>
        A promise is returned, that resolves with a string representation of the
        text that was returned. In the next statement, we take the result of the
        promise and use console.log() to display the text in the console.
      </p>
      <u>File Responses</u>
      <p>
        The blob() method is used to read a file of raw data, such as an image
        or a spreadsheet. Once it has read the whole file, it returns a promise
        that resolves with a blob object. Here is an example:
      </p>
      <pre>
  <b>fetch(url)
    .then( response => response.blob() ); // transforms the data into a blob object
    .then( blob => console.log(blob.type) )
    .catch( error => console.log('There was an error: ', error))</b>
      </pre>
      <p>
        This is similar to the text example above, but the blob() method is used
        to return a blob object. We then use the type property to log the
        MIME-type to log what type of file we have received.
      </p>
      <u>JSON Responses</u>
      <p>
        JSON is probably the most common format for AJAX responses. The json()
        method is used to deal with these by transforming a stream of JSON data
        into a promise that resolves to a JavaScript object. Here is an example:
      </p>
      <pre>
  <b>fetch(url)
    .then( response => response.json() ); // transforms the JSON data into a JavaScript object
    .then( data => console.log(Object.entries(data)) )
    .catch( error => console.log('There was an error: ', error))
  </b>
      </pre>
      <u>Creating Response Objects</u>
      <p>
        Although most of the time you will be dealing with a response object
        that is returned from a request you make, you can also create your own
        response objects using a constructor function:
      </p>
      <pre>
  <b>const response = new Response("Hello!", {
    ok: true,
    status: 200,
    statusText: "OK",
    type: "cors",
    url: "/api",
  });</b>
      </pre>
      <p>
        The first argument is the data that is to be returned while the second
        argument is an object that can be used to provide values for any of the
        properties listed above. This is useful if we need to send a dummy
        response for testing purposes or if we are creating an API that needs to
        send a response.
      </p>
      <u>Request Interface</u>
      <p>
        We can get more fine-grained control over the request being made by
        providing a Request object as an argument. This allows a number of
        options to be set about the request. Request objects are created using
        the Request() constructor, and include the following properties:
      </p>
      <ul>
        <li>
          url – The URL of the requested resource (the only property that is
          required)
        </li>
        <li>
          method – a string that specifies which HTTP method should be used for
          the request. By default, this is GET
        </li>
        <li>
          headers – This is a Headers object (see later section) that provides
          details of the request’s headers
        </li>
        <li>
          mode – Allows you to specify if Cross-origin resource sharing (CORS)
          is used or not. CORS is enabled by default
        </li>
        <li>
          cache – Allows you to specify how the request will use the browser’s
          cache. For example, you can force it to request a resource and update
          the cache with the result, or you can force it to only look in the
          cache for the resource
        </li>
        <li>
          credentials – Lets you specify if cookies should be allowed with the
          request
        </li>
        <li>
          redirect – Specifies what to do if the response returns a redirect.
          There’s a choice of three values: “follow” (the redirect is followed),
          “error” (an error is thrown) or “manual” (the user has to click on a
          link to follow the redirect)
        </li>
      </ul>
      <p>
        A constructor function is used to create a new Request object. An
        example is shown below:
      </p>
      <pre>
  <b>const request = new Request("https://example.com/data", {
    method: "GET",
    mode: "cors",
    redirect: "follow",
    cache: "no-cache",
  });</b>
      </pre>
      <p>
        The url property is the first argument, and is required. The second
        argument is an object made up of any of the other properties listed
        above.
      </p>
      <pre>
  <b>fetch(request)
    .then( // do something with the response )
    .catch( // handle any errors)</b>

    ------------------------------------------

  <b>fetch('https://example.com/data', {
    method: 'GET',
    mode: 'cors',
    redirect: 'follow',
    cache: 'no-cache'
  })
  .then( // do something with the response )
  .catch( // handle any errors)
    </b>
      </pre>
      <u>Headers Interface</u>
      <p>
        HTTP headers are used to pass on any additional information about a
        request or response. This information is typically contained in headers
        and includes the file-type of the resource, cookie information,
        authentication information and when the resource was last modified. A
        new Headers instance is created using a constructor function, as seen in
        the example below:
      </p>
      <pre>
  <b>const headers = new Headers();</b>
      </pre>
      <p>
        A Headers object includes the following properties and methods that can
        be used to access information about the headers, as well as edit the
        header information.
      </p>
      <ul>
        <li>
          has() – Can be used to check if the headers object contains the header
          provided as an argument
        </li>
        <li>get() - Returns the value of the header provided as an argument</li>
        <li>
          set() – Can be used to set a value of an already existing header, or
          create a new header with the value provided as an argument if it does
          not already exist
        </li>
        <li>append() – Adds a new header to the headers object</li>
        <li>delete() – Removes the header provided as an argument</li>
        <li>
          keys(), values() and entries() – Iterators that can be used to iterate
          over the headers key, values or entries (key and value pairs)
        </li>
      </ul>
      <u>Putting it all together</u>
      <p>
        We can use the Headers, Request and Response objects to put together a
        typical example that sets up the URL, Request and Headers before calling
        the fetch() method:
      </p>
      <pre>
  <b>const url = "https:example.com/data";
    const headers = new Headers({
      "Content-Type": "text/plain",
      "Accept-Charset": "utf-8",
      "Accept-Encoding": "gzip,deflate",
  });

  const request = (url, { headers: headers });

  fetch(request)
    .then(function (response) {
      if (response.ok) {
        return response;
      }
      throw Error(response.statusText);
    })
    .then((response) =>
      console
        .log("Do something with response")
        .catch((error) => console.log("There was an error!"))
    );</b>
      </pre>
      <u>Receiving Information</u>
      <p>
        This code works so I just added a URL to open the
        <a href="sendinginfo/ajax.html" target="_blank">code</a> to view it.
      </p>
      <u>Sending Information</u>
      <p>
        This code works so I just added a URL to open the
        <a href="receivinginfo/todo.html" target="_blank">code</a> to view it.
      </p>
      <h2>FormData</h2>
      <p>
        The Fetch API includes the FormData interface, which makes it much
        easier to submit information in forms using Ajax. A FormData instance is
        created using a constructor function:
      </p>
      <pre>
  <b>const data = new FormData();</b>
      </pre>
      <p>
        This code works so I just added a URL to open the
        <a href="formdata/todo.html" target="_blank">code</a> to view it.
      </p>
      <h2>A Living Standard</h2>
      <p>
        A “living standard”, which means that the specification is being
        developed in the wild . This means that, despite it being available to
        use, it’s still subject to change as developers, browser vendors and
        end-users provide feedback about how it works. It’s an experimental
        technology, and new features might get added, or the syntax and behavior
        of some properties and methods might change in the future.
      </p>
      <p>
        There is a library that takes care of Ajax requests like the Fetch API.
      </p>
      <p>
        The jQuery library is a good option for this – it has the generic ajax()
        method that can be used in a very similar way to the fetch() method. For
        example, if you want to get the data from the number API, you would use
        the following code:
      </p>
      <pre>
  <b>$.ajax('http://numbersapi.com/random')
  .done(text => outputDiv.innerHTML = text );</b>
      </pre>
      <!--    NOTES GO ABOVE HERE     -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!-- This is where my questions are added. This is to help me know that I
      will be continuing my notes above this sectin. -->
      <h2>Questions:</h2>
      <p>
        When would you use the description property to describe what a function
        does? When would you see it. I thought that was why we put comments in
        our code. Here is an example how the loadGame() function can be written
        as an async function.
      </p>
    </main>

    <!-- FOOTER HERE -->
    <footer></footer>
  </body>
</html>
