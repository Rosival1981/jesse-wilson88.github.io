<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="description" content="infomation about site." />
    <meta name="author" content="Jesse Wilson" />

    <!-- SITE TITLE -->
    <title>Week 7 Notes & Codes</title>

    <!-- TELLS PHONES NOT TO LIE ABOUT THEIR WIDTH & stops the font from
      enlarging when a phone is turned sideways-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- STYLE SHEETS -->
    <link href="css/normalize.css" rel="stylesheet" />
    <!-- phone-default -->
    <link href="css/small.css" rel="stylesheet" />
    <!-- enhance-tablet -->
    <link href="css/medium.css" rel="stylesheet" />
    <!-- enhance-desktop -->
    <link href="css/large.css" rel="stylesheet" />

    <!-- JAVASCRIPTS-->
    <!-- <script defer src="js/styles.js"></script> -->
  </head>
  <body>
    <!-- HEADER HERE -->
    <header id="headerWrapper">
      <h1>Week 7 Notes & Codes</h1>
    </header>

    <!-- NAVIGATION HERE -->
    <nav></nav>

    <!-- CONTENT HERE -->
    <main>
      <h1><a href="https://www.sitepoint.com/premium/books/html5-css3-for-the-real-world-2nd-edition/read/12">Chapter 8: CSS3 Transforms And Transitions</a></h1>
      <p>
        For years, the only way to displaytext on an angle was to use an image
        of text created in an image-editing program and the only way to animate
        was to change positioning with JavaScript. This is far from ideal. Enter
        CSS3: without a line of JavaScript or a single JPEG, you can tilt,
        scale, move, and even flip your elements with ease.
      </p>
      <h2>Transforms</h2>
      <p>
        The CSS3 transform lets you translate, rotate, scale, and.or shew any
        element on the page. Some effects are possible using previously existing
        CSS features (translating with relatice and absolute positioning), CSS3
        give us more control over many more aspects of the elements appearance.
      </p>
      <p>
        With transform functions we can manipulate an element's appearance.The
        value of the transform property is one or more transform functions
        (separated by spaces) that will be applied in the order they’re
        provided. All modern browsers, starting with IE10 and Android 3, also
        support the transformation of elements in 3D space, but 3D transforms
        are beyond the scope of this book.
      </p>
      <u>Translation</u>
      <p>
        Translation functions allow you to move elements up, down, left, or
        right. This is similar to the behavior of position: relative; moving
        elements along the x and y axes. When employing a translation function,
        you're moving elements without impacting the flow of the document.
        Unlike positioning: relative; you position an element against either its
        current position or a parent or other ancestor. A translated element can
        only be moved relative to its current position.
      </p>
      <pre>
  // The translate(x,y) function moves an element x from the left, and y from the top
  <b>transform: translate(45px, -45px);</b>

  // If you only want to move an element vertically
  <b>transform: translateX(45px);</b> // Move 45px to the right along
  the x axis

  // If you only want to move an element horizontally
  <b>transform: translateY(-30px);</b> // Move up along the y axis by 30px
      </pre>
      <figure>
        <img src="images/dukes1.jpg" alt="Put your dukes up sir" />
        <figcaption>
          Figure 8.1. This block will serve to illustrate CSS3 transforms
        </figcaption>
      </figure>
      <p>
        Let's pretend the image above is HTML code and we will use the following
        code to change how it looks. Here is the code that we will be working
        with for the words <b>Put your dukes up, sire</b>.
      </p>
      <pre>
  &#60;h1>Put your &#60;span>dukes</span> up, sire</h1>

  // We will have it change when 'duke' is hovered over
  <b>.ad-ad2 h1:hover span {
    color: #484848;  
    transform: translateX(40px);
  }</b>
      </pre>
      <p>
        Because transforms does not work on inline elements, this is how the
        code would look so it did work.
      </p>
      <pre>
  <b>.ad-ad2 h1 span {
    font-size: 30px;
    color: #999999;
    display: inline-block;
  }</b>
      </pre>
      <p>
        This would be the result after hovering over the word dukes.
      </p>
      <figure>
        <img src="images/dukes2.jpg" alt="Put up your dukes hovered over">
        <figcaption>Figure 8.2. The result of our translate transform</figcaption>
      </figure>
      <u>Scaling</u>
      <p>
        The scale(x,y) function scales an element by the defined factors 
        horizontally then vertically. If only variable is passed to the 
        scale(x) function, it will be used for bother x and y values and will 
        maintain the original aspect ratio. If you did scale(1) would leave the 
        element the same size, scale(2) would double its proportions, 
        scale(0.5) would halve them, and so on. Providing different values will 
        distort the element, as you’d expect.
      </p>
      <pre>
  <b>transform: scale(1.5, 0.25);</b>

  // You can also scale only horizontally or vertically.
  <b>scaleX(x); // Horizontal dimensions
  scaleY(y); // Vertical dimensions
  </b>

  // This is how you add a scale transform to your span. You shouldn’t declare a new transform:   
  // because of the cascade, a second transform would override the first. To declare multiple   
  // transformations, provide a space-separated list of transform functions.
  // A scaled element will grow outwards from or shrink inwards towards its center.
  <b>.ad-ad2 h1:hover span {
    color: #484848;
    transform: translateX(40px) scale(1.5);
  }</b>
      </pre>
      <p>
        If your text looks like the Figure 8.3, you may adjusting
        the element’s height, width, or font-size instead of using a scale() transform.
      </p>
      <figure>
        <img src="images/inlinetext.jpg" alt="Unwanted inline text results">
        <figcaption>Figure 8.3. Using the scale function on inline text can have unwanted results</figcaption>
      </figure>
      <p>
        In our example, however, we want the text to pop out of the ad without reflowing
        the surrounding text, so the scale does exactly what we need it to do. Figure 8.4
        shows what our hover state looks like with the scale added to the existing translation.
      </p>
      <figure>
        <img src="images/dukes3.jpg" alt="The word dukes is scaled to a larger size">
        <figcaption>Figure 8.4. Our ad now has plenty of pop</figcaption>
      </figure>
      <u>Rotation</u>
      <p>
        The rotate() function rotates an element around the point of origin by a specified
        angle value. As with scale, by default the point of origin is the element’s center. 
      </p>
      <pre>
  // Values for the rotation() function can be degrees, grads, radians, or turns.
  <b>.ad-ad2 h1:hover span {
    color: #484848;
    transform: rotate(10deg) translateX(40px) scale(1.5);
  }</b>
      </pre>
      <p>
        Declaring the rotation before the translate so it is applied first. Transforms are applied in the order provided. In this case, the span will be rotated 10 degrees, and then moved
        40px along the rotated x axis as it would be seen in figure 8.5.
      </p>
      <figure>
        <img src="images/dukes4.jpg" alt="Shows the word duke scaled and rotated clockwise">
        <figcaption>
          Figure 8.5. Our text has now been translated, scaled, and rotated—that’s quite a punch!
        </figcaption>
      </figure>
      <u>shew</u>
      <p>
        The skew(x,y) function specifies a skew along the x and y axes. As you’d expect,
the x specifies the skew on the x axis, and the y specifies the skew on the y axis. If
the second parameter is omitted, the skew will only occur on the x axis as shows in figure 8.6.
      </p>
      <figure>
        <img src="images/skew.jpg" alt="Some text with a skew transform applied">
        <figcaption>Figure 8.6. Some text with a skew transform applied</figcaption>
      </figure>
      <u>Changing the Origin of the Transform</u>
      <p>
        We can control the origin from which your transforms are
        applied. This is done using the transform-origin property. It has the same syntax
        as the background-position property, and defaults to the center of the object. Applying a rotate() transform to a circle would have no
        visible effect—a circle rotated 90 degrees still looks exactly the same as it did before
        being rotated. An ellipse rotated 180 degrees around its center would also look the
        same as it did before being rotated upside down. However, if you gave your circle
        or ellipse a transform-origin of 10% 10% or top center, you would notice the
        rotation as Figure 8.7 illustrates.
      </p>
      <figure>
        <img src="images/origin.jpg" alt="Rotating an ellipse1 is more noticeable if the transform-origin is set to something other than the default
        50% 50%">
        <figcaption>Figure 8.7. Rotating an ellipse1 is more noticeable if the transform-origin is set to something other than the default
          50% 50%</figcaption>
      </figure>
      <pre>
  <b>transform-origin: 0 0;</b>
      </pre>
      <p>
        The order of transform functions does matter: if you rotate before translating,
        your translate direction will be on the rotated axis. The rightmost square in Figure
        8.8 was translated then rotated with transform: translateX(200px)
        rotate(135deg);. The leftmost square was rotated first then translated along
        the newly rotated axis: transform: rotate(135deg) translateX(200px).
      </p>
      <figure>
        <img src="images/orderoftransform.jpg" alt="The order of transform functions makes a difference">
        <figcaption>Figure 8.8. The order of transform functions makes a difference</figcaption>
      </figure>
      <u>Support for Internet Explorer 8 and Earlier</u>
      <p>
        I am not taking notes for this section since Explorer 8 has not been supported since January 12, 2016. The code it shared looked nasty anyways. You can look at page 193 - 194 for if you really want to see it and go over it.
      </p>
      <u>Transitions</u>
      <p>
        Animation has certainly been possible for some time with JavaScript, but native
        CSS transitions generally require less client-side processing, so they’ll usually appear
        smoother. On mobile devices with limited computing power, this can be a lifesaver.
      </p>
      <p>
        Transitions allow the values of CSS properties to change over time, essentially
        providing simple animations. For example, if a link changes color on hover, you
        can have it gradually fade from one color to the other instead of a sudden change. We can animate any of the transforms we’ve just seen, so that our pages feel more
        dynamic.
      </p>
      <p>
        CSS transitions are declared along with the regular styles on an element. Whenever
        the target properties change, the browser will apply the transition making the change
        gradual. Often the change will be due to different styles applied to a hover state;
        however, transitions will work equally well if the property in question is changed
        by adding a class, or otherwise using JavaScript to change state. This is significant:
        rather than writing out an animation in JavaScript, you can simply switch a property
        value and rely on the browser to do all the heavy lifting.
      </p>
      <p>Here are the steps to create a simple transition using only CSS:</p>
      <ol>
        <li>Declare the original state of the element in the default style declaration.</li>
        <li>Declare the final state of your transitioned element; for example, a :hover state.</li>
        <li>Include the transition functions in your default style declaration using the
          transition properties, including: transition-property, transition-duration,
          transition-timing-function, and transition-delay. We’ll look at each of
          these and how they work shortly.</li>
      </ol>
      <p>
        The important point to note is that the transition is declared in the default or
        originating state. The -webkit- vendor prefix is still needed for older mobile devices,
        including iOS6.1, BlackBerry10, Android 4.3 and UC Browser for Android. All
        other browsers, including IE10 and Android 4.4 browser support the unprefixed
        syntax.
      </p>
      <u>transition-property</u>
      <p>
        The transition-property property defines the CSS properties of the element that
        should be transitioned, with all for all properties being the default.
      </p>
      <p>
        Any property changing from one value to another for which you can find a valid
        midpoint can be transitioned. For example, in transitioning from a 1px red border
        to a 15px blue border, we transition the color and width of the border. The midpoint of 1px and 15px is obvious (8px), so we know that is a transitionable property value.
        The midpoint between red and blue might not seem obvious, but the browser converts
        named colors to their numeric values, which have a midpoint. If the borderstyle
        were declared as changing from solid to dashed, that would not be a transitionable
        property as there is no midpoint between these key terms.
      </p>
      <p>
        It is important to include a pre-state and a post-state. For example, to transition
        from rectangular corners to rounded corners, set the original state to border-radius:
        0;. A
        list of properties for Animatable CSS properties can be animated is found at
        <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties">MDN Web Docs</a>.
      </p>
      <pre>
  // Appling the transition to the transform property
  <b>.ad-ad2 h1 span {
    transition-property: transform;
  }</b>

  // Seperate transition-property declaration by commas
  <b>.foo {
    transition-property: transform, color;
  }</b>
      </pre>
      <p>
        In itself, the transition-property property has no effect; that’s because we still
        need to specify the duration of the transition.
      </p>
      <u>The transition-duration Property</u>
      <p>
        The transition-duration property sets how long the transition will take to go from the default state to the transitioned state. It can be done in seconds (s) or milliseconds (ms).
      </p>
      <pre>
  // Seconds
  transition-duration: 0.2s;

  // Milliseconds
  transition-duration: 200ms;
      </pre>
      <p>
        While transitions are supported in all modern browsers, the fact that 
        they’re declared separately from the properties that are changing means 
        that those changes will still be apparent in older browsers without support 
        for transitions. Those browsers will still apply the :hover (or other) 
        state, except that the changes will happen instantly rather than 
        transitioning over time.
      </p>
      <u>The transition-timing-function Property</u>
      <p>
        The transition-timing-function lets you control the pace of the transition 
        in even more granular detail. The most common timing functions include the 
        key terms ease, linear, ease-in, ease-out, or ease-in-out. Here are the 
        different key terms explained:
      </p>
      <ul>
        <li>The default ease has a slow start, then it speeds up, and ends slowly.</li>
        <li>The ease-in-out is similar to ease, but accelerates more sharply at the beginning.</li>
        <li>The linear creates a transition that animates at a constant speed.</li>
        <li>ease-in creates a transition that is slow to start but gains speed, then stops abruptly.</li>
        <li>The opposite, ease-out, starts at full speed, then slows progressively as it reaches the conclusion of the transition.</li>
      </ul>
      <p>
        The book says the best way to familiarize ourself with these is to play around with them and try them all. This is something I did when I taught myself BASIC. It also says it is helpful to set the transition-duration longer when testing timing functions if it is too fast. Then I can put it to what I want. The book talks about making our own <a href="http://cubic-bezier.com/">cubic-bezier</a> function but most likely I will not since it is calculus and I have never taken a calculus class. Here is another <a href="http://estelle.github.io/animation/files/cubicbezierprint.html">link</a> the book shared.
      </p>
      <p>
        With these predefined timing functions and developer-defined cubic Bézier function, we can divide the transition over equidistant steps. With steps we can:
      </p>
      <ul>
        <li>You define the number of steps and the direction of either start or end.</li>
        <li>Where either the first step happens at the animation start.</li>
        <li>
          Where the last step happens at the animation end respectively.
        </li>
      </ul>
      <p>
        For example, steps(5, start) would jump
        through the equidistant steps of 0%, 20%, 40%, 60%, and 80%, and steps(5, end)
        198 HTML5 & CSS3 for the Real World
        would jump throught the equidistant steps of 20%, 40%, 60%, 80%, and 100%.
      </p>
      <pre>
  // This makes the transition fast to start with, becoming slower as it progresses. Of
  // course, with a 0.2 second duration, the difference is barely perceptible.
  <b>transition-timing-function: ease-out;</b>
      </pre>
      <u>The transition-delay Property</u>
      <p>
        By using the transition-delay property, it’s possible to introduce a delay before the transition begins. A transition noramally begins immediately with a default of 0. To delay the transition include the number of seconds (s) or milliseconds (ms). 50ms delay is enough time to wait and make sure the user are intentionally hovering over your ad or anything else they can hover over. You don't want the user to have a bad experience accidently hovering over something (an ad or anything else).
      </p>
      <pre>
  <b>-webkit-transition-delay: 50ms;
  transition-delay: 50ms;</b>  
      </pre>
      <p>
        <b>Negative</b> time <b>delays</b> that's less than the duration of the entire transition will cause it to start immediately, but it will start partway through the animation. if you have a delay of -500ms on a 2s transition, the transition will start a quarter of the way through, and will last 1.5 seconds.
      </p>
      <u>The transition Shorthand Property</u>
      <p>
        With four transition properties and a vendor prefix, you could wind up with eight
        lines of CSS for a single transition. Fortunately, as with other properties such as border, there’s a shorthand available. The transition property is shorthand for
        the four transition properties just described.
      </p>
      <pre>
  // Let’s take another look at our transition so far
  <b>.ad-ad2 h1 span {
    transition-property: transform;
    transition-duration: 0.2s;
    transition-timing-function: ease-out;
    transition-delay: 50ms;
  }</b>

  // Now let’s combine all those values into a shorthand declaration
  <b>.ad-ad2 h1 span {
    transition: transform 0.2s ease-out 50ms;
  }</b>
      </pre>
      <u>Multiple Transitions</u>
      <p>
        The transition properties allow for multiple transitions in one call. For example,
        if we want to change the color at the same time as changing the rotation and size,
        we can. If we wanted to transition the text colors instead of just transitioning the rotation we would have to include the color property in the transitioned style declaration and then either add the color property in the transition-property
        value list, or use the key term all.
      </p>
      <pre>
  <b>transition-property: transform, color;
  transition-duration: 0.2s;
  transition-timing-function: ease-out;
  transition-delay: 50ms;</b>

  // If you want your properties to transition at different rates, or if you just want a select
  // few to have a transition effect. Simply include each value in a comma-separated list using 
  // the same order as the transition-property for all your longhand transition property declarations.
  <b>transition-property: transform, color;
  transition-duration: 0.2s, 0.1s;
  transition-timing-function: ease-out, linear;
  transition-delay: 50ms;</b>

  // And the shorthand would look like this:
  <b>transition: transform 0.2s ease-out 50ms, color 0.1s linear 50ms;</b>

  // Or we can change both properties at the same rate and delay, you can include
  // both property names. When using the all keyword, all the properties transition 
  // at the same rate, speed, and delay.
  <b>transition: all 0.2s ease-out 50ms;</b>
      </pre>
      <h2>Annimations</h2>
      <p>
        Transitions animate elements over time and are limited in what they can do. We can define the staring and ending states but there are no fine-grained control over any intermediate states. Unlike transtions, CSS animations will allow you to control each step of an animation via key frames. A keyframe is a snapshot
        that defines a starting or end point of any smooth transition. With CSS transitions,
        we’re essentially limited to defining a first and a last keyframe. CSS animations allow
        us to add any number of keyframes in between, to CSS animations is great for mobile devices with the lack of powerful proccessors compaired to weighty, CPU-intensive JavaScript animation. But it’s still better
        to employ JavaScript for intricate, stateful UIs, and when you do, you’ll likely want
        to use a JavaScript animation library to help with manageability and performance.
      </p>
      <u>Keyframes</u>
      <p>
        Each keyframe looks like its own nested CSS declaration block. Instead of a traditional
        selector, though, you use a percentage value, or a comma-separated list of
        percentage values. There are two keyterms―from and to―which evaluate to 0%
        and 100% respectively. These values specify how far along the animation each
        keyframe is located.
      </p>
      <pre>
  <b>@keyframes moveRight { 
    from {
    transform: translateX(-50%);
    }
    to {
    transform: translateX(50%);
    }
  }
  
  @keyframes appearDisappear { 
    0%, 100% {
    opacity: 0;
    }
    20%, 80% {
    opacity: 1;
    }
  }
  
  @keyframes bgMove {
    100% {
    background-position: 120% 0;
    }
  }</b>
      </pre>
      <u>Animation Properties</u>
      <p>
        The animation properties, remembering that you will need two declarations for
        each property as the -webkit- prefix is still needed in WebKit browsers, are as
        follows:
      </p>
      <p>
        The <b>animation-name</b> property is used to attach an animation (previously defined using the @keyframes syntax) to an element:
      </p>
      <pre>
  <b>animation-name: appearDisappear;</b>
      </pre>
      <p>
        The <b>animation-duration</b> property defines the length of time (in seconds or milliseconds)
        an animation takes to complete one iteration (all the way through, from
        0% to 100%): 
      </p>
      <pre>
  <b>animation-duration: 300ms;</b>
      </pre>
      <p>
        The <b>animation-timing-function</b> determines how the animation will progress over its duration.:
      </p>
      <figure>
        <img src="images/bike_sprite.png" alt="The sprite image we'll use to create the animation" class="ad-ad3">
        <figcaption>Figure 8.9. The sprite image we'll use to create the animation</figcaption>
      </figure>
      <pre>
  <b>animation-timing-function: linear;</b>

  // To make the bike_sprite.png file look like it is moving
  .ad-ad3 :after {
    content: '';
    width: 90px;
    height: 92px;
    background-image: url(../images/bike_sprite.png);
    display: block;
    margin: auto;
  }

  @keyframes bike {
    0% {
    background-position: 0 0;
    }
    100% {
        background-position: -360px 0;
    }
  }

  // This is used to show the first image after going through the spright, if I am correct. Not sure where you would put it.
  <b>animation-timing-function: steps(4, end);</b>
      </pre>
      <p>
        The <b>animation-iteration-count</b> property lets you define how many times the
        animation will play through. The value is generally an integer, but you can also use
        numbers with decimal points (in which case, the animation will end partway through
        206 HTML5 & CSS3 for the Real World
        an iteration), or the value infinite for endlessly repeating animations.
      </p>
      <pre>
  <b>animation-iteration-count: infinite;</b>
      </pre>
      <p>
        When the animation iterates, it normally goes from the 0% to the 100% keyframe,
        jumping back to the 0% when it starts a new iteration (if the animation-iterationcount
        is greater than 1). This is the default or normal value for <b>animation-direction</b>.
        You can use the animation-direction property to change this behavior. With the alternate value, the
        initial iteration and odd-numbered iterations after that will go in the normal 0% to
        100% direction, but the second iteration and every even iteration after that will go
        in the reverse direction of 100% to 0%.
      </p>
      <pre>
  <b>animation-direction: alternate;;</b>
      </pre>
      <p>
        The <b>animation-delay</b> property is used to define how many milliseconds or seconds
        to wait before the browser begins the animation:
      </p>
      <pre>
  <b>animation-delay: 50ms;</b>
      </pre>
      <p>
        The <b>animation-fill-mode</b> property defines what happens before the first animation
        iteration begins and after the last animation iteration concludes. By default, an animation
        has no effect on property values outside of when it’s iterating, but we can
        override this default behavior of animation-fill-mode: none. The available values are none, forwards, backwards, or both.
      </p>
      <pre>
  <b>animation-fill-mode: both;</b>
      </pre>
      <p>
        The <b>animation-play-state</b> property defines whether the animation is running or
        paused. A paused animation displays the current state of the animation statically.
        When a paused animation is resumed, it restarts from the current position.
      </p>
      <pre>
  <b>animation-name: appearDisappear;</b>
      </pre>
      <p>
        This book is so good at taking you through code and then letting you know that you should not do something a certain way. Here is a better way, but there is a way you should do it. Drives me crazy...lol I just want to know HOW to do something the right way. But one again here is another example:
      </p>
      <u>The Shorthand animation Property</u>
      <p>
        Fortunately, there’s a shorthand for all of these animation properties, especially
        since we’re still including the -webkit- prefix. The animation property takes as
        its value a space-separated list of values for the longhand animation-name, animation-
        duration, animation-timing-function, animation-delay, animation-iteration-
        count, animation-direction, animation-fill-mode, and animation-playstate
        properties:
      </p>
      <pre>
  <b>.verbose {
    animation-name: appearDisappear; 
    animation-duration: 300ms; 
    animation-timing-function: ease-in;
    animation-iteration-count: 1;
    animation-direction: alternate;
    animation-delay: 5s;
    animation-fill-mode: backwards;
    animation-play-state: running;
  }</b>
  
  /* shorthand */
  // Note that in the shorthand version, we’ve left out the animation-iteration-count
  and animation-play-state since both were set to default.
  <b>.concise {
    animation: 300ms ease-in alternate 5s backwards appearDisappear;
  }</b>

  // To declare multiple animations on an element, include a grouping for each animation
  //name, with each shorthand grouping separated by a comma.
  <b>.target {
    animation:
    animationOne 300ms ease-in backwards,
    animationTwo 600ms ease-out 1s forwards;
  }</b>
      </pre>
      <p>
        This is how the bike code should look like to make the bike_sprite.png file look like the man is pedaling.
      </p>
      <pre>
  <b>@keyframes bike {
    0% {
      background-position: 0 0;
    }
    100% {
      background-position: -360px 0;
    }
  }

  @keyframes move {
    0% {
      transform: translateX(-100px);
    }
    100% {
      transform: translateX(100px);
    }
  }  
    
  h1:after {
    content: '';
    width: 90px;
    height: 92px;
    background-image: url(../images/bike_sprite.png);
    display: block;
    margin: auto;
    animation: 
        0.4s steps(4, end) infinite 50ms bike,
        8s linear infinite 50ms move;
    animation-play-state: paused;
  }

  h1:hover:after {
    animation-play-state: running;
  }</b>
      </pre>
      <h1><a href="https://www.sitepoint.com/premium/books/html5-css3-for-the-real-world-2nd-edition/read/12">Chapter 12: Canvas, SVG, and Drag and Drop</a></h1>
      <h2>Canvas</h2>
      <p>
        With HTML5’s Canvas API, we can draw anything we can imagine, all through
        JavaScript. We are able to improve the performance of our website by not downloading images off the network. With canvas we can draw:
      </p>
      <ul>
        <li>shapes and lines</li>
        <li>arcs and text</li>
        <li>gradients and patterns</li>
      </ul>
      <p>
        Canvas can also manipulate pixels in images and videos.
      </p>
      <pre>
  // The text in between the canvas tags will only be shown if the canvas element is
  //not supported by the visitor’s browser
  <b>&#60;canvas>
    Sorry! Your browser doesn’t support Canvas.
  &#60;/canvas></b>
      </pre>
      <p>
        Since drawing on the canvas is done using JavaScript, we’ll need a way to grab the
        element from the DOM. We’ll do so by giving our canvas an ID:
      </p>
      <pre>
  <b>&#60;canvas id="myCanvas" class="myCanvas">
    Sorry! Your browser doesn’t support Canvas.
  &#60;/canvas></b>
      </pre>
      <p>
        The canvas element takes both a width and height attribute, which must also be
        set.
      </p>
      <pre>
  // Let’s add a width and height attribute to the canvas element
  <b>&#60;canvas id="myCanvas" class="myCanvas" width="200" height="200">
    Sorry! Your browser doesn’t support Canvas.
  &#60;/canvas></b>

  // Let’s add a border to our canvas using some CSS to visually distinguish it
  on the page.
  <b>.myCanvas {
    border: dotted 2px black;
  }</b>

  // Just adding a background-color to the CSS. This is cool
  <canvas id="myCanvas" class="myCanvas" width="200" height="200">
    Sorry! Your browser doesn’t support Canvas.
  </canvas>
      </pre>
      <u>Drawing on the Canvas</u>
      <p>
        With HTML5’s Canvas API, we can draw anything we can imagine, all through
        JavaScript. To see how this code looks when it is ran click <a href="./canvas/" target="_blank">here</a>.
        Before we can draw onto a canvas, we need to
        grab hold of the canvas element on our page. I tried to take notes for this portion of the book but nothing made sense from what was written and the code that was displayed. That is why I shared the complete code to look at it. 
      </p>
      <p><i>I will try my best to take some notes.</i> Before we can draw onto a canvas, we need to
      grab hold of the canvas element on our page.</p>
      <pre>
  <b>var canvas = document.getElementById("myCanvas");</b>
      </pre>
      <p>
        Once we’ve stored our canvas element in a variable, we then set up the canvas’s
        context. The context is the place where your drawing is rendered. We obtain our drawing context by calling the getContext method and passing it
        the string "2d", since we’ll be drawing in two dimensions.
      </p>
      <pre>
  <b>var context = canvas.getContext("2d");</b>
      </pre>
        <p>
          The object that’s returned by getContext is an instance of CanvasRenderingContext2D. 
          On a real-life painting canvas, you must first saturate your brush with paint before
          you can begin. In the HTML5 canvas, you must do the same, and we do so with the
          strokeStyle or fillStyle properties. Both strokeStyle and fillStyle are set on
          a context object, and both take one of three values: a string representing a color, a
          CanvasGradient object, or a CanvasPattern object
        </p>
        <pre>
  <b>context.strokeStyle = "red";</b>
        </pre>
        <p>
          Fill it with the color blue.
        </p>
        <pre>
  <b>context.fillStyle = "blue";</b>
        </pre>
        <p>
          Let’s change our blue fill to blue with a 50% opacity
        </p>
        <pre>
  <b>context.fillStyle = "rgba(0, 0, 255, 0.5)";</b>
        </pre>
        <u>Drawing a Rectangle to the Canvas</u>
        <p>
          Once we’ve defined the color of the stroke and the fill, we’re ready to start drawing!
          Let’s begin by drawing a rectangle. We can repeat the steps we just took: grabbing
          the canvas and the context, and setting a fill and stroke style. But now, we’ll draw
          a rectangle.We can do this by calling the fillRect and strokeRect methods.
        </p>
        <pre>
  <b>context.fillRect(10, 10, 100, 100);
  context.strokeRect(10, 10, 100, 100);</b>
        </pre>
        <p>
          The code would go together like this:
        </p>
        <pre>
  <b>var canvas = document.getElementById("myCanvas");
  var context = canvas.getContext("2d");
  context.strokeStyle = "red";
  context.fillStyle = "rgba(0, 0, 255, 0.5)";
  context.fillRect(10, 10, 100, 100);
  context.strokeRect(10, 10, 100, 100);</b>
        </pre>
        <figure>
          <img src="./images/simpleRectangle.jpg" alt="A simple rectangle—not bad for our first canvas drawing!">
          <figcaption>Figure 12.2. A simple rectangle—not bad for our first canvas drawing!</figcaption>
        </figure>
        <p>
          In the canvas coordinate system, the top-left corner is (0,0). If the canvas is 200 pixels by 200 pixels, then the bottom-right corner is (200,200), as Figure 12.3 illustrates.
        </p>
        <figure>
          <img src="./images/canvasCoords.jpg" alt="The canvas coordinate system goes top-to-bottom and left-to-right">
          <figcaption>Figure 12.3. The canvas coordinate system goes top-to-bottom and left-to-right</figcaption>
        </figure>
        <u>Variations on fillStyle</u>
        <p>
          Instead of a color as our fillStyle, we could have used a CanvasGradient or a
          CanvasPattern object. createPattern
          takes two parameters: the image to create the pattern with, and how that image
          should be repeated. The repeat value is a string, and the valid values are the same
          as those in CSS: repeat, repeat-x, repeat-y, and no-repeat. The image may still be loading unless it is in the browser cache. To be on the safe side, we’ll use the image’s onload property to create our pattern once the image has been fully loaded.
        </p>
        <pre>
  <b>function drawPattern() {
    …
    var img = new Image();
    img.src = "../images/bg-bike.png";
    img.onload = function() {
      var pattern = context.createPattern(img, "repeat"); 
      context.fillStyle = pattern;                        
      context.fillRect(10, 10, 100, 100);                  
      context.strokeRect(10, 10, 100, 100);             
    };
  }</b>
        </pre>
        <p>
          We can also create a CanvasGradient object to use as our fillStyle. To create a CanvasGradient, we call one of two methods: createLinearGradient() or createRadialGradient(); then we add one or more color stops to the gradient. createLinearGradient ’s x0 and y0 represent the starting location of the gradient. x1 and y1 represent the ending location.
        </p>
        <pre>
  <b>function drawGradient() {
    var canvas = document.getElementById("demo3");
    var context = canvas.getContext("2d");
    context.strokeStyle = "red";
    var gradient = context.createLinearGradient(0, 0, 0, 200); 
  }</b>
        </pre>
        <p>
          Now we need to specify the color stops with the addColorStop() method. The offset is a value between 0 and 1. An offset of 0 is at the start of the gradient, and an offset of 1 is at the end of the gradient. To make a gradient that starts as blue and begins to blend into white halfway down the gradient, we can specify a blue color stop with an offset of 0 and a purple color stop with an offset of 1.
        </p>
        <pre>
  <b>function drawGradient() {
    …
    var gradient = context.createLinearGradient(0, 0, 0, 200);
    gradient.addColorStop(0, "blue"); 
    gradient.addColorStop(1, "white"); 
    context.fillStyle = gradient; 
    context.fillRect(10, 10, 100, 100); 
    context.strokeRect(10, 10, 100, 100); 
  }</b>
        </pre>
        <figure>
          <img src="./images/linearGradient.jpg" alt="Creating a linear gradient with canvas">
          <figcaption>Figure 12.5. Creating a linear gradient with canvas</figcaption>
        </figure>
        <u>Drawing Other Shapes by Creating Paths</u>
        <p>
          We are not limited to only drawing rectangles. The book says we can draw any shape we can imaging but there are no built-in methods for drawing circles or other shapes. To draw more interesting shapes, we must first lay out the
          path of the shape. Paths create a blueprint for your lines, arcs, and shapes, but paths are invisible
          until you give them a stroke! When we drew rectangles, we first set the strokeStyle
          and then called fillRect. When we dray more complex shapes, wew need to take three steps:
        </p>
        <ul>
          <li>Layout the path</li>
          <li>Stroke the path</li>
          <li>Fill the path</li>
        </ul>
        <p>
          The first step is to
          begin the path of the circle. We do that with the method beginPath(), which resets
          the default path for you to begin drawing a new shape:
        </p>
        <pre>
  <b>function drawCircle(canvas) {
    var context = canvas.getContext("2d");
    context.beginPath();
  }</b>
        </pre>
        <p>
          Now we need to create an arc. An arc is a segment of a circle, but as there’s no
          method for creating a circle, we can draw a 360° arc. We create it using the arc
          method.
        </p>
        <pre>
  function drawCircle(canvas) {
    var canvas = document.getElementById("myCanvas");
    var context = canvas.getContext("2d");
    context.beginPath();
    <b>context.arc(50, 50, 30, 0, Math.PI*2, true);
  }</b>
        </pre>
        <p>
          The signature for the arc method is: arc(x, y, radius, startAngle, endAngle,
          anticlockwise). x and y represent where on the canvas you want the arc’s path to begin. startAngle and endAngle represent the start and end angles along the circle’s circumference
          that you want to draw. anticlockwise is an optional argument. If you wanted the arc to be drawn counterclockwise
          instead of clockwise, you would set this value to <b style="color:blue">true</b>.
        </p>
        <pre>
  function drawCircle(canvas) {
    var context = canvas.getContext("2d");
    context.beginPath();
    context.arc(100, 100, 50, 0, Math.PI*2, <b style="color:blue">true</b>);
    <b>context.closePath();</b>
  }
        </pre>
        <p>
          Now we have a path—but unless we stroke it or fill it, we’ll be unable to see it.
        </p>
        <pre>
  function drawCircle(canvas) {
    var context = canvas.getContext("2d");
    context.beginPath();
    context.arc(50, 50, 30, 0, Math.PI*2, true);
    context.closePath();
    <b>context.strokeStyle = "red";
    context.fillStyle = "blue";
    context.lineWidth = 3;</b>
  }
        </pre>
        <p>
          Lastly, we fill and stroke the path. To fill a path you simply call fill, and to
          stroke it you call stroke.
        </p>
        <pre>
  function drawCircle(canvas) {
    var context = canvas.getContext("2d");
    context.beginPath();
    context.arc(100, 100, 50, 0, Math.PI*2, true);
    context.closePath();
    context.strokeStyle = "red";
    context.fillStyle = "blue";
    context.lineWidth = 3;
    <b>context.fill();
    context.stroke();</b>
  }
        </pre>
        <figure>
          <img src="./images/shinyNewCircle.jpg" alt="Our shiny new circle">
          <figcaption>Figure 12.6. Our shiny new circle</figcaption>
        </figure>
        <u>Saving Canvas Drawings</u>
        <p>
          If we deside to keep a copy of our drawing, we can use the API's toDataURL method to save it. It can be saved as a png or jpg, pending on what we specify. Then we can right-click the image and save it as a PNG or JPG. This is what the function looks like to save the drawn image. This does not seem to work.
        </p>
        <pre>
  <b>function saveDrawing() {
    var canvas5 = document.getElementById("demo5");
    window.open(canvas5.toDataURL("image/png"));
  }</b>

  // This is how it is called or can be called
  <b>var button = document.getElementById("saveButton");
  button.addEventListener("click", saveDrawing, false);</b>
        </pre>
        <u>Drawing to the Canvas</u>
        <p>
          To ensure the image has loaded, an event listener will be added that will run the code only once the window’s load event has fired.
        </p>
        <pre>
  <b>window.addEventListener("load", drawImageToCanvas, false);</b>
        </pre>
        <p>
          Then we can grap the image from our page.
        </p>
        <pre>
  <b>function drawImageToCanvas() {
    var canvas = document.getElementById("demo6");
    var context = canvas.getContext("2d");
    var image = document.getElementById("myImageElem");
  }</b>
        </pre>
        <figure>
          <img src="./images/getImage.jpg" alt="An image and a canvas sitting on a page, doing very little">
          <figcaption>Figure 12.8. An image and a canvas sitting on a page, doing very little</figcaption>
        </figure>
        <p>
          We can use canvas’s drawImage method to redraw the image from our page into the
          canvas.
        </p>
        <pre>
  function drawImageToCanvas() {
    var canvas = document.getElementById("demo6");
    var context = canvas.getContext("2d");
    var image = document.getElementById("myImageElem");
    <b>context.drawImage(image, 0, 0);</b>
  }
        </pre>
        <p>
          Because we’ve drawn the image to the (0,0) coordinate, the image appears in the
          top-left of the canvas, as you can see in Figure 12.9.
        </p>
        <figure>
          <img src="./images/redrawImage.jpg" alt="Redrawing an image inside a canvas">
          <figcaption>Figure 12.9. Redrawing an image inside a canvas</figcaption>
        </figure>
        <pre>// Since the image is 64 by 64 pixels and
          the canvas is 200 by 200 pixels. If we draw the image to (68, 68), it would be in the center.
          <b>context.drawImage(image, 68, 68);</b>
        </pre>
        <figure>
          <img src="./images/redrawImageCenter.jpg" alt="Displaying the image in the center of the canvas">
          <figcaption>Figure 12.10. Displaying the image in the center of the canvas</figcaption>
        </figure>
        <u>Manipulating Images</u>
        <p>
          Redrawing an image element from the page onto a canvas is fairly unexciting. It’s
          really no different from using an img element. But what is intresting is when we can manipulate the image after it is drawn in canvas. After the image is drawn, we can use the getImageData method from the Canvas API to manipulate the pixels of that image. For example we can take the color image and change it to black and white.
        </p>
        <p>
          getImageData will return an ImageData object, which contains three properties:
          width, height, and data. The first two are self-explanatory; it’s the last one, data,
          that interests us. data contains information about the pixels in the ImageData object in the form of
          an array. Each pixel on the canvas will have four values in the data array, which
          correspond to that pixel’s R, G, B, and A values. A stands for Alpha, a measure of the element’s transparency, with 0 meaning the element is totally transparent, 1
          meaning it’s totally opaque, and 0.5 meaning it’s 50% transparent.
        </p>
        <pre>
  var canvas = document.getElementById("myCanvas");
  var context = canvas.getContext("2d");
  var image = document.getElementById("myImageElem");
  // draw the image at x=0 and y=0 on the canvas
  context.drawImage(image, 68, 68);
  var imageData = context.getImageData(0, 0, 1, 1);
  var pixelData = imageData.data;
  console.log(pixelData.length);
        </pre>
        <u>Security Errors with getImageData</u>
        <p>
          You may get an error with getImaeData because when you’re
          running the code locally on your computer, you’ll be using the file:// protocol
          to open local files. And files loaded with the file:// protocol are considered to
          come from different domains, which is deemed a security error. The true security 
          issue that Chrome and Firefox are attempting to prohibit is a user
          on one domain manipulating images on another domain. For example, stopping me
          from loading an official logo from http://google.com/ and then manipulating the
          pixel data.
        </p>
        <p>
          Information leakage can occur if scripts from one domain can access
          information (e.g. read pixels) from images from another domain
          (this is called a cross-origin request). To mitigate this, canvas elements
          are defined with a flag indicating whether they are originclean.
        </p>
        <p>
          To help prevent this an origin-flas will be set to false if the image you want to manipulate is on a different domain from the JS doing the manipulating. This flag is set to false in Chrome and Firefox while you're testing from files on your hard drive. If you want to test pixel manipulation using canvas in Firefox or Chrome, you’ll
          need to either test it on a web server running on your computer (http://localhost/),
          or test it online.
        </p>
        <u>Converting an Image from Color to Black and White</u>
        <p>
          To do this we need to use the getImageData(0, 0, 200, 200) to get entire canvas and then use a for loop to get each pixal in the image and change it to gray-scale. In most for loops we increment by 1 but since each pixel has four values (R, G, B, and A) we need to increment by 4.
        </p>
        <p>
          We then need to determine the gray-scale for the current pixel. This can be done with a mathematical formula for converting RGB to grayscale. We just need
          to multiply each of the red, green, and blue values by some specific numbers.
        </p>
        <pre>
  function manipulateImage() {
    ⋮
    for (var i = 0; i < imageData.data.length; i += 4) {
    red = imageData.data[i];
    green = imageData.data[i + 1];
    blue = imageData.data[i + 2];
    <b>grayscale = red * 0.3 + green * 0.59 + blue * 0.11;</b>
  }

  // Once that is one we need to store those values back in to the data array
  <b>imageData.data[i] = grayscale;
  imageData.data[i + 1] = grayscale;
  imageData.data[i + 2] = grayscale;</b>
        </pre>
        <p>
          To plave the image back into the canvase we need to use the putImageData method.
        </p>
        <pre>
  function manipulateImage() {
    var canvas = document.getElementById("demo7");
    var context = canvas.getContext("2d");
    var image = document.getElementById("secondImage");
    context.drawImage(image, 60, 60);
    var imageData = context.getImageData(0, 0, 200, 200);
    for (var i = 0; i < imageData.data.length; i += 4) {
      var red = imageData.data[i];
      var green = imageData.data[i + 1];
      var blue = imageData.data[i + 2];
      var grayscale = red * 0.3 + green * 0.59 + blue * 0.11;
      imageData.data[i] = grayscale;
      imageData.data[i + 1] = grayscale;
      imageData.data[i + 2] = grayscale;
    }
    <b>context.putImageData(imageData, 0, 0);</b>
  }
        </pre>
        <u>Manipulating Video with Canvas</u>
        <p>
          We still start out by setting up the canvas and the context.
        </p>
        <pre>
  <b>function makeVideoOldTimey() {
    var video = document.getElementById("video");
    var canvas = document.getElementById("canvasOverlay");
    var context = canvas.getContext("2d");
  }</b>

  // Then an addEventListener is used to call the draw function when the play event fires
  <b>video.addEventListener("play", function() {
    draw(video,context,canvas);
  }, false);</b>
        </pre>
        <p>
          There is a lot of things that you need to check when doing this. Things like checking to see if the videos is paused or ended. Since we want to pass several parameters to the draw function—video, context,
          and canvas—we must call it from inside an anonymous function. This is what the anonymous draw function would look like.
        </p>
        <pre>
  <b>function draw(video, context, canvas) {
    if (video.paused || video.ended) return false;
    drawOneFrame(video, context, canvas);
  }</b>
        </pre>
        <p>
          The drawOneFrame function is nearly
          identical to the code we had earlier for converting an image from color to black and
          white, except that we’re drawing the video element onto the canvas instead of a
          static image.
        </p>
        <pre>
  <b>function drawOneFrame(video, context, canvas){
    // draw the video onto the canvas
    context.drawImage(video, 0, 0, canvas.width, canvas.height);

    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    var pixelData = imageData.data; 
    // Loop through the red, green and blue pixels, 
    // turning them grayscale
    
    var red, green, blue, greyscale;  
    for (var i = 0; i < pixelData.length; i += 4) {
      red = pixelData[i];
      green = pixelData[i + 1];
      blue = pixelData[i + 2];
      //we'll ignore the alpha value, which is in position i+3
          
      grayscale = red * 0.3 + green * 0.59 + blue * 0.11;
          
      pixelData[i] = grayscale;
      pixelData[i + 1] = grayscale;
      pixelData[i + 2] = grayscale;
    }
            
    context.putImageData(imageData, 0, 0); 
  }</b>
        </pre>
        <p>
          The setTimeout method allows us to keep calling the draw function over and over
again, without pause. The final parameter is the value for delay, which tells the
browser how long, in milliseconds, to wait before calling the function. We need to add this to the draw function.
        </p>
        <pre>
  // Start over!
  <b>setTimeout(function(){ draw(video, context, canvas); }, 0);</b>
        </pre>
        <u>Displaying Text on the Canvas</u>
        <p>
          There is so much here what I wanted to capture is how to change the text. These 
          lines of code were added into the catch part of the code to display the error so the user
          know what is going wrong.
        </p>
        <pre>
  // First we should reset the width or height of the canvas
  <b>canvas.width = canvas.width;</b>

  // Change the background color from black to transparent
  <b>canvas.style.backgroundColor = "transparent";</b>
  <b>context.fillStyle = "white";</b>

  // I think this sets the font color to white
  <b><b>context.fillStyle = "white";</b></b>

  // Align the text
  <b>context.textAlign = "left";</b>
  
  // Set the font-family
  <b>context.font = "18px LeagueGothic, Tahoma, Geneva, sans-serif";</b>
        </pre>
        <p>
          As the book says we use the fillText method to draw the text, which takes the text to be drawn and the x,y
          coordinates where it should be placed. Since the message is long they showed how to split it up in sections, placing each one on the canvas
          separately.
        </p>
        <pre>
  <b>context.fillText("There was an error rendering ", 10, 20);  
  context.fillText("the video to the canvas.", 10, 40);
  context.fillText("Perhaps you are viewing this page from", 10, 70);
  context.fillText("a file on your computer?", 10, 90);
  context.fillText("Try viewing this page online instead.", 10, 130);</b>
        </pre>
        <p>
          This is how the catch section would look when put all together.
        </p>
        <pre>
  function drawOneFrame(video, context, canvas){
    context.drawImage(video, 0, 0, canvas.width, canvas.height);

    try {
    …
    } catch (err) {
      // clear the canvas 
      context.clearRect(0,0,canvas.width,canvas.height);
      canvas.style.backgroundColor = "transparent";
      context.fillStyle = "white";
      context.textAlign = "left";
      context.font = "18px LeagueGothic, Tahoma, Geneva, sans-serif";
      context.fillText("There was an error rendering ", 10, 20);  
      context.fillText("the video to the canvas.", 10, 40);
      context.fillText("Perhaps you are viewing this page from", 10, 70);
      context.fillText("a file on your computer?", 10, 90);
      context.fillText("Try viewing this page online instead.", 10, 130); 

      return false; 
    }
  }
        </pre>
        <p>
          As a last step, we return false. This lets us check in the draw function whether an
          exception was thrown. If it was, we want to stop calling drawOneFrame for each
          video frame, so we exit the draw function
        </p>
        <pre>
  function draw(video, context, canvas) {
    if (video.paused || video.ended) return false;

    <b>drawOneFrame(video, context, canvas);</b>
    
    // Start over!
    setTimeout(function(){ draw(video, context, canvas); }, 0);
  }
        </pre>
        <u>Accessibility Concerns</u>
        <p>
          A major downside of canvas in its current form is its lack of accessibility. The canvas
          doesn’t create a DOM node, is not a text-based format, and is thus essentially invisible
          to tools such as screen readers. Even though we wrote text to the
          canvas in our last example, that text is essentially no more than a bunch of pixels
          and is therefore inaccessible―it’s just like an image that contains text.
        </p>
        <h2>SVG</h2>
        <p>
          SVG stands for Scalable Vector Graphics, a specific file
          format that allows you to describe vector graphics using XML (eXtensible Markup Language). A major selling point
          of vector graphics in general is that, unlike bitmap images (such as GIF, JPEG, PNG,
          and TIFF), vector images preserve their quality even as you blow them up or shrink
          them down. We can use SVG to do many of the same tasks we can do with canvas,
          including drawing paths, shapes, text, gradients, and patterns.
        </p>
        <p>
          Drawing a circle in SVG is arguably easier than drawing a circle with canvas. Here’s
          how we do it:
        </p>
        <pre>
  <b>&#60;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400">
    &#60;circle cx="50" cy="50" r="25" fill="red"/>
  &#60;/svg></b>
        </pre>
          <figure>
            <img src="./images/svgCircle.jpg" alt="A circle drawn using SVG">
            <figcaption>Figure 12.11. A circle drawn using SVG</figcaption>
          </figure>
          <p>
            It is cool that I can just have this code in the HTML file and it shows but it was easier at this point to show the image of how it would look. For some reason the area is hugh when I just use the svg tag.
          </p>
          <p>
            Here is how you could make a rectangle.
          </p>
          <pre>
  &#60;svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 400 400">
  &#60;desc>Drawing a rectangle</desc>
  <b>&#60;rect x="10" y="10" width="100" height="100"
    fill="blue" stroke="red" stroke-width="3" /></b>
  &#60;/svg>
          </pre>
          <figure>
            <img src="./images/svgRectangle.jpg" alt="A rectangle drawn with SVG">
              <figcaption>Figure 12.12. A rectangle drawn with SVG</figcaption>
          </figure>
          <p>
            Not all shapes are this easy. If you want to create complex shapes the code can look scary. Here is part of the code that was shared in the book:
          </p>
          <pre>
  style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:2.761343;
  stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;
  stroke-dasharray:none;stroke-dashoffset:0" d="m 249.28667,389.00422 -9.7738,
  30.15957 -31.91999,7.5995 c - 2.74681,1.46591 -5.51239,2.92436 -1.69852,
  6.99979 l 30.15935,12.57 796 -11.80876,32.07362 c -1.56949,4.62283 -0.21957,
  6.36158 4.24212,3.35419 l 26.59198,-24.55691 30.9576,17.75909 c 3.83318,
  2.65893 6.12086,0.80055 5.36349,-3.57143 l -12.10702,-34.11764 22.72561,
  -13.7066 c 2.32805,-1.03398 5.8555,-6.16054 -0.46651,-6.46042 l -33.5 0135,
  -0.66887 -11.69597,-27.26175 c -2.04282,-3.50583 -4.06602,-7.22748 -7.06823,
  -0.1801 z"
          </pre>
          <p>
            As I go through all this, I am thinking to myself, when I have time I should try to add the HTML code to my index file and tie it to the CSS & JS that is added so I can see it broken down from section instead of it complete from the files canvas folder in my GitHub.
          </p>
          <u>Drawing an Image to Raphaël’s Container</u>
          <p>
            Here is the code for the Raphaël container.
          </p>
          <pre>
  &#60;article class="ad-ad4">
    &#60;div id="mapDiv">
      &#60;h1 id="geoHeading">Where in the world are you?&#60;/h1>
        &#60;form id="geoForm">
        &#60;input type="button" id="geobutton" value="Tell us!">
        &#60;/form>
      <b>&#60;div class="spin" id="spinner">&#60;/div></b> // Spinner is placed
    &#60;/div>
  &#60;/article>
          </pre>
          <p>
            The element is passed to the Raphael method.
          </p>
          <pre>
  <b>var container = Raphael(document.getElementById("spinner"), 125, 125);</b>
          </pre>
          <p>
            We then draw the spinner SVG image into the newly created container with the
            Raphaël method image, which is called on a Raphaël container object. This method
            takes the path to the image, the starting coordinates where the image should be
            drawn, and the width and height of the image.
          </p>
          <pre>
  // This code our spinner image will appear once the geolocation code begins to
  // run, and will spin until the map is displayed.
  <b>var spinner = container.image("images/spinnerBW.svg", 0, 0, 125, 125);</b>
          </pre>
          <p>
            We create a new object attrsToAnimate specifying that we want to animate the rotation,
            and we want to rotate by 720 degrees (two full turns).
          </p>
          <pre>
  <b>var attrsToAnimate = { transform: "r720" };</b>
          </pre>
          <p>
            The final step is to call the animate method, and specify how long the animation
            should last.
          </p>
          <pre>
  <b>spinner.animate(attrsToAnimate, 60000);</b>
          </pre>
          <p>
            Once the map is completely loaded we need to not have the spinner showing
          </p>
          <pre>
  <b>function displayOnMap(position) {
    document.getElementById("spinner").style.display = "none";
  }</b>
          </pre>
          <u>Canvas versus SVG</u>
          <p>
            The book says it depends on what we are doing and that goes with many other ways we can create our web page. It all depends on what we are doing. They both have their benefits, but if a person was designing a game canvas would be the way to go because they can require a lof of animations.
          </p>
          <p>
            If you need to paint pixels to the screen and have no concerns about
            the ability to retrieve and modify your shapes, canvas is probably the better choice.
            If, on the other hand, you need to be able to access and change specific aspects of
            your graphics, SVG might be more appropriate.
          </p>
          <h2>Drag and Drop</h2>

      <!--    NOTES GO ABOVE HERE     -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!--         -->
      <!-- This is where my questions are added. This is to help me know that I
      will be continuing my notes above this sectin. -->
    </main>

    <!-- FOOTER HERE -->
    <footer></footer>
  </body>
</html>
