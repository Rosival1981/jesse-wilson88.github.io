<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="description" content="infomation about site." />
    <meta name="author" content="Jesse Wilson" />

    <!-- SITE TITLE -->
    <title>Week 9 Notes & Codes</title>

    <!-- TELLS PHONES NOT TO LIE ABOUT THEIR WIDTH & stops the font from
      enlarging when a phone is turned sideways-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- STYLE SHEETS -->
    <link href="css/normalize.css" rel="stylesheet" />
    <!-- phone-default -->
    <link href="css/small.css" rel="stylesheet" />
    <!-- enhance-tablet -->
    <link href="css/medium.css" rel="stylesheet" />
    <!-- enhance-desktop -->
    <link href="css/large.css" rel="stylesheet" />
    <link href="css/animation.css" rel="stylesheet" />

    <!-- JAVASCRIPTS-->
    <script defer src="js/styles.js"></script>
    <script defer src="js/animation.js"></script>
    <script defer src="js/main.js"></script>
    <script defer src="js/factors.js"></script>
    <script defer src="js/canvas.js"></script>
  </head>
  <body>
    <!-- HEADER HERE -->
    <header id="headerWrapper">
      <h1>Week 9 Notes & Codes</h1>
    </header>

    <!-- NAVIGATION HERE -->
    <nav></nav>

    <!-- CONTENT HERE -->
    <main>
      <h1>
        <a
          href="https://www.sitepoint.com/premium/books/javascript-novice-to-ninja-2nd-edition/read/9"
          target="_blank"
          >The Window Object</a
        >
      </h1>
      <u>The Browser Object Model</u>
      <p>
        Browser Object Model (or BOM for short) is a collection of properties
        and methods that contain information about the browser and computer
        screen. There is no official standard for the BOM, although there are a
        number of properties and methods that are supported by all the major
        browsers, making a sort of de facto standard. These properties and
        methods are made available through the window object. Every browser
        window, tab, popup, frame, and iframe has a window object.
      </p>
      <u>Going Global</u>
      <p>
        Global variables are variables that are created without using the const,
        let or var keywords. Global variables can be accessed in all parts of
        the program. Global variables are actual properties of a global object.
        In a browser environment, the global object is the window object. Any
        global variable created is actually a property of the window object.
      </p>
      <pre>
  <b>x = 6;</b> // global variable created
  << 6

  <b>window.x</b> // same variable can be accessed as a property of the window object
  << 6
  
  <b>window.x === x;</b> // both variables are exactly the same
  &#60;&#60; true
      </pre>
      <p>
        We should refer to global variables without using the window object;
        it’s less typing and your code will be more portable between
        environments unless we need to check whether a global variable has been
        defined.
      </p>
      <pre>
  <b>if (x) {</b>
    // do something
  <b>}</b>
      </pre>
      <p>
        If the variable is accessed as a property of the window object, then the
        code will still work, as window.x will simply return false,
      </p>
      <pre>
  <b>if (window.x) {</b>
    // do something
  <b>}</b>
      </pre>
      <p>
        The parseInt() and isNaN(), are actually methods of the global object,
        which in a browser environment makes them methods of the window object.
      </p>
      <pre>
  <b>window.parseInt(4.2);</b>
  &#60;&#60; 4

  <b>window.isNaN(4.2);</b>
  &#60;&#60; false

  // ES6 made parseInt() and isNaN() methods of the Number object
  <b>Number.parseInt(4.2);</b>
  &#60;&#60; 4

  <b>Number.isNaN(4.2);</b>
  &#60;&#60; false
      </pre>
      <u>Dialogs</u>
      <p>
        The alert(), confirm() and prompt() functions produce dialogs in the
        browswer. All browsers support these as methods of the window object.
      </p>
      <p>
        The window.alert() method will pause the execution of the program and
        display a message in a dialog box. The message is provided as an
        argument to the method, and undefined is always returned.
      </p>
      <pre>
  <b>window.alert('Hello');</b>
  &#60;&#60; undefined
      </pre>
      <p>
        The window.confirm() method will stop the execution of the program and
        display a confirmation dialog that shows a message with options of OK
        and cancel.
      </p>
      <pre>
  <b>window.confirm('Do you wish to continue?');</b>
  &#60;&#60; undefined
      </pre>
      <p>
        The window.prompt() method will stop the execution of the program and
        prompt the user to enter some text with options of OK and cancel. The
        text is returned if the user clicks OK or null of the user clicks
        cancel.
      </p>
      <pre>
  <b>window.prompt('Please enter your name:');</b>
      </pre>
      <h2>Browser Information</h2>
      <p>
        The window object has a number of properties and methods that provide
        information about the user’s browser.
      </p>
      <u>Which Browser?</u>
      <p>
        The window object has a navigator property that returns a reference to
        the Navigator object. The Navigator object contains information about
        the browser being used. Its userAgent property will return information
        about the browser and operating system being used. For example, if I run
        the following line of code, it shows that I am using Safari version 10
        on Mac OS. Don't rely on this information because it can be masquerade a
        different browser.
      </p>
      <pre>
  <b>window.navigator.userAgent</b>
  &#60;&#60; "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/602.4.8 (KHTML, like Gecko) Version/10.0.3 Safari/602.4.8"
      </pre>
      <u>Location, Location, Location</u>
      <p>
        The window.location property is an object that contains a number of
        properties that provide information about different fragments of the
        URL.
      </p>
      <pre>
  // The href property returns the full URL as a string
  <b>window.location.href</b>
  &#60;&#60; "https://www.sitepoint.com/premium/books/javascript-novice-to-ninja"

  // We can assign the property where we want to go
  <b>window.location.href = 'https://www.sitepoint.com/javascript/'</b>
  &#60;&#60; "https://www.sitepoint.com/javascript/"

  // The protocol property returns a string describing the protocol used (such 
  // as http, https, pop2, ftp, etc.)
  <b>window.location.protocol</b>
  &#60;&#60; "https:"

  // The host property returns a string describing the domain of the current URL
  <b>window.location.host</b>
  &#60;&#60; << "www.sitepoint.com"

  // The hostname property returns a string describing the domain of the current URL
  <b>window.location.hostname</b>
  &#60;&#60; "www.sitepoint.com"

  // The port property returns a string describing the port number but it will
  // return an empty string if the port is not stated in the URL
  <b>window.location.port</b>
  &#60;&#60; ""

  // The pathname property returns a string of the path that follows the domain
  <b>window.location.pathname</b>
  &#60;&#60; "/premium/books/javascript-novice-to-ninja"

  // The search property returns a string that starts with a '?' followed by the query
  // string parameters. It returns an empty string if there are no query string parameters.
  <b>window.location.search</b>
  &#60;&#60; "?q=javascript&limit=24&offset=0&page=1&content_types[]=All&slugs[]=all&states[]=available&amp;order="

  // The hash property returns a string that starts with a "#" followed by the fragment
  // identifier. It returns an empty string if there is no fragment identifier
  <b>window.location.hash</b>
  &#60;&#60; ""

  // The origin property returns a string that shows the protocol and domain where
  // the current page originated from. This property is read-only, so cannot be changed
  <b>window.location.origin</b>
  &#60;&#60; "https://www.sitepoint.com"
      </pre>
      <p>The window.location object also has methods that can be used</p>
      <pre>
  // The reload() method can be used to force a reload of the current page. 
  // The browser will be forced to reload if a parameter of true is given.
  // Other wise it will reload from the cache.
  <b>window.location.reload()</b>

  // The assign() method can be used to load another resource from a URL
  // provided as a parameter.
  <b>window.location.assign('https://www.sitepoint.com/')</b>

  // The replace() method is almost the same as the assign() method, except the
  // current page will not be stored in the session history, so the user will be
  // unable to navigate back to it using the back button.
  <b>window.location.replace(''https://www.sitepoint.com/');</b>

  // The toString() method returns a string containing the whole URL.
  <b>window.location.toString();</b>
  &#60;&#60; "https://www.sitepoint.com/javascript/"
      </pre>
      <h2>The Browser History</h2>
      <p>
        The window.history property can be used to access information about any
        previously visited pages in the current browser session.
      </p>
      <pre>
  // The window.history.length property shows how many pages have been visited
  // before arriving at the current page.
  <b>window.history.length</b>
  &#60;&#60; 3

  // The window.history.go() method can be used to go to a specific page, where 0
  / is the current page.
  <b>window.history.go(1);</b> // goes forward 1 page
  <b>window.history.go(0);</b> // reloads the current page
  <b>window.history.go(-1);</b> // goes back 1 page

  // A method used to navigate forwards by one page
  <b>window.history.forward()</b>
  
  // A method used to navigate backwards by one page
  <b>window.history.back()</b>
      </pre>
      <h2>Controlling Windows</h2>
      <p>
        A new window can be opened using the window.open() method. You can
        assign window.open() method to a variable.
      </p>
      <pre>
  //                       (           URL         , Window Title, list of attributes                 ) 
  <b>const popup = window.open('https://sitepoint.com', 'SitePoint' ,'width=400,height=400,resizable=yes');</b>

  // The close() method can be used to close a window, assuming you have a
  // reference to it
  <b>popup.close();</b>

  // It is possible to move a window by passing parameters (x & y coords)
  <b>window.moveTo(0,0);</b> // will move the window to the top-left corner of the screen
      </pre>
      <h2>Screen Information</h2>
      <p>
        You can use window.screen to find out the height & width of the screen
        the browser is displayed on in pixels.
      </p>
      <pre>
  <b>window.screen.height</b>
  &#60;&#60; 1024

  <b>window.screen.width</b>
  &#60;&#60; 1280

  // The availHeight and availWidth can be used to find the height and width of the
  // screen, excluding any operating system menus.
  <b>window.screen.availWidth</b>
  &#60;&#60; 1024

  <b>window.screen.availHeight</b>
  &#60;&#60; 1280

  // The colorDepth property can be used to find the color bit depth of the user’s
  // monitor even though it is not really used for anything other than collecting user statistics.
  <b>window.screen.colorDepth;</b>
  &#60;&#60; 24
      </pre>
      <h2>The Document Object</h2>
      <p>
        Each window object contains a document object. This object has
        properties and methods that deal with the page that has been loaded into
        the window. The document object contains a few other methods that are
        worth looking at.
      </p>
      <u>write() method</u>
      <pre>
  // The write() method simply writes a string of text to the page. If a page has
  //already loaded, it will completely replace the current document
  <b>document.write('Hello, world!');</b>

  // It is
  possible to include HTML in the string and become part of the DOM tree.
  <b>document.write('&#60;h1>Hello, world!&#60;/h1>');</b>

  // It can also be used within a document inside
  &#60;script> tags to inject a string into the markup. This will NOT overwrite the rest
  of the HTML on the page.
  <b>&#60;h1>
  &#60;script>document.write("Hello, world!")&#60;/script>
  &#60;/h1></b>
      </pre>
      <u>Cookies</u>
      <p>
        Cookies are small files that are saved locally on a user’s computer.
        Cookies can be used to sidestep this problem by storing information that
        can then be retrieved between requests. Cookies can be used for
        personalizing a user’s browsing experience, storing user preferences,
        keeping track of user choices (such as a shopping cart), authentication
        and tracking users.
      </p>
      <pre>
  // A cookie file might contain the following information:
  "name=Superman; hero=true; city=Metropolis"
      </pre>
      <u>Creating Cookies</u>
      <pre>
  <b>document.cookie = 'name=Superman';</b>
  &#60;&#60; "name=Superman"

  // You can add more cookies by assigning them to document.cookie.
  <b>document.cookie = 'hero=true';</b>
  &#60;&#60; "hero=true"

  <b>document.cookie = 'hero=true';</b>
  &#60;&#60; "city=Metropolis"
      </pre>
      <u>Changing Cookie Values</u>
      <pre>
  <b>document.cookie = 'name=Batman'</b>
  &#60;&#60; "name=Batman"

  <b>document.cookie = 'city=Gotham'</b>
  &#60;&#60; "city=Gotham"
      </pre>
      <u>Reading Cookies</u>
      <pre>
  <b>document.cookie:</b>
  &#60;&#60; "name=Batman; hero=true; city=Gotham"

  // We can use the split() method to break the string into an array containing each name/value pair.
  <b>const cookies = document.cookie.split("; ");
  for (crumb of cookies){
    const [key,value] = crumb.split("=");
    console.log(`The value of ${key} is ${value}`);
  }</b>
  &#60;&#60; The value of name is Batman
  &#60;&#60; The value of hero is true
  &#60;&#60; The value of city is Gotham
      </pre>
      <u>Cookie Expiry Dates</u>
      <pre>
  <b>const expiryDate = new Date();
  const tomorrow = expiryDate.getTime() + 1000 * 60 * 60 * 24;
  expiryDate.setTime(tomorrow);
  
  document.cookie = `name=Batman; expires=${expiryDate.toUTCString()}`;</b>

  // An alternative is to set the max-age value in seconds.
  <b>document.cookie = 'name=Batman; max-age=86400' // 86400 secs = 1 day</b>
      </pre>
      <u>The Path and Domain of Cookies</u>
      <p>
        By default, cookies can only be read by pages inside the same directory
        and domain as the file was set. This is for security reasons so that
        access to the cookie is limited. The path can be changed so that any
        page in the root directory can read the cookie.
      </p>
      <pre>
  <b>document.cookie = 'name=Batman; path=/'</b>

  // This is what it would look like for the sitepoint website
  document.cookie = 'name=Batman; domain=sitepoint.com';
      </pre>
      <u>Secure Cookies</u>
      <pre>
  <b>document.cookie = 'name=Batman; secure';</b>
      </pre>
      <u>Deleting Cookies</u>
      <pre>
  // To remove a cookie, you need to set it to expire at a time in the past
  <b>document.cookie = 'name=Batman; expires=Thu, 01 Jan 1970 00:00:01 GMT';</b>
      </pre>
      <h2>Timing Functions</h2>
      <u>setTimeout()</u>
      <p>
        The window.setTimeout() method accepts a callback to a function as its
        first parameter and a number of milliseconds as its second parameter.
      </p>
      <pre>
  // Show an alert dialog after three seconds (that’s 3000 milliseconds):
  <b>window.setTimeout( () => alert("Time's Up!"), 3000);</b>
  &#60;&#60; 4 // Not sure what this is but it goes up every time.

  // You can prevent the alert from popping up if you can type the next line of code with the number that was generated from the code above.
  <b>window.clearTimeout(4);</b>
  &#60;&#60; undefined 
      </pre>
      <u>setInterval()</u>
      <p>
        The window.setInterval() method works in a similar way to
        window.setTimeout(), except that it will repeatedly invoke the callback
        function after every given number of milliseconds.
      </p>
      <pre>
  // It is also possible to use a named function
  <b>function chant(){ console.log('Beetlejuice'); }</b>

  // Set up the interval and assign it to a variable
  <b>const summon = window.setInterval(chant,1000);</b>
  &#60;&#60; 6

  // The setInterval can be interrupted
  <b>window.clearInterval(summon);</b>
      </pre>
      <u>Animation</u>
      <p>Here is the given code for the following animation examples:</p>
      <pre>
  // HTML Code
  <b>&#60;!DOCTYPE html>
  &#60;html lang="en">
    &#60;head>
      &#60;meta charset="utf-8" />
      &#60;title>Animation Example&#60;/title>
      &#60;link rel="stylesheet" href="styles.css" />
    &#60;/head>
    &#60;body>
      &#60;div id="square">&#60;/div>
      &#60;script src="main.js">&#60;/script>
    &#60;/body>
  &#60;/html></b>

  // CSS Code
  <b>#square {
    margin: 20px; /* Originally was 100px */
    width: 100px;
    height: 100px;
    background: #d16;
  }</b>
      </pre>
      <p>
        The second argument is 1000/60, which equates to a frame speed of 60
        frames per second (JavaScript).
      </p>
      <pre>
  <b>const squareElement = document.getElementById("square");

  let angle = 0;

  setInterval(() => {
    angle = (angle + 2) % 360;
    squareElement.style.transform = `rotate(${angle}deg)`;
  }, 1000 / 60);</b>
      </pre>
      <div id="square1"></div>
      <p>requestAnimationFrame example (JavaScript)</p>
      <pre>
  <b>const squareElement = document.getElementById("square");

  let angle = 0;

  function rotate() {
    angle = (angle + 2) % 360;
    squareElement.style.transform = `rotate(${angle}deg)`;
    window.requestAnimationFrame(rotate);
  }

  const id = requestAnimationFrame(rotate);</b>

  // To start the animation, we need to call the requestAnimationFrame() method,
  // giving the rotate() function as an argument. This will return a unique ID that
  // can be employed to stop the animation using the window.cancelAnimationFrame() method. 
  // Not sure where it would be put yet but the animation can be stopped with:
  <b>cancelAnimationFrame(id);</b>
      </pre>
      <div id="square2"></div>
      <div>Pure CSS animation example (CSS)</div>
      <pre>
  <b>#square {
    margin: 20px; /* Originally was 100px */
    width: 100px;
    height: 100px;
    background: #cc0;
    animation: spin 4s linear infinite;
  }
  
  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }</b>
      </pre>
      <div id="square3"></div>
      <h1>
        <a
          href="https://www.sitepoint.com/premium/books/javascript-novice-to-ninja-2nd-edition/read/14"
          target="_blank"
          >HTML5 APIs</a
        >
      </h1>
      <h2>The data- Attribute</h2>
      <p>
        The data- attribute is a way of embedding data in a web page using
        custom attributes that are ignored by the browser. They’re also private
        to a page, so are not intended to be used by an external service – their
        sole purpose is to be used by a JavaScript program. They’re perfect for
        adding data that can be used as a hook that the program utilizes to
        access information about a particular element on the page.
      </p>
      <p>
        The names of these attributes can be decided by the developer, but they
        must use the following format:
      </p>
      <ul>
        <li>Start with data-.</li>
        <li>
          Contain only lowercase letters, numbers, hyphens, dots, colons or
          underscores.
        </li>
        <li>Include an optional string value.</li>
      </ul>
      <pre>
  <b>data-powers = 'flight superSpeed'
  data-rating = '5'
  data-dropdown
  data-user = 'DAZ'
  data-max-length = '32'</b>
      </pre>
      <p>
        The information contained in the attributes can be used to identify
        particular elements. For example, all the elements with an attribute of
        data-dropdown could be identified as dropdown menu. The values of the
        attributes can also be used to filter different elements. For example,
        we could find all the elements that have a data-rating value of 3 or
        more.
      </p>
      <p>
        Each element has a dataset property that can be used to access any
        dataattributes it contains. Here’s an example of some markup:
      </p>
      <pre>
  <b><div id='hero' data-powers='flight superSpeed'>
    Superman
  </div></b>
      </pre>
      <p>The data-powers attribute can be accessed using the following code:</p>
      <pre>
  <b>const superman = document.getElementById('hero');
  const powers = superman.dataset.powers;</b>
  &#60;&#60; 'flight superSpeed'
      </pre>
      <p>
        Notice that the data- prefix is dropped. To access the attribute, powers
        is used as if it’s a property of the dataset object. If a data-
        attribute’s name contains hyphens, they are replaced with camel-case
        notation, so data-max-length would be accessed using dataset.maxLength.
      </p>
      <p>
        any data- attribute can be found using the standard getAttribute method.
        So the previous code could be replaced with the following if you still
        need to support older browsers:
      </p>
      <pre>
  <b>const powers = superman.getAttribute('data-powers');</b>
      </pre>
      <p>
        The restriction of only using a string value can be overcome by encoding
        any JavaScript object or value as a JSON string, then performing
        type-conversion later, as required. For example, the value of
        data-max-length will return a string, but can easily be converted into a
        number using the following code:
      </p>
      <pre>
  <b>const maxLength = Number(element.dataset.maxLength);</b>
      </pre>
      <h2>HTML5 APIs</h2>
      <p>
        The HTML5 specification contains a number of APIs that help to gain
        access to hardware, such as cameras, batteries, geolocation, and the
        graphics card. Hardware evolves quickly, and APIs are frequently
        introduced to give developers access, and control new features that
        appear in the latest devices. Due to the ever-changing nature of most
        APIs, it’s still best practice to use feature detection before using any
        of the API methods.
      </p>
      <u>HTML5 Web Storage</u>
      <p>
        The Web Storage API provides a key-value store on the client’s computer
        that is similar to using cookies but has fewer restrictions, more
        storage capacity, and is generally easier to use. This makes it perfect
        for storing information about users, as well as storing
        application-specific information that can then be used during future
        sessions.
      </p>
      <p>The Web Storage API has some crucial differences with cookies:</p>
      <ul>
        <li>
          Information stored is not shared with the server on every request.
        </li>
        <li>
          Information is available in multiple windows of the browser (but only
          if the domain is the same).
        </li>
        <li>
          Storage capacity limit is much larger than the 4KB limit for cookies.
        </li>
        <li>
          Any data stored does not automatically expire as it does with cookies.
          This potentially makes cookies a better choice for something like
          showing a popup once a day.
        </li>
      </ul>
      <p>
        If a browser supports the Web Storage API, the window object will have a
        property called localStorage, which is a native object with a number of
        properties and methods used to store data. The information is saved in
        the form of key-value pairs, and the values can only be strings. There
        is also a sessionStorage object that works in the same way, although the
        data is only saved for the current session.
      </p>
      <p>
        Here is a basic example of storing information. To save a value locally,
        use:
      </p>
      <pre>
  <b>localStorage.setItem('name', 'Walter White');</b>

  // Retreive the data using getItem()
  <b>localStorage.getItem('name');</b>
  &#60;&#60; "Walter White"

  // Retreive the data using assignment
  <b>localStorage.name = 'Heisenberg';

  console.log(localStorage.name);</b>
  &#60;&#60; "Heisenberg"

  // Remove data from local storage using the removeItem() method
  <b>localStorage.removeItem('name');</b>

  // We can also delete data
  <b>delete localStorage.name;</b>

  // We can also remove all data from local storage
  <b>localStorage.clear();
  </b>
      </pre>
      <p>
        Every time a value is saved to local storage, a storage event is fired.
        Note that this event is only fired on any other windows or tabs from the
        same domain, and only if the value of the item being saved changes. The
        event object sent by the event listener to the callback has a number of
        properties that provide information about the updated item:
      </p>
      <ul>
        <li><b>key</b> tells us the key of the item that changed</li>
        <li>
          <b>newValue</b> tells us the new value to which it has been changed
        </li>
        <li>
          <b>oldValue</b> tells us the previous value before it was changed
        </li>
        <li>
          <b>storageArea</b> tells us if it is stored in local or session
          storage
        </li>
      </ul>
      <p>
        The fact that only strings can be saved might seem like a restriction at
        first, but by using JSON, we can store any JavaScript object in local
        storage.
      </p>
      <pre>
  <b>localStorage.setItem('superman', JSON.stringify(hero);</b>

  // To retrieve the superhero
  <b>superman = JSON.parse(localStorage.getItem('superman'));</b>
      </pre>
      <u>Geolocation</u>
      <p>
        The Geolocation API is used to obtain the geographical position of the
        device and provides a useful interface for adding location-based
        information to a website or application. This can be used to find the
        user’s exact location, link to nearby places or measure the speed at
        which the user is moving and be used to filter data based on the user’s
        location or speed and direction of travel.
      </p>
      <p>
        If geolocation is available, it will be a property of the navigator
        object with a property method called getCurrentPosition() that will
        return a position object to a specified callback function. In this
        example that callback function is called youAreHere():
      </p>
      <pre>
  <b>navigator.geolocation.getCurrentPosition(youAreHere);</b>
      </pre>
      <p>
        The position object passed to the youAreHere() function has a coords
        property with a latitude and longitude property, which together give the
        coordinates of the device. These coordinates can then be used in
        conjunction with other applications or web services (such as a mapping
        service) to obtain the user’s exact location.
      </p>
      <pre>
  <b>function youAreHere(position) {
    console.log(`Latitude: ${position.coords.latitude}, Longitude: ${position.coords.longitude}`);
  }</b>
      </pre>
      <p>
        The position object has several other properties that can be used to
        find out information about the location and movement of the device:
      </p>
      <ul>
        <li>
          position.speed property returns the ground speed of the device in
          meters per second.
        </li>
        <li>
          position.altitude property returns an estimate of the device’s
          altitude in meters above the WGS84 ellipsoid, which is a standard
          measurement for the center of the Earth.
        </li>
        <li>
          position.heading property returns the direction the device is moving
          in. This is measured as a bearing in degrees, clockwise from North.
        </li>
        <li>
          position.timestamp property returns the time that the position
          information was recorded.
        </li>
        <li>
          position.accuracy property returns the accuracy of the latitude and
          longitude properties in meters. This can be useful to know the town or
          city users are in or their exact location.
        </li>
        <li>
          position.altitudeAccuracy property, which returns the accuracy of the
          altitude property in meters.
        </li>
      </ul>
      <p>
        For the position.accuracy & position.altitudeAccuracy property, the
        lower the returned value, the more accurate the measurements are.
      </p>
      <p>
        The geolocation object has a watchPosition() method that will call a
        callback function every time the position of the device is updated. This
        method returns an ID that can be used to reference the position being
        watched.
      </p>
      <pre>
  <b>const id = navigator.geolocation.watchPosition(youAreHere);</b>

  // The clearWatch() method can be used to stop the callback being called, using
  // the ID of the watch as an argument.
  <b>navigator.geolocation.clearWatch(id);</b>
      </pre>
      <u>Web Workers</u>
      <p>
        Web workers allow processes to be run in the background, adding support
        for concurrency in JavaScript. The idea is that any processes that could
        take a long time are carried out in the background, so the website will
        continue to function without getting the “script has become
        unresponsive” message that occurs when a script runs too long.
      </p>
      <p>
        To get started, use the Worker() constructor function to create a new
        worker:
      </p>
      <pre>
  <b>const worker = new Worker('task.js');</b>
      </pre>
      <p>
        This function takes the name of another JavaScript file as an argument.
        In the example, this is a file called task.js. If this file exists, it
        will be downloaded asynchronously. The worker will only start once the
        file has finished downloading completely. If the file doesn’t exist, an
        error is thrown.
      </p>
      <p>
        The variable that’s assigned to the constructor function (worker in our
        example) can now be used to refer to the worker in the main program. In
        the worker script (task.js), the keyword self is used to refer to the
        worker.
      </p>
      <p>
        Web workers use the concept of messages to communicate back and forth
        between the main script and worker script. The postMessage() method can
        be used to send a message and start the worker working. The argument to
        this method can send any data to the web worker. To post a message to
        the worker, the following code is used inside the main script:
      </p>
      <pre>
  <b>worker.postMessage('Hello');</b>
      </pre>
      <p>
        To post a message from the worker, the following is used in the worker
        script:
      </p>
      <pre>
  <b>self.postMessage('Finished');</b>
      </pre>
      <p>
        When a message is posted, a message event is fired, so they can be dealt
        with using an event listener. The data sent with the message as an
        argument is stored in the data property of the event object that’s
        passed to the callback function.
      </p>
      <pre>
  <b>worker.addEventListener('message', (event) => {
    console.log(event.data);
  }, false);</b>

  // When a worker has completed its task, it can be stopped using the terminate()
  // method from within the main script:
  <b>worker.terminate();</b>

  // Or using the close() method from inside the worker script:
  <b>self.close();</b>
      </pre>
      <u>Facorizing Example</u>
      <p>
        The original code given in the book would mess up the page because it
        would have to calculate the factors of a number that had a length of 18
        or more (ex. 180000000000000000). It also showed how to fix this by
        storing the number to be factorized is stored in the event.data
        property. The factorsOf() function is then used to find the factors of
        the number, convert it into a string and then send a message back
        containing the answer. The close() method to terminate the worker, since
        its work is done.
      </p>
      <div id="pre">
        <button id="rainbow">Change Color</button>
        <form>
          <label for="number">Enter a Number to Factorize:</label>
          <input id="number" type="number" name="number" min="1" value="20" />
          <button type="submit">Submit</button>
        </form>
        <div id="output"></div>
      </div>
      <br />
      <u>Shared Web Workers</u>
      <p>
        Web workers allow computationally complex operations to be performed in
        a separate thread, meaning that the flow of a program won’t suffer
        interruptions, and an application will not freeze or hang. They are a
        useful feature that help to keep sites responsive, even when complicated
        operations are being carried out.
      </p>
      <p>
        We can also create shared web workers that allow lots of different
        scripts on the same domain to access the same worker object.
      </p>
      <u>Service Workers</u>
      <p>
        The Service Worker API allows a worker script to run in the background
        with the added benefit of being able to intercept network requests. This
        allows you to take alternative action if the network is offline, and
        effectively create app-like offline experiences. Service workers also
        allow access to push notifications and background syncing. Service
        workers require a secure network to run on HTTPS to avoid any malicious
        code hijacking network requests.
      </p>
      <u>Websockets</u>
      <p>
        Websocket is a new protocol that allows two-way communication with a
        server – also known as push messaging. This means that a connection is
        kept open and responses are ‘pushed’ to the client as soon as they are
        received.
      </p>
      <p>
        I wrote the
        <b><a href="./websocket/websocket.html" target="_blank">code</a></b>
        into a new page so it was seperate. It works when I send a message but
        based on what the book says the response is not working. I will have to
        look at this later when I have more itme. Putting the code to work is
        found on page 551 - 556.
      </p>
      <u>Notifications</u>
      <p>
        The Notification API allows you to show messages using the system’s
        notifications. This is usually a popup in the corner of the screen, but
        it changes depending on the operating system. An advantage of using the
        system notification is that they will still be displayed even if the web
        page that calls them isn’t the current tab.
      </p>
      <p>
        Before you can send notifications, you need to get permission granted by
        the user. This can be achieved using the requestPermission() method of a
        Notification global object.
      </p>
      <pre>
  // Visit any website in your browser and enter the following code in the console
  <b>if(window.Notification) {
    Notification.requestPermission();
  }</b>
      </pre>
      <p>
        If the permission property is set to granted we can create a new
        notification using a constructor function.
      </p>
      <pre>
  // This will produce a system notification with the title “Hello JavaScript!”.
  if(window.Notification) {
    Notification.requestPermission()
    <b>.then((permission) => {
      if(Notification.permission === 'granted') {
        new Notification('Hello JavaScript!');
      }
    });</b>
  }
      </pre>
      <p>
        The constructor function’s first parameter is the title of the
        notification, and is required. The function also accepts a second
        parameter, which is an object of options. These include body that
        specifies any text that you want to appear below the title, and icon
        where you can specify a link to an image that will be displayed as part
        of the notification:
      </p>
      <pre>
  <b>const notification = new Notification('JavaScript: Novice to Ninja',{
    body: 'The new book from SitePoint',
    icon: 'sitepointlogo.png'
  });</b>
      </pre>
      <p>
        Depending on your browser and computer OS, some notifications close
        automatically after a short period of time, and some will stay on the
        screen until the user clicks on them. We can close the notification
        programmatically using the close() method:
      </p>
      <pre>
  <b>notification.close();</b>
      </pre>
      <p>
        The notification instance has a number of events that it can react to,
        including click (when a user clicks on it), show (when the notification
        appears) and close (when the notification is closed).
      </p>
      <pre>
  // Open a new window when the user clicked on the
  // notification using the following code:
  <b>otification.addEventListener('click', () => {
    window.open('https://sitepoint.com')
  }, false);</b>
      </pre>
      <u>Multimedia</u>
      <p>
        Flash was discontinued December 2020. HTML5 introduced the &#60;audio>
        and &#60;video> tags used to insert audio and video clips into a web
        page. It also introduced a Media API for controlling the playback of the
        clips using JavaScript. The controls attribute for
        &#60;audio>&#60;audio> and &#60;video> can be added (without any value)
        and will display the browser’s native controls, such as play, pause, and
        volume control.
      </p>
      <pre>
  // Insert an audio clip by using the &#60;audio> tag and the src attribute to point to the audio file.
  <b>&#60;audio src='/song.mp3' controls>
    Your browser does not support the audio element.
  &#60;/audio></b>

  // Source: https://www.youtube.com/watch?v=Y1fiOJDXA-E&ab_channel=FreddieMercurySolo
<audio src='./media/Freddie Mercury  Montserrat Caballé - Barcelona (Original David Mallet Video 1987 Remastered).mp3' controls>
      Your browser does not support the audio element.
  </audio>
      </pre>
      <pre>
  // Insert an video clip by using the &#60;video> tag and the src attribute to point to the audio file.
  <b>&#60;video src='http://movie.mp4' controls>
    Your browser does not support the audio element.
  &#60;/video></b>

  // Source: https://www.youtube.com/watch?v=Y1fiOJDXA-E&ab_channel=FreddieMercurySolo
  <video src='media/Freddie Mercury  Montserrat Caballé - Barcelona (Original David Mallet Video 1987 Remastered).mp4' controls>
    Your browser does not support the video element.
  </video>
      </pre>
      <p>
        The audio or video element can be referenced by a variable using one of
        the DOM methods.
      </p>
      <pre>
  <b>const video = document.getElementsByTagName('video')[0];</b>
      </pre>
      <p>
        Audio and video elements have a number of properties and methods to
        control the playback of the clip.
      </p>
      <pre>
  // The play() method will start the clip playing from its current position
  <b>video.play();</b>

  // The pause() method will pause the clip at its current position
  <b>video.pause();</b>

  // The volume property is a number that can be used to set the audio volume
  <b>video.volume = 0.9;</b>

  // The muted property is a boolean value that can be used to mute the audio
  <b>video.muted = true;</b>

  // The currentTime property is a number value that can be used to jump to another
  // part of the clip
  <b>video.currentTime += 10;</b> // jumps forward 10 seconds

  // The playbackRate property is used to fast-forward or rewind the clip by
  // changing its value. A value of 1 is playback at normal speed
  <b>video.playbackRate = 8;</b> // fast-forward at 8 times as fast

  // The loop property is a boolean value that can be set to true to make the clip
  // repeat in a loop
  <b>video.loop = true;</b>

  // The duration property can be used to see how long the clip lasts
  <b>video.duration;</b>
  &#60;&#60; 52.209
      </pre>
      <p>
        Some of the properties are only available once the browser has received
        all the metadata associated with the video. This means that, in order to
        ensure a value is returned, you should use an event listener that fires
        once the metadata has loaded, like the one shown below:
      </p>
      <pre>
  <b>video.addEventListener('loadedmetadata', () => {
    console.log(video.duration);
  });</b>
      </pre>
      <p>
        Audio and video clips also have a number of events that will fire when
        they occur, including:
      </p>
      <ul>
        <li>
          The play event, which fires when the clip starts and when it resumes
          after a pause.
        </li>
        <li>The pause event, which fires when the clip is paused.</li>
        <li>The volumechange event, which fires when the volume is changed.</li>
        <li>
          The loadedmetadata event, which we saw in the note above, and which
          fires when all the video’s metadata has loaded.
        </li>
      </ul>
      <p>
        These events allow you to respond to any interactions the user has with
        the video.
      </p>
      <pre>
  // The following event listener can be added to check whether
  the user has paused the video
  <b>video.addEventListener("pause", () => {
      console.log("The video has been paused");
    },
    false
  );</b>
      </pre>
      <p>
        The audio and video elements bring native support for multimedia into
        the browser, and the API gives developers full control of the playback
        of audio tracks and video clips.
      </p>
      <h2>Other APIs</h2>
      <p>
        The list of APIs is constantly growing, and includes APIs for accessing
        a device’s camera, uploading files, accessing the battery status,
        handling push notifications, building drag-and-drop functionality,
        creating 3D effects with WebGL, and many more! A comprehensive list of
        HTML5 APIs can be found at the Mozilla Developer Network.
      </p>
      <p>
        There are some security and privacy considerations to keep in mind when
        considering some HTML5 APIs – especially those on the cutting edge that
        haven’t been used in the wild for long. For example, there are concerns
        that the ambient light API might make it possible to steal data and the
        battery API has been dropped by Apple and Mozilla due to concerns over
        user profiling.
      </p>
      <h2>Drawing with Canvas</h2>
      <p>
        The canvas element was introduced to allow graphics to be drawn onto a
        web page in real time using JavaScript. A canvas element is a
        rectangular element on the web page. It has a coordinate system that
        starts at (0,0) in the top-left corner.
      </p>
      <pre>
  // This is code for the HTML. Each section is modified just to show it seperately:
  <b>&#60;canvas id="canvas" width="400" height="400"
    >Sorry, but your browser does not support the canvas element
  &#60;/canvas></b>
      </pre>
      <p>
        This canvas can now be accessed in a JavaScript program using the
        document.getElementById() method. The following code draws the blue
        rectangle.
      </p>
      <pre>
  <b>const canvasElement = document.getElementById('canvas');</b>

  // The getContext() method is used to access the context:
  <b>const context = canvasElement.getContext('2d');</b>

  // The fill colors can be changed by assigning a CSS color to the fillStyle 
  // property respectively. These colors will be utilized for everything that’s 
  // drawn onto the canvas until they’re changed:
  <b>context.fillStyle = "#0000cc";</b> // a blue fill color

  // The lineWidth property can be used to set the width of any line strokes drawn
  // onto the canvas. It defaults to one pixel and remains the same until it’s changed:
  <b>context.lineWidth = 4;</b>

  // The fillRect() method can draw a filled-in rectangle. The first two parameters
  // are the coordinates of the top-left corner, the third parameter is the width, and the
  // last parameter is the height. The following produces a filled-in blue rectangle in
  // the top-left corner of the canvas at coordinates (10,10) that is 100 pixels wide and
  // 50 pixels high:
  <b>context.fillRect(10,10,100,50);</b>
      </pre>
      <p>The following code draws the gray outlined rectangle.</p>
      <pre>
  <b>const canvasElement = document.getElementById('canvas');</b>

  // The getContext() method is used to access the context:
  <b>const context = canvasElement.getContext('2d');</b>

  // The fill colors can be changed by assigning a CSS color to the strokeStyle 
  // property respectively. These colors will be utilized for everything that’s 
  // drawn onto the canvas until they’re changed:
  <b>context.strokeStyle = "#ccc";</b> // a gray stroke color

  // The lineWidth property can be used to set the width of any line strokes drawn
  // onto the canvas. It defaults to one pixel and remains the same until it’s changed:
  <b>context.lineWidth = 4;</b>

  // The strokeRect() method works in the same way, but produces a rectangle that
  // is not filled in. This will draw the outline of a rectangle underneath the last one:
  <b>context.strokeRect(10,100,100,50);</b>
      </pre>
      <p>The following code draws the red 'T'.</p>
      <pre>
  <b>const canvasElement = document.getElementById('canvas');</b>

  // The getContext() method is used to access the context:
  <b>const context = canvasElement.getContext('2d');</b>

  // Straight lines can be drawn employing the moveTo() and lineTo() methods.
  // These methods can be used together to produce a path. Nothing will actually be
  // drawn onto the canvas until the stroke() method is called. The following
  // example will draw a thick red T shape onto the canvas by moving to the
  // coordinates (130,50), then drawing a horizontal line 30 pixels long, and finally
  // moving to the middle of that line and drawing a vertical line 40 pixels long:
  <b>context.beginPath();
  context.moveTo(130, 50);
  context.lineTo(180, 50);
  context.moveTo(155, 50);
  context.lineTo(155, 90);
  context.strokeStyle = '#c00';
  context.lineWidth = 15;
  context.stroke();</b>
      </pre>
      <p>The following code draws the yellow circle.</p>
      <pre>
  <b>const canvasElement = document.getElementById('canvas');</b>

  // The getContext() method is used to access the context:
  <b>const context = canvasElement.getContext('2d');</b>
  // The arc() method can be used to draw an arc of a given radius from a particular
  // point. The first two parameters are the coordinates of the center of the arc; the
  // next parameter is the radius, followed by the start angle, then the finish angle
  // (note that these are measured in radians). The last parameter is a boolean value
  // that says whether the arc should be drawn counter-clockwise. The following
  // example will draw a yellow circle of radius 30 pixels at center (200,200), since
  // Math.PI * 2 represents a full turn:
  <b>context.beginPath();
  context.arc(200, 200, 30, 0, Math.PI * 2, false);
  context.strokeStyle = '#ff0';
  context.lineWidth = 4;
  context.stroke();</b>
      </pre>
      <p>This draws the green Hello text</p>
      <pre>
  <b>const canvasElement = document.getElementById('canvas');</b>

  // The getContext() method is used to access the context:
  <b>const context = canvasElement.getContext('2d');</b>
  
  // The fillText() method is used to write text onto the canvas. The first parameter
  // is the text to be displayed, while the next two parameters are the x and y
  // coordinates, respectively. The font property can be used to set the font style
  // used, otherwise the style is inherited from the canvas element’s CSS setting (note
  // that it needs to be changed before the fillText() method is used to draw the
  // text). The following example will draw the text “Hello” in green at coordinates
  // (20,50), as shown below.
  <b>context.fillStyle = '#0c0'; // a blue fill color
  context.font = 'bold 26px sans-serif';
  context.fillText('Hello', 20, 200);</b>
      </pre>

      <p>This is the results of the code above.</p>
      <canvas id="canvas" width="400" height="400"
        >Sorry, but your browser does not support the canvas element
      </canvas>
      <h2>Shims and Polyfills</h2>
      <p>
        HTML5 APIs progress at a rapid rate ― new APIs are constantly being
        introduced, and existing APIs often change. We can’t always guarantee
        that users will have the most up-to-date browser. This is where a shim
        or a polyfill comes in handy. These are libraries of code that allow you
        to use the APIs as usual. They then fill in the necessary code that’s
        not provided natively by the user’s browser.
      </p>
      <p>
        The terms shim and polyfill are often used interchangeably. The main
        difference is a piece of code that adds some missing functionality to a
        browser. A polyfill is a shim that achieves the same functionality,
        while also using the API commands that would be used if the feature was
        supported natively.
      </p>
      <p>
        This means that your code can use the APIs as normal and it should work
        as expected in older browsers. The advantage here is that the same set
        of standard API commands can be used ― you don’t need to write
        additional code to deal with different levels of support. And when users
        update their browsers, the transition will be seamless, as their
        experience will remain the same.
      </p>

      <h2>Questions:</h2>
      <p>
        Is there any way to draw multiple canvas drawings and place them in
        different areas of a page? I tried but it seems like there can only be
        one line like this in JavaScript. I tried but I got an error. I tried
        using different ids (canvas1, canvas2, etc.) to seperate different
        areas. I also used different canvasElement (canvasElement1`,
        canvasElement2, etc.), but it did not help.
      </p>
      <pre>
  <b>const context = canvasElement.getContext('2d');</b>
      </pre>
    </main>

    <!-- FOOTER HERE -->
    <footer></footer>
  </body>
</html>
