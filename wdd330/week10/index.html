<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="description" content="infomation about site." />
    <meta name="author" content="Jesse Wilson" />

    <!-- SITE TITLE -->
    <title>Week 10 Notes & Codes</title>

    <!-- TELLS PHONES NOT TO LIE ABOUT THEIR WIDTH & stops the font from
      enlarging when a phone is turned sideways-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- STYLE SHEETS -->
    <link href="css/normalize.css" rel="stylesheet" />
    <!-- phone-default -->
    <link href="css/small.css" rel="stylesheet" />
    <!-- enhance-tablet -->
    <link href="css/medium.css" rel="stylesheet" />
    <!-- enhance-desktop -->
    <link href="css/large.css" rel="stylesheet" />

    <!-- JAVASCRIPTS-->
    <script defer src="js/styles.js"></script>
    <script defer src="js/fetch.js"></script>
  </head>
  <body>
    <!-- HEADER HERE -->
    <header id="headerWrapper">
      <h1>Week 10 Notes & Codes</h1>
    </header>

    <!-- NAVIGATION HERE -->
    <nav></nav>

    <!-- CONTENT HERE -->
    <main>
      <h1>
        <a
          href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation"
          target="_blank"
          >Client-side form validation</a
        >
      </h1>
      <p>
        It is important to make sure that all required form controls are filled
        out before submitting data to the server. This ensures that all the data
        submitted matches the requirements set forth in various form controls.
      </p>
      <p>
        Client-side validation is an initial check and important feature of good
        user experience. This is done by catching invalid data on the
        Client-side, the user can correct right now. If it gets to the server
        and is rejected, there will be a noticeable delay that is caused by a
        round trip to the server and then set back to the Client-side to tell
        the user to fix their data.
      </p>
      <p>
        However, client-side validation should not be considered an exhaustive
        security measure! Our apps should always perform security checks on any
        form-submitted data on the server-side as well as the client-side,
        because client-side validation is too easy to bypass, so malicious users
        can still easily send bad data through to your server.
      </p>
      <h2>What is form validation?</h2>
      <p>
        Any site we go to that has a registration form will give us feedback
        when we don't enter data in the format they are expecting. Messages
        like:
      </p>
      <ul>
        <li>"This field is required" (You can't leave this field blank).</li>
        <li>
          "Please enter your phone number in the format xxx-xxxx" (A specific
          data format is required for it to be considered valid).
        </li>
        <li>
          "Please enter a valid email address" (the data you entered is not in
          the right format).
        </li>
        <li>
          "Your password needs to be between 8 and 30 characters long and
          contain one uppercase letter, one symbol, and a number." (A very
          specific data format is required for your data).
        </li>
      </ul>
      <p>
        This is called form validation. When you enter data, the browser and/or
        the web server will check to see that the data is in the correct format
        and within the constraints set by the application. Validation done in
        the browser is called client-side validation, while validation done on
        the server is called server-side validation.
      </p>
      <p>
        When the user enters the data, requested in the form, correctly it is
        submitted to the server and can be saved in a database. If the data is
        entered incorrectly the user is able to fix those issues/errors based on
        the message given to them and the form can be resubmitted.
      </p>
      <p>
        To make the users experience to fill out forms as easy as possible, here
        are three reasons why we validate our forms:
      </p>
      <ul>
        <li>
          <b>We want to get the right data, in the right format.</b> Our
          applications won't work properly if our users' data is stored in the
          wrong format, is incorrect, or is omitted altogether.
        </li>
        <li>
          <b>We want to protect our users' data.</b> Forcing our users to enter
          secure passwords makes it easier to protect their account information.
        </li>
        <li>
          <b>We want to protect ourselves.</b> There are many ways that
          malicious users can misuse unprotected forms to damage the application
        </li>
      </ul>
      <p id="warning">
        Warning:: Never trust data passed to your server from the client. Even
        if your form is validating correctly and preventing malformed input on
        the client-side, a malicious user can still alter the network request.
      </p>
      <h2>Different types of client-side validation</h2>
      <p>
        There are two different types of client-side validation that you'll
        encounter on the web:
      </p>
      <ul>
        <li>
          <b>Built-in form validation</b> uses HTML5 form validation features,
          which we've discussed in many places throughout this module. This
          validation generally doesn't require much JavaScript. Built-in form
          validation has better performance than JavaScript, but it is not as
          customizable as JavaScript validation.
        </li>
        <li>
          <b>JavaScript</b> validation is coded using JavaScript. This
          validation is completely customizable, but you need to create it all
          (or use a library).
        </li>
      </ul>
      <h2>Using built-in form validation</h2>
      <p>
        Here are some of the abilities to validate some of the users data in
        HTML without the help of JavaScript:
      </p>
      <ul>
        <li>
          <b>required:</b> Specifies whether a form field needs to be filled in
          before the form can be submitted.
        </li>
        <li>
          <b>minlength and maxlength:</b> Specifies the minimum and maximum
          length of textual data (strings).
        </li>
        <li>
          <b>min and max:</b> Specifies the minimum and maximum values of
          numerical input types.
        </li>
        <li>
          <b>type:</b> Specifies whether the data needs to be a number, an email
          address, or some other specific preset type.
        </li>
        <li>
          <b>pattern:</b> Specifies a regular expression that defines a pattern
          the entered data needs to follow.
        </li>
      </ul>
      <p>
        If the data entered follows all of the rules specified by the attributes
        above, it is considered valid.
      </p>
      <p>When an element is valid, the following things are true:</p>
      <ul>
        <li>
          The element matches the :valid CSS pseudo-class, which lets you apply
          a specific style to valid elements.
        </li>
        <li>
          If the user tries to send the data, the browser will submit the form,
          provided there is nothing else stopping it from doing so (e.g.,
          JavaScript).
        </li>
      </ul>
      <p>When an element is invalid, the following things are true:</p>
      <ul>
        <li>
          The element matches the :invalid CSS pseudo-class, and sometimes other
          UI pseudo-classes (e.g., :out-of-range) depending on the error, which
          lets you apply a specific style to invalid elements.
        </li>
        <li>
          If the user tries to send the data, the browser will block the form
          and display an error message.
        </li>
      </ul>
      <h2>Built-in form validation examples</h2>
      <p>
        I don't really need to go through all these little examples right now. I
        am not really good with creating forms, but I to have some knowledge
        that I think I can Google them. But I can click
        <a
          href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation#built-in_form_validation_examples"
          >here</a
        >
        to see where it is talked about in this site. I am not adding everything
        here, just what I need to show an example. Mainly because it is the same
        example over and over with added attributes or CSS for validating the
        data.
      </p>
      Here is the base code given in the page:
      <pre>
  // HTML code
  <b>&#60;form>
    &#60;label for="choose">Would you prefer a banana or cherry?</label>
    &#60;input id="choose" name="i_like">
    &#60;button>Submit&#60;/button>
  &#60;/form></b>

  // CSS code
  <b>input:invalid {
    border: 2px dashed red;
  }
  
  input:valid {
    border: 2px solid black;
  }</b>
      </pre>
      <p>This is how you would use the required attribute:</p>
      <pre>
  // HTML code 
  <b>&#60;input id="choose" name="i_like" required></b>

  // This is what we can do to the CSS to show the user the field is required
  <b>input:invalid:required {
    background-image: linear-gradient(to right, pink, lightgreen);
  }</b>
      </pre>
      <u>Validating against a regular expression</u>
      <p>
        The pattern attribute can be confusing but I am glad we don't have to
        create the validation, we just need to find one that we want and should
        be able to find it from searching the internet. The pattern attribute,
        which expects a Regular Expression as its value. A regular expression
        (regex) is a pattern that can be used to match character combinations in
        text strings, so regexps are ideal for form validation and serve a
        variety of other uses in JavaScript.
      </p>
      <p>Here are some examples of regexps:</p>
      <ul>
        <li>a — Matches one character that is a (not b, not aa, and so on).</li>
        <li>abc — Matches a, followed by b, followed by c.</li>
        <li>
          ab?c — Matches a, optionally followed by a single b, followed by c. (
          ac or abc)
        </li>
        <li>
          ab*c — Matches a, optionally followed by any number of bs, followed by
          c. ( ac , abc, abbbbbc, and so on).
        </li>
        <li>a|b — Matches one character that is a or b.</li>
        <li>
          abc|xyz — Matches exactly abc or exactly xyz (but not abcxyz or a or
          y, and so on).
        </li>
      </ul>
      <pre>
  // HTML code
  <b>&#60;input id="choose" name="i_like" required pattern="[Bb]anana|[Cc]herry"></b>
      </pre>
      <p>
        There are many more possibilities that are not covered on this site
        page. For a complete list and many examples, click
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions"
          >here</a
        >. The &#60;textarea> element doesn't support the pattern attribute.
      </p>
      <u>Constraining the length of your entries</u>
      <p>
        You can constrain the character length of all text fields created by &#60;input> or &#60;textarea> by using the minlength and maxlength attributes. A field is invalid if it has a value and that value has fewer characters than the minlength value or more than the maxlength value.
      </p>
      <pre>
  // HTML code
  <b>&#60;input type="text" id="choose" name="i_like" required minlength="6" maxlength="6"></b>

  <b>&#60;input type="number" id="number" name="amount" value="1" min="1" max="10"></b>
      </pre>
      <p>
        In the example above they used the type of number. There are other types that can be used.
      </p>
      <ul>
        <li>button - Defines a clickable button (mostly used with a JavaScript to activate a script)</li>
        <li>checkbox - Defines a checkbox</li>
        <li>color - Defines a color picker</li>
        <li>date - Defines a date control (year, month, day (no time))</li>
        <li>datetime-local - Defines a date and time control (year, month, day, time (no timezone)</li>
        <li>email - Defines a field for an e-mail address</li>
        <li>file - Defines a file-select field and a "Browse" button (for file uploads)</li>
        <li>hidden - Defines a hidden input field</li>
        <li>image - Defines an image as the submit button</li>
        <li>month - Defines a month and year control (no timezone)</li>
        <li>number - Defines a field for entering a number</li>
        <li>password - Defines a password field</li>
        <li>radio - Defines a radio button</li>
        <li>range - Defines a range control (like a slider control)</li>
        <li>reset - Defines a reset button</li>
        <li>search - Defines a text field for entering a search string</li>
        <li>submit - Defines a submit button</li>
        <li>tel - Defines a field for entering a telephone number</li>
        <li>text - Default. Defines a single-line text field</li>
        <li>time - Defines a control for entering a time (no timezone)</li>
        <li>url = Defines a field for entering a URL</li>
        <li>week - Defines a week and year control (no timezone)</li>
      </ul>
      <p>
        Attributes number, and other types, such as range and date) can also take a step attribute, which specifies what increment the value will go up or down by when the input controls are used (such as the up and down number buttons). In the above example we've not included a step attribute, so the value defaults to 1. This means that floats, like 3.2, will also show as invalid.
      </p>
      <p>
        Here is the full <a href="./form1/" target="_blank">example</a> given on the site to show usage of HTML's built-in validation features.
      </p>
      <h2>Validating forms using JavaScript</h2>
      <p>
        You must use JavaScript if you want to take control over the look and feel of native error messages or to deal with legacy browsers that do not support HTML's built-in form validation. In this section we will look at the different ways to do this.
      </p>
      <u>The Constraint Validation API</u>
      <p>
        Most browsers support the Constraint Validation API, which consists of a set of methods and properties available on the following form element DOM interfaces:
      </p>
      <ul>
        <li>HTMLButtonElement (represents a &#60;button> element)</li>
        <li>HTMLFieldSetElement (represents a &#60;fieldset> element)</li>
        <li>HTMLInputElement (represents an &#60;input> element)</li>
        <li>HTMLOutputElement (represents an &#60;output> element)</li>
        <li>HTMLSelectElement (represents a &#60;select> element)</li>
        <li>HTMLTextAreaElement (represents a &#60;textarea> element)</li>
      </ul>
      <p>
        The Constraint validation API makes the following properties available on the above elements.
      </p>
      <ul>
        <li>validationMessage: Returns a localized message describing the validation constraints that the control doesn't satisfy (if any). If the control is not a candidate for constraint validation (willValidate is false) or the element's value satisfies its constraints (is valid), this will return an empty string.</li>
        <li>validity: Returns a ValidityState object that contains several properties describing the validity state of the element. You can find full details of all the available properties in the ValidityState reference page; below is listed a few of the more common ones:</li>
        <ul>
          <li>patternMismatch: Returns true if the value does not match the specified pattern, and false if it does match. If true, the element matches the :invalid CSS pseudo-class.</li>
          <li>tooLong: Returns true if the value is longer than the maximum length specified by the maxlength attribute, or false if it is shorter than or equal to the maximum. If true, the element matches the :invalid CSS pseudo-class.</li>
          <li>tooShort: Returns true if the value is shorter than the minimum length specified by the minlength attribute, or false if it is greater than or equal to the minimum. If true, the element matches the :invalid CSS pseudo-class.</li>
          <li>rangeOverflow: Returns true if the value is greater than the maximum specified by the max attribute, or false if it is less than or equal to the maximum. If true, the element matches the :invalid and :out-of-range CSS pseudo-classes.</li>
          <li>rangeUnderflow: Returns true if the value is less than the minimum specified by the min attribute, or false if it is greater than or equal to the minimum. If true, the element matches the :invalid and :out-of-range CSS pseudo-classes.</li>
          <li>typeMismatch: Returns true if the value is not in the required syntax (when type is email or url), or false if the syntax is correct. If true, the element matches the :invalid CSS pseudo-class.</li>
          <li>valid: Returns true if the element meets all its validation constraints, and is therefore considered to be valid, or false if it fails any constraint. If true, the element matches the :valid CSS pseudo-class; the :invalid CSS pseudo-class otherwise.</li>
          <li>valueMissing: Returns true if the element has a required attribute, but no value, or false otherwise. If true, the element matches the :invalid CSS pseudo-class.</li>
        </ul>
        <li>willValidate: Returns true if the element will be validated when the form is submitted; false otherwise.</li>
      </ul>
      <p>
        The Constraint Validation API also makes the following methods available on the above elements and the form element
      </p>
      <ul>
        <li>checkValidity(): Returns true if the element's value has no validity problems; false otherwise. If the element is invalid, this method also fires an invalid event on the element.</li>
        <li>reportValidity(): Reports invalid field(s) using events. Useful in combination with preventDefault() in an onSubmit event handler</li>
        <li>setCustomValidity(message): Adds a custom error message to the element; if you set a custom error message, the element is considered to be invalid, and the specified error is displayed. This lets you use JavaScript code to establish a validation failure other than those offered by the standard HTML5 validation constraints. The message is shown to the user when reporting the problem.</li>
      </ul>
      <p>
        Here are some other examples given in the book for validation:
      </p>
      <ul>
        <li><a href="./form2/">Form 2</a></li>
        <li><a href="./form3/">Form 3</a></li></li>
      </ul>
      <h1><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">Using Fetch</a></h1>
      <p>
        The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.
      </p>
      <p>
        This kind of functionality was previously achieved using XMLHttpRequest. Fetch provides a better alternative that can be easily used by other technologies such as Service Workers. Fetch also provides a single logical place to define other HTTP-related concepts such as CORS and extensions to HTTP.
      </p>
      <p>
        The fetch specification differs from jQuery.ajax() in the following significant ways:
      </p>
      <ul>
        <li>The Promise returned from fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500. Instead, as soon as the server responds with headers, the Promise will resolve normally, and it will only reject on network failure or if anything prevented the request from completing.</li>
        <li>fetch() won’t send cross-origin cookies unless you set the credentials init option.</li>
      </ul>
      <p>
        Here is a basic fetch request:
      </p>
      <pre>
  <b>fetch('http://example.com/movies.json')
    .then(response => response.json())
    .then(data => console.log(data));</b>
      </pre>
      <p>
        The example above fetches a JSON file across the network and printing it to the console. The simplest use of fetch() takes one argument. This does not directly return the JSON response body but instead returns a promise that resolves with a Response object.
      </p>
      <p>
        The Response object, in turn, does not directly contain the actual JSON response body but is instead a representation of the entire HTTP response. To extract the JSON body content from the Response object, we use the json() method, which returns a second promise that resolves with the result of parsing the response body text as JSON.
      </p>
      <p>
        Fetch requests are controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.
      </p>
      <u>Supplying request options</u>
      <p>
        The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings:
      </p>
      <pre>
  // Example POST method implementation:
  <b>async function postData(url = "", data = {}) {</b>
    // Default options are marked with *
    <b>const response = await fetch(url, {</b>
      <b>method: "POST",</b> // *GET, POST, PUT, DELETE, etc.
      <b>mode: "cors",</b> // no-cors, *cors, same-origin
      <b>cache: "no-cache",</b> // *default, no-cache, reload, force-cache, only-if-cached
      <b>credentials: "same-origin",</b> // include, *same-origin, omit
      <b>headers: {
        "Content-Type": "application/json",</b>
        // 'Content-Type': 'application/bex-www-form-urlencoded',
      <b>},</b>
      <b>redirect: "follow",</b> // manual, *follow, error
      // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, 
      // strict-origin-when-cross-origin, unsafe-url
      <b>referrerPolicy: "no-referrer",</b> 
      <b>body: JSON.stringify(data),</b> // body data type must match "Content-Type" header
    <b>});</b>
    <b>return response.json();</b> // parses JSON response into native JavaScript objects
  <b>}</b>
  
  <b>postData("https://example.com/answer", { answer: 42 }).then((data) => {</b>
    <b>console.log(data);</b> // JSON data parsed by `data.json()` call
  <b>});</b>
      </pre>
      <p>
        Note that mode: "no-cors" only allows a limited set of headers in the request:
      </p>
      <ul>
        <li>Accept</li>
        <li>Accept-Language</li>
        <li>Content-Language</li>
        <li>Content-Type with a value of application/x-www-form-urlencoded, multipart/form-data, or text/plain</li>
      </ul>
      <u>Sending a request with credentials included</u>
      <p>
        To cause browsers to send a request with credentials included on both same-origin and cross-origin calls, add credentials: 'include' to the init object you pass to the fetch() method.
      </p>
      <pre>
  <b>fetch('https://example.com', {
    credentials: 'include'
  });</b>
      </pre>
      <p>
        If you only want to send credentials if the request URL is on the same origin as the calling script, add credentials: 'same-origin'
      </p>
      <pre>
  // The calling script is on the origin 'https://example.com'
  <b>fetch('https://example.com', {
    credentials: 'same-origin'
  });</b>
      </pre>
      <p>
        To instead ensure browsers don’t include credentials in the request, use credentials: 'omit'.
      </p>
      <pre>
  <b>fetch('https://example.com', {
    credentials: 'omit'
  })</b>
      </pre>
      <u>Uploading JSON data</u>
      <p>
        Use fetch() to POST JSON-encoded data.
      </p>
      <pre>
  <b>const data = { username: 'example' };

    fetch('https://example.com/profile', {
      method: 'POST',</b> // or 'PUT'
      <b>headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    })
    .then(response => response.json())
    .then(data => {
      console.log('Success:', data);
    })
    .catch((error) => {
      console.error('Error:', error);
    });</b>
      </pre>
      <u>Uploading a file</u>
      <p>
        Files can be uploaded using an HTML &#60;input type="file" /> input element, FormData() and fetch().
      </p>
      <pre>
  <b>const formData = new FormData();
  const fileField = document.querySelector('input[type="file"]');
  
  formData.append('username', 'abc123');
  formData.append('avatar', fileField.files[0]);
  
  fetch('https://example.com/profile/avatar', {
    method: 'PUT',
    body: formData
  })
  .then(response => response.json())
  .then(result => {
    console.log('Success:', result);
  })
  .catch(error => {
    console.error('Error:', error);
  });</b>
      </pre>
      <u>Uploading multiple files</u>
      <p>
        Files can be uploaded using an HTML &#60;input type="file" multiple /> input element, FormData() and fetch().
      </p>
      <pre>
  <b>const formData = new FormData();
  const photos = document.querySelector('input[type="file"][multiple]');
  
  formData.append('title', 'My Vegas Vacation');
  for (let i = 0; i < photos.files.length; i++) {
    formData.append(`photos_${i}`, photos.files[i]);
  }
  
  fetch('https://example.com/posts', {
    method: 'POST',
    body: formData,
  })
  .then(response => response.json())
  .then(result => {
    console.log('Success:', result);
  })
  .catch(error => {
    console.error('Error:', error);
  });</b>
      </pre>
      <u>Processing a text file line by line</u>
      <p>
        The chunks that are read from a response are not broken neatly at line boundaries and are Uint8Arrays, not strings.  If I want to fetch a text file and process it line by line, it is up to me to handle these complications.
      </p>
      <pre>
  <b>async function* makeTextFileLineIterator(fileURL) {
    const utf8Decoder = new TextDecoder('utf-8');
    const response = await fetch(fileURL);
    const reader = response.body.getReader();
    let { value: chunk, done: readerDone } = await reader.read();
    chunk = chunk ? utf8Decoder.decode(chunk) : '';
  
    const re = /\n|\r|\r\n/gm;
    let startIndex = 0;
    let result;
  
    for (;;) {
      let result = re.exec(chunk);
      if (!result) {
        if (readerDone) {
          break;
        }
        let remainder = chunk.substr(startIndex);
        ({ value: chunk, done: readerDone } = await reader.read());
        chunk = remainder + (chunk ? utf8Decoder.decode(chunk) : '');
        startIndex = re.lastIndex = 0;
        continue;
      }
      yield chunk.substring(startIndex, result.index);
      startIndex = re.lastIndex;
    }
    if (startIndex < chunk.length) {
      // last line didn't end in a newline char
      yield chunk.substr(startIndex);
    }
  }
  
  async function run() {
    for await (let line of makeTextFileLineIterator(urlOfFile)) {
      processLine(line);
    }
  }
  
  run();</b>
      </pre>
      <u>Checking that the fetch was successful</u>
      <p>
        A fetch() promise will reject with a TypeError when a network error is encountered or CORS is misconfigured on the server-side, although this usually means permission issues or similar — a 404 does not constitute a network error, for example. An accurate check for a successful fetch() would include checking that the promise resolved, then checking that the Response.ok property has a value of true. The code would look something like this:
      </p>
      <pre>
  <b>fetch('flowers.jpg')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not OK');
      }
      return response.blob();
    })
    .then(myBlob => {
      myImage.src = URL.createObjectURL(myBlob);
    })
    .catch(error => {
      console.error('There has been a problem with your fetch operation:', error);
    });</b>
      </pre>
      <u>Supplying your own request object</u>
      <p>
        Instead of passing a path to the resource you want to request into the fetch() call, you can create a request object using the Request() constructor, and pass that in as a fetch() method argument:
      </p>
      <pre>
  <b>const myHeaders = new Headers();

    const myRequest = new Request('flowers.jpg', {
      method: 'GET',
      headers: myHeaders,
      mode: 'cors',
      cache: 'default',
    });
    
    fetch(myRequest)
      .then(response => response.blob())
      .then(myBlob => {
        myImage.src = URL.createObjectURL(myBlob);
      });</b>

  // Request() accepts exactly the same parameters as the fetch() method. You can even pass in an existing request object to create a 
  // copy of it:
  <b>const anotherRequest = new Request(myRequest, myInit);</b>

  // This is pretty useful, as request and response bodies are one use only. Making a copy like this allows you to make use of the 
  // request/response again while varying the init options if desired. The copy must be made before the 
  // body is read, and reading the body in the copy will also mark it as read in the original request
      </pre>
      <h2>Headers</h2>
      <p>
        The Headers interface allows you to create your own headers object via the Headers() constructor. 
      </p>
      <pre>
  // A headers object is a simple multi-map of names to values:
  <b>const content = 'Hello World';
  const myHeaders = new Headers();
  myHeaders.append('Content-Type', 'text/plain');
  myHeaders.append('Content-Length', content.length.toString());
  myHeaders.append('X-Custom-Header', 'ProcessThisImmediately');</b>

  //  The same can be achieved by passing an array of arrays or an object literal to the constructor:
  <b>const myHeaders = new Headers({
    'Content-Type': 'text/plain',
    'Content-Length': content.length.toString(),
    'X-Custom-Header': 'ProcessThisImmediately'
  });</b>

  // The contents can be queried and retrieved:
  <b>console.log(myHeaders.has('Content-Type'));</b> // true
  <b>console.log(myHeaders.has('Set-Cookie'));</b> // false
  <b>myHeaders.set('Content-Type', 'text/html');
  myHeaders.append('X-Custom-Header', 'AnotherValue');</b>

  <b>console.log(myHeaders.get('Content-Length'));</b> // 11
  <b>console.log(myHeaders.get('X-Custom-Header'));</b> // ['ProcessThisImmediately', 'AnotherValue']

  <b>myHeaders.delete('X-Custom-Header');</b>
  <b>console.log(myHeaders.get('X-Custom-Header'));</b> // null
      </pre>
      <p>
        Some of these operations are only useful in ServiceWorkers, but they provide a much nicer API for manipulating headers.
      </p>
      <p>
        All of the Headers methods throw a TypeError if a header name is used that is not a valid HTTP Header name.
      </p>
      <pre>
  // The mutation operations will throw a TypeError if there is an immutable guard. Otherwise, they fail silently.
  <b>const myResponse = Response.error();
  try {
    myResponse.headers.set('Origin', 'http://mybank.com');
  } catch (e) {
    console.log('Cannot pretend to be a bank!');
  }</b>

  // A good use case for headers is checking whether the content type is correct before you process it further.
  <b>fetch(myRequest)
    .then(response => {
       const contentType = response.headers.get('content-type');
       if (!contentType || !contentType.includes('application/json')) {
         throw new TypeError("Oops, we haven't got JSON!");
       }
       return response.json();
    })
    .then(data => {
        /* process your data further */
    })
    .catch(error => console.error(error));</b>
      </pre>
      <u>Guard</u>
      <p>
        Since headers can be sent in requests and received in responses, and have various limitations about what information can and should be mutable, headers' objects have a guard property. This is not exposed to the Web, but it affects which mutation operations are allowed on the headers object. Possible guard values are:
      </p>
      <ul>
        <li>none: default.</li>
        <li>request: guard for a headers object obtained from a request (Request.headers).</li>
        <li>request-no-cors: guard for a headers object obtained from a request created with Request.mode no-cors.</li>
        <li>response: guard for a headers object obtained from a response (Response.headers).</li>
        <li>immutable: guard that renders a headers object read-only; mostly used for ServiceWorkers.</li>
      </ul>
      <p id="note">
        Note: You may not append or set the Content-Length header on a guarded headers object for a response. Similarly, inserting Set-Cookie into a response header is not allowed: ServiceWorkers are not allowed to set cookies via synthesized responses.
      </p>
      <h2>Response objects</h2>
      <p>
        As you have seen above, Response instances are returned when fetch() promises are resolved. The most common response properties you'll use are:
      </p>
      <ul>
        <li>Response.status — An integer (default value 200) containing the response status code.</li>
        <li>Response.statusText — A string (default value ""), which corresponds to the HTTP status code message. Note that HTTP/2 does not support status messages.</li>
        <li>Response.ok — seen in use above, this is a shorthand for checking that status is in the range 200-299 inclusive. This returns a boolean value.</li>
      </ul>
      <p>
        They can also be created programmatically via JavaScript, but this is only really useful in ServiceWorkers, when you are providing a custom response to a received request using a respondWith() method:
      </p>
      <pre>
  <b>const myBody = new Blob();

  addEventListener('fetch', function(event) {
    // ServiceWorker intercepting a fetch
    event.respondWith(
      new Response(myBody, {
        headers: { 'Content-Type': 'text/plain' }
      })
    );
  });</b>
      </pre>
      <p>
        The Response() constructor takes two optional arguments — a body for the response, and an init object (similar to the one that Request() accepts.)
      </p>
      <p id="note">
        Note: The static method error() returns an error response. Similarly, redirect() returns a response resulting in a redirect to a specified URL. These are also only relevant to Service Workers.
      </p>
      <h2>Body</h2>
      <p>
        Both requests and responses may contain body data. A body is an instance of any of the following types: 
      </p>
      <ul>
        <li>ArrayBuffer</li>
        <li>ArrayBufferView</li>
        <li>Blob/File</li>
        <li>string</li>
        <li>URLSearchParams</li>
        <li>FormData</li>
      </ul>
      <p>
        The Request and Response interfaces share the following methods to extract a body. These all return a promise that is eventually resolved with the actual content.
      </p>
      <ul>
        <li>Request.arrayBuffer() / Response.arrayBuffer()</li>
        <li>Request.blob() / Response.blob()</li>
        <li>Request.formData() / Response.formData()</li>
        <li>Request.json() / Response.json()</li>
        <li>Request.text() / Response.text()</li>
      </ul>
      <p>
        This makes usage of non-textual data much easier than it was with XHR. Request bodies can be set by passing body parameters:
      </p>
      <pre>
  <b>const form = new FormData(document.getElementById('login-form'));
  fetch('/login', {
    method: 'POST',
    body: form
  });</b>
      </pre>
      <p>
        Both request and response (and by extension the fetch() function), will try to intelligently determine the content type. A request will also automatically set a Content-Type header if none is set in the dictionary.
      </p>
      <h2>Feature detection</h2>
      <p>
        Fetch API support can be detected by checking for the existence of Headers, Request, Response or fetch() on the Window or Worker scope. For example:
      </p>
      <pre>
  <b>if (window.fetch) {</b>
    // run my fetch request here
  <b>} else {</b>
    // do something with XMLHttpRequest?
  <b>}</b>
      </pre>
      <h2>Polyfill</h2>
      <p>
        To use Fetch in unsupported browsers, there is a Fetch Polyfill available that recreates the functionality for non-supporting browsers.
      </p>
      <p>
        To demonstrate Fetch working, here is a demo pulling the Date, location of the earthquake and the magnitude. Just click the button.
      </p>
      <button onclick="outputdata()">Click</button>
      <ul id="quake"></ul>
    </main>

    <!-- FOOTER HERE -->
    <footer></footer>
  </body>
</html>
